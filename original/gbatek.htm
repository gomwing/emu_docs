<HTML><HEAD>
  <STYLE>
    body,h2{font-size:12px}
    pre,h3{font-size:11px}
    h1,h2,h3{margin:0;display:inline;padding:0}
    h1{font-weight:normal}
    h2,h3{font-weight:bold}
    body,h1,h2{font-family:Arial, Helvetica, sans-serif}
    pre,h3{font-family:monospace, "Courier New", Courier}
    body{max-width:50em}
  </STYLE>
  <TITLE>GBATEK - GBA/NDS Technical Info</TITLE>
  <META NAME="GENERATOR" CONTENT="nocash help engine">
  <META NAME="Author" CONTENT="Nocash Martin Korth">
  <META NAME="KeyWords" CONTENT="specs,specifications,reference,programmers,
   gba,nds,dsi,twl,gameboy advance,nintendo ds,nintendo dsi,arm,asm,dev,
   gbatek,technical,io,ports,memory,hardware,nocash">
</HEAD><BODY bgcolor="#ffffff" text="#000000" link="#0033cc" vlink="#0033cc" alink="#0033cc">
<img src="https://vg07.met.vgwort.de/na/19106c1de2f249d0a54770b609d661ed" width="1" height="1" alt="">


<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dstechnicaldata"></A>
  DS Technical Data
</FONT></TD></TR></TABLE><BR>
<B>Processors</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1x ARM946E-S 32bit RISC CPU, 66MHz (NDS9 video) (not used in GBA mode)
  1x ARM7TDMI  32bit RISC CPU, 33MHz (NDS7 sound) (16MHz in GBA mode)
</TD></TR></TABLE>
<B>Internal Memory</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4096KB Main RAM (8192KB in debug version)
  96KB   WRAM (64K mapped to NDS7, plus 32K mappable to NDS7 or NDS9)
  60KB   TCM/Cache (TCM: 16K Data, 32K Code) (Cache: 4K Data, 8K Code)
  656KB  VRAM (allocateable as BG/OBJ/2D/3D/Palette/Texture/WRAM memory)
  4KB    OAM/PAL (2K OBJ Attribute Memory, 2K Standard Palette RAM)
  248KB  Internal 3D Memory (104K Polygon RAM, 144K Vertex RAM)
  ?KB    Matrix Stack, 48 scanline cache
  8KB    Wifi RAM
  256KB  Firmware FLASH (512KB in iQue variant, with chinese charset)
  36KB   BIOS ROM (4K NDS9, 16K NDS7, 16K GBA)
</TD></TR></TABLE>
<B>Video</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  2x LCD screens (each 256x192 pixel, 3 inch, 18bit color depth, backlight)
  2x 2D video engines (extended variants of the GBA's video controller)
  1x 3D video engine (can be assigned to upper or lower screen)
  1x video capture (for effects, or for forwarding 3D to the 2nd 2D engine)
</TD></TR></TABLE>
<B>Sound</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  16 sound channels (16x PCM8/PCM16/IMA-ADPCM, 6x PSG-Wave, 2x PSG-Noise)
  2 sound capture units (for echo effects, etc.)
  Output: Two built-in stereo speakers, and headphones socket
  Input:  One built-in microphone, and microphone socket
</TD></TR></TABLE>
<B>Controls</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Gamepad      4 Direction Keys, 8 Buttons
  Touchscreen  (on lower LCD screen)
</TD></TR></TABLE>
<B>Communication Ports</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Wifi IEEE802.11b
</TD></TR></TABLE>
<B>Specials</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Built-in Real Time Clock
  Power Managment Device
  Hardware divide and square root functions
  CP15 System Control Coprocessor (cache, tcm, pu, bist, etc.)
</TD></TR></TABLE>
<B>External Memory</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  NDS Slot (for NDS games) (encrypted 8bit data bus, and serial 1bit bus)
  GBA Slot (for NDS expansions, or for GBA games) (but not for DMG/CGB games)
</TD></TR></TABLE>
<B>Manufactured Cartridges</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  ROM: 16MB, 32MB, or 64MB
  EEPROM/FLASH/FRAM: 0.5KB, 8KB, 64KB, 256KB, or 512KB
</TD></TR></TABLE>
<B>Can be booted from</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  NDS Cartridge (NDS mode)
  Firmware FLASH (NDS mode) (eg. by patching firmware via ds-xboo cable)
  Wifi (NDS mode)
  GBA Cartridge (GBA mode) (without DMG/CGB support) (without SIO support)
</TD></TR></TABLE>
<B>Power Supply</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Built-in rechargeable Lithium ion battery, 3.7V 1000mAh (DS-Lite)
  External Supply: 5.2V DC
</TD></TR></TABLE>
<BR>
<B>NDS-Lite</B><BR>
Slightly smaller than the original NDS, coming in a more decently elegant case.
The LCDs are much more colorful (and thus not backwards compatible with any
older NDS or GBA games), and the LCDs support wider viewing angles. Slightly
different power managment device (with selectable backlight brightness, new
external power source flag, lost audio amplifier mute flag). Slightly different
Wifi controller (different chip ID, different dirt effects when accessing
invalid wifi ports and unused wifi memory regions, different behaviour on
GAPDISP registers, RF/BB chips replaced by a single chip). Slightly different
touch screen controller (with new unused input, and slightly different
powerdown bits).<BR>
<BR>
<B>Notice</B><BR>
NDS9 means the ARM9 processor and its memory and I/O ports in NDS mode<BR>
NDS7 means the ARM7 processor and its memory and I/O ports in NDS mode<BR>
GBA means the ARM7 processor and its memory and I/O ports in GBA mode<BR>
<BR>
<B>The two Processors</B><BR>
Most game code is usually executed on the ARM9 processor (in fact, Nintendo
reportedly doesn't allow developers use the ARM7 processor, except by
predefined API functions, anyways, even with the most likely inefficient API
code, most of the ARM7's 33MHz horsepower is left unused).<BR>
The ARM9's 66MHz "horsepower" is a different tale - it seems Nintendo thought
that a 33MHz processor would be too "slow" for 3D games, and so they (tried to)
badge an additional CPU to the original GBA hardware.<BR>
However, the real 66MHz can be used only with cache and tcm, all other memory
and I/O accesses are delayed to the 33MHz bus clock, that'd be still quite
fast, but, there seems to be a hardware glitch that adds 3 waitcycles to all
nonsequential accesses at the NDS9 side, which effectively drops its bus clock
to about 8MHz, making it ways slower than the 33MHz NDS7 processor, it's even
slower than the original 16MHz GBA processor.<BR>
Altogether, with the bugged 66MHz, and the unused 33MHz, Nintendo could have
reached almost the same power when staying with the GBA's 16MHz processor :-)<BR>
Although, when properly using cache/tcm, then the 66MHz processor &lt;can&gt;
be very fast, still, the NDS should have worked as well with a single
processor, though using only an ARM9 might cause a lot of compatibility
problems with GBA games, so there's at least one reason for keeping the ARM7
included.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dsiomaps"></A>
  DS I/O Maps
</FONT></TD></TR></TABLE><BR>
ARM9 I/O Map<BR>
<B>ARM9 Display Engine A</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4000000h  4    2D Engine A - DISPCNT - LCD Control (Read/Write)
  4000004h  2    2D Engine A+B - DISPSTAT - General LCD Status (Read/Write)
  4000006h  2    2D Engine A+B - VCOUNT - Vertical Counter (Read only)
  4000008h  50h  2D Engine A (same registers as GBA, some changed bits)
  4000060h  2    DISP3DCNT - 3D Display Control Register (R/W)
  4000064h  4    DISPCAPCNT - Display Capture Control Register (R/W)
  4000068h  4    DISP_MMEM_FIFO - Main Memory Display FIFO (R?/W)
  400006Ch  2    2D Engine A - MASTER_BRIGHT - Master Brightness Up/Down
</TD></TR></TABLE>
<A HREF="#gbaiomap">GBA I/O Map</A><BR>
<B>ARM9 DMA, Timers, and Keypad</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  40000B0h  30h  DMA Channel 0..3
  40000E0h  10h  DMA FILL Registers for Channel 0..3
  4000100h  10h  Timers 0..3
  4000130h  2    KEYINPUT
  4000132h  2    KEYCNT
</TD></TR></TABLE>
<B>ARM9 IPC/ROM</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4000180h  2  IPCSYNC - IPC Synchronize Register (R/W)
  4000184h  2  IPCFIFOCNT - IPC Fifo Control Register (R/W)
  4000188h  4  IPCFIFOSEND - IPC Send Fifo (W)
  40001A0h  2  AUXSPICNT - Gamecard ROM and SPI Control
  40001A2h  2  AUXSPIDATA - Gamecard SPI Bus Data/Strobe
  40001A4h  4  Gamecard bus timing/control
  40001A8h  8  Gamecard bus 8-byte command out
  40001B0h  4  Gamecard Encryption Seed 0 Lower 32bit
  40001B4h  4  Gamecard Encryption Seed 1 Lower 32bit
  40001B8h  2  Gamecard Encryption Seed 0 Upper 7bit (bit7-15 unused)
  40001BAh  2  Gamecard Encryption Seed 1 Upper 7bit (bit7-15 unused)
</TD></TR></TABLE>
<B>ARM9 Memory and IRQ Control</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4000204h  2  EXMEMCNT - External Memory Control (R/W)
  4000208h  2  IME - Interrupt Master Enable (R/W)
  4000210h  4  IE  - Interrupt Enable (R/W)
  4000214h  4  IF  - Interrupt Request Flags (R/W)
  4000240h  1  VRAMCNT_A - VRAM-A (128K) Bank Control (W)
  4000241h  1  VRAMCNT_B - VRAM-B (128K) Bank Control (W)
  4000242h  1  VRAMCNT_C - VRAM-C (128K) Bank Control (W)
  4000243h  1  VRAMCNT_D - VRAM-D (128K) Bank Control (W)
  4000244h  1  VRAMCNT_E - VRAM-E (64K) Bank Control (W)
  4000245h  1  VRAMCNT_F - VRAM-F (16K) Bank Control (W)
  4000246h  1  VRAMCNT_G - VRAM-G (16K) Bank Control (W)
  4000247h  1  WRAMCNT   - WRAM Bank Control (W)
  4000248h  1  VRAMCNT_H - VRAM-H (32K) Bank Control (W)
  4000249h  1  VRAMCNT_I - VRAM-I (16K) Bank Control (W)
</TD></TR></TABLE>
<B>ARM9 Maths</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4000280h  2  DIVCNT - Division Control (R/W)
  4000290h  8  DIV_NUMER - Division Numerator (R/W)
  4000298h  8  DIV_DENOM - Division Denominator (R/W)
  40002A0h  8  DIV_RESULT - Division Quotient (=Numer/Denom) (R)
  40002A8h  8  DIVREM_RESULT - Division Remainder (=Numer MOD Denom) (R)
  40002B0h  2  SQRTCNT - Square Root Control (R/W)
  40002B4h  4  SQRT_RESULT - Square Root Result (R)
  40002B8h  8  SQRT_PARAM - Square Root Parameter Input (R/W)
  4000300h  4  POSTFLG - Undoc
  4000304h  2  POWCNT1 - Graphics Power Control Register (R/W)
</TD></TR></TABLE>
<B>ARM9 3D Display Engine</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4000320h..6A3h
</TD></TR></TABLE>
<A HREF="#ds3diomap">DS 3D I/O Map</A><BR>
<B>ARM9 Display Engine B</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4001000h  4    2D Engine B - DISPCNT - LCD Control (Read/Write)
  4001008h  50h  2D Engine B (same registers as GBA, some changed bits)
  400106Ch  2    2D Engine B - MASTER_BRIGHT - 16bit - Brightness Up/Down
</TD></TR></TABLE>
<B>ARM9 DSi Extra Registers</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  40021Axh  ..  DSi Registers
  4004xxxh  ..  DSi Registers
</TD></TR></TABLE>
<B>ARM9 IPC/ROM</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4100000h  4    IPCFIFORECV - IPC Receive Fifo (R)
  4100010h  4    Gamecard bus 4-byte data in, for manual or dma read (R) (or W)
</TD></TR></TABLE>
<B>ARM9 DS Debug Registers (Emulator/Devkits)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4FFF0xxh  ..   Ensata Emulator Debug Registers
  4FFFAxxh  ..   No$gba Emulator Debug Registers
</TD></TR></TABLE>
<B>ARM9 Hardcoded RAM Addresses for Exception Handling</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  27FFD9Ch   ..  NDS9 Debug Stacktop / Debug Vector (0=None)
  DTCM+3FF8h 4   NDS9 IRQ Check Bits (hardcoded RAM address)
  DTCM+3FFCh 4   NDS9 IRQ Handler (hardcoded RAM address)
</TD></TR></TABLE>
<B>Main Memory Control</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  27FFFFEh  2    Main Memory Control
</TD></TR></TABLE>
<B>Further Memory Control Registers</B><BR>
<A HREF="#armcp15systemcontrolcoprocessor">ARM CP15 System Control Coprocessor</A><BR>
<BR>
<B>ARM7 I/O Map</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4000004h  2   DISPSTAT
  4000006h  2   VCOUNT
  40000B0h  30h DMA Channels 0..3
  4000100h  10h Timers 0..3
  4000120h  4   Debug SIODATA32
  4000128h  4   Debug SIOCNT
  4000130h  2   KEYINPUT
  4000132h  2   KEYCNT
  4000134h  2   Debug RCNT
  4000136h  2   EXTKEYIN
  4000138h  1   RTC Realtime Clock Bus
  4000180h  2   IPCSYNC - IPC Synchronize Register (R/W)
  4000184h  2   IPCFIFOCNT - IPC Fifo Control Register (R/W)
  4000188h  4   IPCFIFOSEND - IPC Send Fifo (W)
  40001A0h  2   AUXSPICNT - Gamecard ROM and SPI Control
  40001A2h  2   AUXSPIDATA - Gamecard SPI Bus Data/Strobe
  40001A4h  4   Gamecard bus timing/control
  40001A8h  8   Gamecard bus 8-byte command out
  40001B0h  4   Gamecard Encryption Seed 0 Lower 32bit
  40001B4h  4   Gamecard Encryption Seed 1 Lower 32bit
  40001B8h  2   Gamecard Encryption Seed 0 Upper 7bit (bit7-15 unused)
  40001BAh  2   Gamecard Encryption Seed 1 Upper 7bit (bit7-15 unused)
  40001C0h  2   SPI bus Control (Firmware, Touchscreen, Powerman)
  40001C2h  2   SPI bus Data
</TD></TR></TABLE>
<B>ARM7 Memory and IRQ Control</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4000204h  2   EXMEMSTAT - External Memory Status
  4000206h  2   WIFIWAITCNT
  4000208h  4   IME - Interrupt Master Enable (R/W)
  4000210h  4   IE  - Interrupt Enable (R/W)
  4000214h  4   IF  - Interrupt Request Flags (R/W)
  4000218h  -   IE2  ;\DSi only (additional ARM7 interrupt sources)
  400021Ch  -   IF2  ;/
  4000240h  1   VRAMSTAT - VRAM-C,D Bank Status (R)
  4000241h  1   WRAMSTAT - WRAM Bank Status (R)
  4000300h  1   POSTFLG
  4000301h  1   HALTCNT (different bits than on GBA) (plus NOP delay)
  4000304h  2   POWCNT2  Sound/Wifi Power Control Register (R/W)
  4000308h  4   BIOSPROT - Bios-data-read-protection address
</TD></TR></TABLE>
<B>ARM7 Sound Registers</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4000400h 100h Sound Channel 0..15 (10h bytes each)
  40004x0h  4   SOUNDxCNT - Sound Channel X Control Register (R/W)
  40004x4h  4   SOUNDxSAD - Sound Channel X Data Source Register (W)
  40004x8h  2   SOUNDxTMR - Sound Channel X Timer Register (W)
  40004xAh  2   SOUNDxPNT - Sound Channel X Loopstart Register (W)
  40004xCh  4   SOUNDxLEN - Sound Channel X Length Register (W)
  4000500h  2   SOUNDCNT - Sound Control Register (R/W)
  4000504h  2   SOUNDBIAS - Sound Bias Register (R/W)
  4000508h  1   SNDCAP0CNT - Sound Capture 0 Control Register (R/W)
  4000509h  1   SNDCAP1CNT - Sound Capture 1 Control Register (R/W)
  4000510h  4   SNDCAP0DAD - Sound Capture 0 Destination Address (R/W)
  4000514h  2   SNDCAP0LEN - Sound Capture 0 Length (W)
  4000518h  4   SNDCAP1DAD - Sound Capture 1 Destination Address (R/W)
  400051Ch  2   SNDCAP1LEN - Sound Capture 1 Length (W)
</TD></TR></TABLE>
<B>ARM7 DSi Extra Registers</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  40021Axh  ..  DSi Registers
  4004xxxh  ..  DSi Registers
  4004700h  2   DSi SNDEXCNT Register  ;\mapped even in DS mode
  4004C0xh  ..  DSi GPIO Registers     ;/
</TD></TR></TABLE>
<B>ARM7 IPC/ROM</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4100000h  4   IPCFIFORECV - IPC Receive Fifo (R)
  4100010h  4   Gamecard bus 4-byte data in, for manual or dma read (R) (or W)
</TD></TR></TABLE>
<B>ARM7 3DS</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4700000h  4   Disable ARM7 bootrom overlay (W) (3DS only)
</TD></TR></TABLE>
<B>ARM7 WLAN Registers</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4800000h  ..  Wifi WS0 Region (32K) (Wifi Ports, and 8K Wifi RAM)
  4808000h  ..  Wifi WS1 Region (32K) (mirror of above, other waitstates)
</TD></TR></TABLE>
<B>ARM7 Hardcoded RAM Addresses for Exception Handling</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  380FFC0h  4   DSi7 IRQ IF2 Check Bits (hardcoded RAM address) (DSi only)
  380FFDCh  ..  NDS7 Debug Stacktop / Debug Vector (0=None)
  380FFF8h  4   NDS7 IRQ IF Check Bits (hardcoded RAM address)
  380FFFCh  4   NDS7 IRQ Handler (hardcoded RAM address)
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dsmemorymaps"></A>
  DS Memory Maps
</FONT></TD></TR></TABLE><BR>
<B>NDS9 Memory Map</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00000000h  Instruction TCM (32KB) (not moveable) (mirror-able to 1000000h)
  0xxxx000h  Data TCM        (16KB) (moveable)
  02000000h  Main Memory     (4MB)
  03000000h  Shared WRAM     (0KB, 16KB, or 32KB can be allocated to ARM9)
  04000000h  ARM9-I/O Ports
  05000000h  Standard Palettes (2KB) (Engine A BG/OBJ, Engine B BG/OBJ)
  06000000h  VRAM - Engine A, BG VRAM  (max 512KB)
  06200000h  VRAM - Engine B, BG VRAM  (max 128KB)
  06400000h  VRAM - Engine A, OBJ VRAM (max 256KB)
  06600000h  VRAM - Engine B, OBJ VRAM (max 128KB)
  06800000h  VRAM - "LCDC"-allocated (max 656KB)
  07000000h  OAM (2KB) (Engine A, Engine B)
  08000000h  GBA Slot ROM (max 32MB)
  0A000000h  GBA Slot RAM (max 64KB)
  FFFF0000h  ARM9-BIOS (32KB) (only 3K used)
</TD></TR></TABLE>
The ARM9 Exception Vectors are located at FFFF0000h. The IRQ handler redirects
to [DTCM+3FFCh].<BR>
<BR>
<B>NDS7 Memory Map</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00000000h  ARM7-BIOS (16KB)
  02000000h  Main Memory (4MB)
  03000000h  Shared WRAM (0KB, 16KB, or 32KB can be allocated to ARM7)
  03800000h  ARM7-WRAM (64KB)
  04000000h  ARM7-I/O Ports
  04800000h  Wireless Communications Wait State 0 (8KB RAM at 4804000h)
  04808000h  Wireless Communications Wait State 1 (I/O Ports at 4808000h)
  06000000h  VRAM allocated as Work RAM to ARM7 (max 256K)
  08000000h  GBA Slot ROM (max 32MB)
  0A000000h  GBA Slot RAM (max 64KB)
</TD></TR></TABLE>
The ARM7 Exception Vectors are located at 00000000h. The IRQ handler redirects
to [3FFFFFCh aka 380FFFCh].<BR>
<BR>
<B>Further Memory (not mapped to ARM9/ARM7 bus)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  3D Engine Polygon RAM (52KBx2)
  3D Engine Vertex RAM (72KBx2)
  Firmware (256KB) (built-in serial flash memory)
  GBA-BIOS (16KB) (not used in NDS mode)
  NDS Slot ROM (serial 8bit-bus, max 4GB with default protocol)
  NDS Slot FLASH/EEPROM/FRAM (serial 1bit-bus)
</TD></TR></TABLE>
<BR>
<B>Shared-RAM</B><BR>
Even though Shared WRAM begins at 3000000h, programs are commonly using mirrors
at 37F8000h (both ARM9 and ARM7). At the ARM7-side, this allows to use 32K
Shared WRAM and 64K ARM7-WRAM as a continous 96K RAM block.<BR>
<BR>
<B>Undefined I/O Ports</B><BR>
On the NDS (at the ARM9-side at least) undefined I/O ports are always zero.<BR>
<BR>
<B>Undefined Memory Regions</B><BR>
16MB blocks that do not contain any defined memory regions (or that contain
only mapped TCM regions) are typically completely undefined.<BR>
16MB blocks that do contain valid memory regions are typically containing
mirrors of that memory in the unused upper part of the 16MB area (only
exceptions are TCM and BIOS which are not mirrored).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dsmemorycontrol"></A>
  DS Memory Control
</FONT></TD></TR></TABLE><BR>
<B>Memory Control</B><BR>
<A HREF="#dsmemorycontrolcacheandtcm">DS Memory Control - Cache and TCM</A><BR>
<A HREF="#dsmemorycontrolcartridgesandmainram">DS Memory Control - Cartridges and Main RAM</A><BR>
<A HREF="#dsmemorycontrolwram">DS Memory Control - WRAM</A><BR>
<A HREF="#dsmemorycontrolvram">DS Memory Control - VRAM</A><BR>
<A HREF="#dsmemorycontrolbios">DS Memory Control - BIOS</A><BR>
<BR>
<B>Memory Access Time</B><BR>
<A HREF="#dsmemorytimings">DS Memory Timings</A><BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dsmemorycontrolcacheandtcm"></A>
  DS Memory Control - Cache and TCM
</FONT></TD></TR></TABLE><BR>
TCM and Cache are controlled by the System Control Coprocessor,<BR>
<A HREF="#armcp15systemcontrolcoprocessor">ARM CP15 System Control Coprocessor</A><BR>
<BR>
The specifications for the NDS9 are:<BR>
<BR>
<B>Tightly Coupled Memory (TCM)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  ITCM 32K, base=00000000h (fixed, not move-able)
  DTCM 16K, base=moveable  (default base=27C0000h)
</TD></TR></TABLE>
Note: Although ITCM is NOT moveable, the NDS Firmware configures the ITCM size
to 32MB, and so, produces ITCM mirrors at 0..1FFFFFFh. Furthermore, the PU can
be used to lock/unlock memory in that region. That trick allows to move ITCM
anywhere within the lower 32MB of memory.<BR>
<BR>
<B>Cache</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Data Cache 4KB, Instruction Cache 8KB
  4-way set associative method
  Cache line 8 words (32 bytes)
  Read-allocate method (ie. writes are not allocating cache lines)
  Round-robin and Pseudo-random replacement algorithms selectable
  Cache Lockdown, Instruction Prefetch, Data Preload
  Data write-through and write-back modes selectable
</TD></TR></TABLE>
<BR>
<B>Protection Unit (PU)</B><BR>
Recommended/default settings are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Region  Name            Address   Size   Cache WBuf Code Data
  -       Background      00000000h 4GB    -     -    -    -
  0       I/O and VRAM    04000000h 64MB   -     -    R/W  R/W
  1       Main Memory     02000000h 4MB    On    On   R/W  R/W
  2       ARM7-dedicated  027C0000h 256KB  -     -    -    -
  3       GBA Slot        08000000h 128MB  -     -    -    R/W
  4       DTCM            027C0000h 16KB   -     -    -    R/W
  5       ITCM            01000000h 32KB   -     -    R/W  R/W
  6       BIOS            FFFF0000h 32KB   On    -    R    R
  7       Shared Work     027FF000h 4KB    -     -    -    R/W
</TD></TR></TABLE>
Notes: In Nintendo's hardware-debugger, Main Memory is expanded to 8MB (for
that reason, some addresses are at 27NN000h instead 23NN000h) (some of the
extra memory is reserved for the debugger, some can be used for game
development). Region 2 and 7 are not understood? GBA Slot should be max
32MB+64KB, rounded up to 64MB, no idea why it is 128MB? DTCM and ITCM do not
use Cache and Write-Buffer because TCM is fast. Above settings do not allow to
access Shared Memory at 37F8000h? Do not use cache/wbuf for I/O, doing so might
suppress writes, and/or might read outdated values.<BR>
The main purpose of the Protection Unit is debugging, a major problem with GBA
programs have been faulty accesses to memory address 00000000h and up (due to
[base+offset] addressing with uninitialized (zero) base values). This problem
has been fixed in the NDS, for the ARM9 processor at least, still there are
various leaks: For example, the 64MB I/O and VRAM area contains only ca. 660KB
valid addresses, and the ARM7 probably doesn't have a Protection Unit at all.
Alltogether, the protection is better than in GBA, but it's still pretty crude
compared with software debugging tools.<BR>
Region address/size are unified (same for code and data), however, cachabilty
and access rights are non-unified (and may be separately defined for code and
data).<BR>
<BR>
Note: The NDS7 doesn't have any TCM, Cache, or CP15.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dsmemorycontrolcartridgesandmainram"></A>
  DS Memory Control - Cartridges and Main RAM
</FONT></TD></TR></TABLE><BR>
<B>4000204h - NDS9 - EXMEMCNT - 16bit - External Memory Control (R/W)</B><BR>
<B>4000204h - NDS7 - EXMEMSTAT - 16bit - External Memory Status (R/W..R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-1   32-pin GBA Slot SRAM Access Time    (0-3 = 10, 8, 6, 18 cycles)
  2-3   32-pin GBA Slot ROM 1st Access Time (0-3 = 10, 8, 6, 18 cycles)
  4     32-pin GBA Slot ROM 2nd Access Time (0-1 = 6, 4 cycles)
  5-6   32-pin GBA Slot PHI-pin out   (0-3 = Low, 4.19MHz, 8.38MHz, 16.76MHz)
  7     32-pin GBA Slot Access Rights     (0=ARM9, 1=ARM7)
  8-10  Not used (always zero)
  11    17-pin NDS Slot Access Rights     (0=ARM9, 1=ARM7)
  12    Not used (always zero)
  13    NDS:Always set?  ;set/tested by DSi bootcode: Main RAM enable, CE2 pin?
  14    Main Memory Interface Mode Switch (0=Async/GBA/Reserved, 1=Synchronous)
  15    Main Memory Access Priority       (0=ARM9 Priority, 1=ARM7 Priority)
</TD></TR></TABLE>
Bit0-6 can be changed by both NDS9 and NDS7, changing these bits affects the
local EXMEM register only, not that of the other CPU.<BR>
Bit7-15 can be changed by NDS9 only, changing these bits affects both EXMEM
registers, ie. both NDS9 and NDS7 can read the current NDS9 setting.<BR>
Bit14=0 is intended for GBA mode, however, writes to this bit appear to be
ignored?<BR>
<A HREF="#dsmainmemorycontrol">DS Main Memory Control</A><BR>
<BR>
<B>GBA Slot (8000000h-AFFFFFFh)</B><BR>
The GBA Slot can be mapped to ARM9 or ARM7 via EXMEMCNT.7.<BR>
For the selected CPU, memory at 8000000h-9FFFFFFh contains the "GBA ROM"
region, and memory at A000000h-AFFFFFFh contains the "GBA SRAM" region
(repeated every 64Kbytes). If there is no cartridge in GBA Slot, then the
ROM/SRAM regions will contain open-bus values: SRAM region is FFh-filled
(High-Z). And ROM region is filled by increasing 16bit values (Addr/2),
possibly ORed with garbage depending on the selected ROM Access Time:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  6 clks   --&gt; returns "Addr/2"
  8 clks   --&gt; returns "Addr/2"
  10 clks  --&gt; returns "Addr/2 OR FE08h" (or similar garbage)
  18 clks  --&gt; returns "FFFFh" (High-Z)
</TD></TR></TABLE>
For the deselected CPU, all memory at 8000000h-AFFFFFFh becomes 00h-filled,
this is required for bugged games like Digimon Story: Super Xros Wars (which is
accidently reading deselected GBA SRAM at [main_ram_base+main_ram_addr*4],
whereas it does presumably want to read Main RAM at [main_ram_base+index*4]).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dsmemorycontrolwram"></A>
  DS Memory Control - WRAM
</FONT></TD></TR></TABLE><BR>
<B>4000247h - NDS9 - WRAMCNT - 8bit - WRAM Bank Control (R/W)</B><BR>
<B>4000241h - NDS7 - WRAMSTAT - 8bit - WRAM Bank Status (R)</B><BR>
Should not be changed when using Nintendo's API.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-1   ARM9/ARM7 (0-3 = 32K/0K, 2nd 16K/1st 16K, 1st 16K/2nd 16K, 0K/32K)
  2-7   Not used
</TD></TR></TABLE>
The ARM9 WRAM area is 3000000h-3FFFFFFh (16MB range).<BR>
The ARM7 WRAM area is 3000000h-37FFFFFh (8MB range).<BR>
The allocated 16K or 32K are mirrored everywhere in the above areas.<BR>
De-allocation (0K) is a special case: At the ARM9-side, the WRAM area is then
empty (containing undefined data). At the ARM7-side, the WRAM area is then
containing mirrors of the 64KB ARM7-WRAM (the memory at 3800000h and up).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dsmemorycontrolvram"></A>
  DS Memory Control - VRAM
</FONT></TD></TR></TABLE><BR>
<B>4000240h - NDS7 - VRAMSTAT - 8bit - VRAM Bank Status (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     VRAM C enabled and allocated to NDS7  (0=No, 1=Yes)
  1     VRAM D enabled and allocated to NDS7  (0=No, 1=Yes)
  2-7   Not used (always zero)
</TD></TR></TABLE>
The register indicates if VRAM C/D are allocated to NDS7 (as Work RAM), ie. if
VRAMCNT_C/D are enabled (Bit7=1), with MST=2 (Bit0-2). However, it does not
reflect the OFS value.<BR>
<BR>
<B>4000240h - NDS9 - VRAMCNT_A - 8bit - VRAM-A (128K) Bank Control (W)</B><BR>
<B>4000241h - NDS9 - VRAMCNT_B - 8bit - VRAM-B (128K) Bank Control (W)</B><BR>
<B>4000242h - NDS9 - VRAMCNT_C - 8bit - VRAM-C (128K) Bank Control (W)</B><BR>
<B>4000243h - NDS9 - VRAMCNT_D - 8bit - VRAM-D (128K) Bank Control (W)</B><BR>
<B>4000244h - NDS9 - VRAMCNT_E - 8bit - VRAM-E (64K) Bank Control (W)</B><BR>
<B>4000245h - NDS9 - VRAMCNT_F - 8bit - VRAM-F (16K) Bank Control (W)</B><BR>
<B>4000246h - NDS9 - VRAMCNT_G - 8bit - VRAM-G (16K) Bank Control (W)</B><BR>
<B>4000248h - NDS9 - VRAMCNT_H - 8bit - VRAM-H (32K) Bank Control (W)</B><BR>
<B>4000249h - NDS9 - VRAMCNT_I - 8bit - VRAM-I (16K) Bank Control (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-2   VRAM MST              ;Bit2 not used by VRAM-A,B,H,I
  3-4   VRAM Offset (0-3)     ;Offset not used by VRAM-E,H,I
  5-6   Not used
  7     VRAM Enable (0=Disable, 1=Enable)
</TD></TR></TABLE>
There is a total of 656KB of VRAM in Blocks A-I.<BR>
Table below shows the possible configurations.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
<B>  VRAM    SIZE  MST  OFS   ARM9, Plain ARM9-CPU Access (so-called LCDC mode)</B>
  A       128K  0    -     6800000h-681FFFFh
  B       128K  0    -     6820000h-683FFFFh
  C       128K  0    -     6840000h-685FFFFh
  D       128K  0    -     6860000h-687FFFFh
  E       64K   0    -     6880000h-688FFFFh
  F       16K   0    -     6890000h-6893FFFh
  G       16K   0    -     6894000h-6897FFFh
  H       32K   0    -     6898000h-689FFFFh
  I       16K   0    -     68A0000h-68A3FFFh
<B>  VRAM    SIZE  MST  OFS   ARM9, 2D Graphics Engine A, BG-VRAM (max 512K)</B>
  A,B,C,D 128K  1    0..3  6000000h+(20000h*OFS)
  E       64K   1    -     6000000h
  F,G     16K   1    0..3  6000000h+(4000h*OFS.0)+(10000h*OFS.1)
<B>  VRAM    SIZE  MST  OFS   ARM9, 2D Graphics Engine A, OBJ-VRAM (max 256K)</B>
  A,B     128K  2    0..1  6400000h+(20000h*OFS.0)  ;(OFS.1 must be zero)
  E       64K   2    -     6400000h
  F,G     16K   2    0..3  6400000h+(4000h*OFS.0)+(10000h*OFS.1)
<B>  VRAM    SIZE  MST  OFS   2D Graphics Engine A, BG Extended Palette</B>
  E       64K   4    -     Slot 0-3  ;only lower 32K used
  F,G     16K   4    0..1  Slot 0-1 (OFS=0), Slot 2-3 (OFS=1)
<B>  VRAM    SIZE  MST  OFS   2D Graphics Engine A, OBJ Extended Palette</B>
  F,G     16K   5    -     Slot 0  ;16K each (only lower 8K used)
<B>  VRAM    SIZE  MST  OFS   Texture/Rear-plane Image</B>
  A,B,C,D 128K  3    0..3  Slot OFS(0-3)   ;(Slot2-3: Texture, or Rear-plane)
<B>  VRAM    SIZE  MST  OFS   Texture Palette</B>
  E       64K   3    -     Slots 0-3                 ;OFS=don't care
  F,G     16K   3    0..3  Slot (OFS.0*1)+(OFS.1*4)  ;ie. Slot 0, 1, 4, or 5
<B>  VRAM    SIZE  MST  OFS   ARM9, 2D Graphics Engine B, BG-VRAM (max 128K)</B>
  C       128K  4    -     6200000h
  H       32K   1    -     6200000h
  I       16K   1    -     6208000h
<B>  VRAM    SIZE  MST  OFS   ARM9, 2D Graphics Engine B, OBJ-VRAM (max 128K)</B>
  D       128K  4    -     6600000h
  I       16K   2    -     6600000h
<B>  VRAM    SIZE  MST  OFS   2D Graphics Engine B, BG Extended Palette</B>
  H       32K   2    -     Slot 0-3
<B>  VRAM    SIZE  MST  OFS   2D Graphics Engine B, OBJ Extended Palette</B>
  I       16K   3    -     Slot 0  ;(only lower 8K used)
<B>  VRAM    SIZE  MST  OFS   &lt;ARM7&gt;, Plain &lt;ARM7&gt;-CPU Access</B>
  C,D     128K  2    0..1  6000000h+(20000h*OFS.0)  ;OFS.1 must be zero
</TD></TR></TABLE>
<BR>
<B>Notes</B><BR>
In Plain-CPU modes, VRAM can be accessed only by the CPU (and by the Capture
Unit, and by VRAM Display mode). In "Plain &lt;ARM7&gt;-CPU Access" mode, the
VRAM blocks are allocated as Work RAM to the NDS7 CPU.<BR>
In BG/OBJ VRAM modes, VRAM can be accessed by the CPU at specified addresses,
and by the display controller.<BR>
In Extended Palette and Texture Image/Palette modes, VRAM is not mapped to CPU
address space, and can be accessed only by the display controller (so, to
initialize or change the memory, it should be temporarily switched to Plain-CPU
mode).<BR>
All VRAM (and Palette, and OAM) can be written to only in 16bit and 32bit units
(STRH, STR opcodes), 8bit writes are ignored (by STRB opcode). The only
exception is "Plain &lt;ARM7&gt;-CPU Access" mode: The ARM7 CPU can use STRB to
write to VRAM (the reason for this special feature is that, in GBA mode, two
128K VRAM blocks are used to emulate the GBA's 256K Work RAM).<BR>
<BR>
<B>Other Video RAM</B><BR>
Aside from the map-able VRAM blocks, there are also some video-related memory
regions at fixed addresses:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  5000000h Engine A Standard BG Palette (512 bytes)
  5000200h Engine A Standard OBJ Palette (512 bytes)
  5000400h Engine B Standard BG Palette (512 bytes)
  5000600h Engine B Standard OBJ Palette (512 bytes)
  7000000h Engine A OAM (1024 bytes)
  7000400h Engine B OAM (1024 bytes)
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dsmemorycontrolbios"></A>
  DS Memory Control - BIOS
</FONT></TD></TR></TABLE><BR>
<B>4000308h - NDS7 - BIOSPROT - Bios-data-read-protection address</B><BR>
Used to double-protect the first some KBytes of the NDS7 BIOS. The BIOS is
split into two protection regions, one always active, one controlled by the
BIOSPROT register. The overall idea is that only the BIOS can read from itself,
any other attempts to read from that regions return FFh-bytes.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Opcodes at...      Can read from      Expl.
  0..[BIOSPROT]-1    0..3FFFh           Double-protected (when BIOSPROT is set)
  [BIOSPROT]..3FFFh  [BIOSPROT]..3FFFh  Normal-protected (always active)
</TD></TR></TABLE>
The initial BIOSPROT setting on power-up is zero (disabled). Before starting
the cartridge, the BIOS boot code sets the register to 1204h (actually 1205h,
but the mis-aligned low-bit is ignored). Once when initialized, further writes
to the register are ignored.<BR>
<BR>
The double-protected region contains the exception vectors, some bytes of code,
and the cartridge KEY1 encryption seed (about 4KBytes). As far as I know, it is
impossible to unlock the memory once when it is locked, however, with some
trickery, it is possible execute code before it gets locked. Also, the two
THUMB opcodes at 05ECh can be used to read all memory at 0..3FFFh,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  05ECh  ldrb r3,[r3,12h]      ;requires incoming r3=src-12h
  05EEh  pop  r2,r4,r6,r7,r15  ;requires dummy values &amp; THUMB retadr on stack
</TD></TR></TABLE>
Additionally most BIOS functions (eg. CpuSet), include a software-based
protection which rejects source addresses in the BIOS area (the only exception
is GetCRC16, though it still cannot bypass the BIOSPROT setting).<BR>
<BR>
<B>Note</B><BR>
The NDS9 BIOS doesn't include any software or hardware based read protection.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dsmemorytimings"></A>
  DS Memory Timings
</FONT></TD></TR></TABLE><BR>
<B>System Clock</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bus clock  = 33MHz (33.513982 MHz) (1FF61FEh Hertz)
  NDS7 clock = 33MHz (same as bus clock)
  NDS9 clock = 66MHz (internally twice bus clock; for cache/tcm)
</TD></TR></TABLE>
Most timings in this document are specified for 33MHz clock (not for the 66MHz
clock). Respectively, NDS9 timings are counted in "half" cycles.<BR>
<BR>
<B>Memory Access Times</B><BR>
Tables below show the different access times for code/data fetches on arm7/arm9
cpus, measured for sequential/nonsequential 32bit/16bit accesses.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  NDS7/CODE             NDS9/CODE
  N32 S32 N16 S16 Bus   N32 S32 N16 S16 Bus
  9   2   8   1   16    9   9   4.5 4.5 16  Main RAM (read) (cache off)
  1   1   1   1   32    4   4   2   2   32  WRAM,BIOS,I/O,OAM
  2   2   1   1   16    5   5   2.5 2.5 16  VRAM,Palette RAM
  16  12  10  6   16    19  19  9.5 9.5 16  GBA ROM (example 10,6 access)
  -   -   -   -   -     0.5 0.5 0.5 0.5 32  TCM, Cache_Hit
  -   -   -   -   -     (--Load 8 words--)  Cache_Miss
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  NDS7/DATA             NDS9/DATA
  N32 S32 N16 S16 Bus   N32 S32 N16 S16 Bus
  10  2   9   1   16    10  2   9   1   16  Main RAM (read) (cache off)
  1   1   1   1   32    4   1   4   1   32  WRAM,BIOS,I/O,OAM
  1?  2   1   1   16    5   2   4   1   16  VRAM,Palette RAM
  15  12  9   6   16    19  12  13  6   16  GBA ROM (example 10,6 access)
  9   10  9   10  8     13  10  13  10  8   GBA RAM (example 10 access)
  -   -   -   -   -     0.5 0.5 0.5 -   32  TCM, Cache_Hit
  -   -   -   -   -     (--Load 8 words--)  Cache_Miss
  -   -   -   -   -     11  11  11  -   32  Cache_Miss (BIOS)
  -   -   -   -   -     23  23  23  -   16  Cache_Miss (Main RAM)
</TD></TR></TABLE>
All timings are counted in 33MHz units (so "half" cycles can occur on NDS9).<BR>
Note: 8bit data accesses have same timings than 16bit data.<BR>
<BR>
*** DS Memory Timing Notes ***<BR>
<BR>
The NDS timings are altogether pretty messed up, with different timings for
CODE and DATA fetches, and different timings for NDS7 and NDS9...<BR>
<BR>
<B>NDS7/CODE</B><BR>
Timings for this region can be considered as "should be" timings.<BR>
<BR>
<B>NDS7/DATA</B><BR>
Quite the same as NDS7/CODE. Except that, nonsequential Main RAM accesses are 1
cycle slower, and more strange, nonsequential GBA Slot accesses are 1 cycle
faster.<BR>
<BR>
<B>NDS9/CODE</B><BR>
This is the most messiest timing. An infamous PENALTY of 3 cycles is added to
all nonsequential accesses (except cache, tcm, and main ram). And, all opcode
fetches are forcefully made nonsequential 32bit (the NDS9 simply doesn't
support fast sequential opcode fetches). That applies also for THUMB code (two
16bit opcodes are fetched by a single nonsequential 32bit access) (so the time
per 16bit opcode is one half of the 32bit fetch) (unless a branch causes only
one of the two 16bit opcodes to be executed, then that opcode will have the
full 32bit access time).<BR>
<BR>
<B>NDS9/DATA</B><BR>
Allows both sequential and nonsequential access, and both 16bit and 32bit
access, so it's faster than NDS9/CODE. Nethertheless, it's still having the 3
cycle PENALTY on nonsequential accesses. And, similar as NDS7/DATA, it's also
adding 1 cycle to nonsequential Main RAM accesses.<BR>
<BR>
*** More Timing Notes / Lots of unsorted Info ***<BR>
<BR>
<B>Actual CPU Performance</B><BR>
The 33MHz NDS7 is running more or less nicely at 33MHz. However, the so-called
"66MHz" NDS9 is having &lt;much&gt; higher waitstates, and it's effective bus
speed is barely about 8..16MHz, the only exception is code/data in cache/tcm,
which is eventually reaching real 66MHz (that, assuming cache HITS, otherwise,
in case of cache MISSES, the cached memory timing might even drop to 1.4MHz or
so?).<BR>
*********************<BR>
ARM9 opcode fetches are always N32 + 3 waits.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  S16 and N16 do not exist (because thumb-double-fetching) (see there).
  S32 becomes N32 (ie. the ARM9 does NOT support fast sequential timing).
</TD></TR></TABLE>
That N32 is having same timing as normal N32 access on NDS7, plus 3 waits.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Eg. an ARM9 N32 or S32 to 16bit bus will take: N16 + S16 + 3 waits.
  Eg. an ARM9 N32 or S32 to 32bit bus will take: N32 + 3 waits.
</TD></TR></TABLE>
Main Memory is ALWAYS having the nonsequential 3 wait PENALTY (even on ARM7).<BR>
*********************<BR>
ARM9 Data fetches however are allowed to use sequential timing, as well as raw
16bit accesses (which aren't forcefully expanded to slow 32bit accesses).<BR>
Nethertheless, the 3 wait PENALTY is added to any NONSEQUENTIAL accesses.<BR>
Only exceptions are cache and tcm which do not have that penalty.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 Eg. LDRH on 16bit-data-bus is N16+3waits.
 Eg. LDR  on 16bit-data-bus is N16+S16+3waits.
 Eg. LDM  on 16bit-data-bus is N16+(n*2-1)*S16+3waits.
</TD></TR></TABLE>
Eventually, data fetches can take place parallel with opcode fetches.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 That is NOT true for LDM (works only for LDR/LDRB/LDRH).
 That is NOT true for DATA in SAME memory region than CODE.
 That is NOT true for DATA in ITCM (no matter if CODE is in ITCM).
</TD></TR></TABLE>
*********************<BR>
<BR>
<B>NDS9 Busses</B><BR>
Unlike ARM7, the ARM9 has separate code and data busses, allowing it to perform
code and data fetches simultaneously (provided that both are in different
memory regions).<BR>
Normally, opcode execution times are calculated as "(codetime+datatime)", with
the two busses, it can (ideally) be "MAX(codetime,datatime)", so the data
access time may virtually take "NULL" clock cycles.<BR>
In practice, DTCM and Data Cache access can take NULL cycles (however, data
access to ITCM can't).<BR>
When executing code in cache/itcm, data access to non-cache/tcm won't be any
faster than with only one bus (as it's best, it could subtract 0.5 cycles from
datatime, but, the access must be "aligned" to the bus-clock, so the
"datatime-0.5" will be rounded back to the original "datatime").<BR>
When executing code in uncached main ram, and accessing data (elsewhere than in
main memory, cache/tcm), then execution time is typically
"codetime+datatime-2".<BR>
<BR>
<B>NDS9 Internal Cycles</B><BR>
Additionally to codetime+datatime, some opcodes include one or more internal
cycles. Compared with ARM7, the behaviour of that internal cycles is slightly
different on ARM9. First of, on the NDS9, the internal cycles are of course
"half" cycles (ie. counted in 66MHz units, not in 33MHz units) (although they
may get rounded to "full" cycles upon next memory access outside tcm/cache).
And, the ARM9 is in some cases "skipping" the internal cycles, that often
depending on whether or not the next opcode is using the result of the current
opcode.<BR>
Another big difference is that the ARM9 has lost the fast-multiply feature for
small numbers; in some cases that may result in faster execution, but may also
result in slower execution (one workaround would be to manually replace MUL
opcodes by the new ARM9 halfword multiply opcodes); the slowest case are MUL
opcodes that do update flags (eg. MULS, MLAS, SMULLS, etc. in ARM mode, and all
ALL multiply opcodes in THUMB mode).<BR>
<BR>
<B>NDS9 Thumb Code</B><BR>
In thumb mode, the NDS9 is fetching two 16bit opcodes by a single 32bit read.
In case of 32bit bus, this reduces the amount of memory traffic and may result
in faster execution time, of course that works only if the two opcodes are
within a word-aligned region (eg. loops at word-aligned addresses will be
faster than non-aligned loops). However, the double-opcode-fetching is also
done on 16bit bus memory, including for unnecessary fetches, such like opcodes
after branch commands, so the feature may cause heavy slowdowns.<BR>
<BR>
<B>Main Memory</B><BR>
Reportedly, the main memory access times would be 5 cycles (nonsequential
read), 4 cycles (nonsequential write), and 1 cycle (sequential read or write).
Plus whatever termination cycles. Plus 3 cycles on nonsequential access to the
last 2-bytes of a 32-byte block.<BR>
That's of course all wrong. Reads are much slower than 5 cycles. Not yet tested
if writes are faster. And, I haven't been able to reproduce the 3 cycles on
last 2-bytes effect, actually, it looks more as if that 3 cycles are accidently
added to ALL nonsequential accesses, at ALL main memory addresses, and even to
most OTHER memory regions... which might be the source of the PENALTY which
occurs on VRAM/WRAM/OAM/Palette and I/O accesses.<BR>
<BR>
<B>DMA</B><BR>
In some cases DMA main memory read cycles are reportedly performed
simultaneously with DMA write cycles to other memory.<BR>
<BR>
<B>NDS9</B><BR>
On the NDS9, all external memory access (and I/O) is delayed to bus clock (or
actually MUCH slower due to the massive waitstates), so the full 66MHz can be
used only internally in the NDS9 CPU core, ie. with cache and TCM.<BR>
<BR>
<B>Bus Clock</B><BR>
The exact bus clock is specified as 33.513982 MHz (1FF61FEh Hertz). However, on
my own NDS, measured in relation to the RTC seconds IRQ, it appears more like
1FF6231h, that inaccuary of 1 cycle per 657138 cycles (about one second per
week) on either oscillator, isn't too significant though.<BR>
<BR>
<B>GBA Slot</B><BR>
The access time for GBA slot can be configured via EXMEMCNT register.<BR>
<BR>
<B>VRAM Waitstates</B><BR>
Additionally, on NDS9, a one cycle wait can be added to VRAM accesses (when the
video controller simultaneously accesses it) (that can be disabled by Forced
Blank, see DISPCNT.Bit7). Moreover, additional VRAM waitstates occur when using
the video capture function.<BR>
Note: VRAM being mapped to NDS7 is always free of additional waits.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dsvideo"></A>
  DS Video
</FONT></TD></TR></TABLE><BR>
The NDS has two 2D Video Engines, each basically the same as in GBA, see<BR>
<A HREF="#gbalcdvideocontroller">GBA LCD Video Controller</A><BR>
<BR>
<B>NDS Specific 2D Video Features</B><BR>
<A HREF="#dsvideostuff">DS Video Stuff</A><BR>
<A HREF="#dsvideobgmodescontrol">DS Video BG Modes / Control</A><BR>
<A HREF="#dsvideoobjs">DS Video OBJs</A><BR>
<A HREF="#dsvideoextendedpalettes">DS Video Extended Palettes</A><BR>
<A HREF="#dsvideocaptureandmainmemorydisplaymode">DS Video Capture and Main Memory Display Mode</A><BR>
<A HREF="#dsvideodisplaysystemblockdiagram">DS Video Display System Block Diagram</A><BR>
<BR>
<B>NDS/DSi File Formats for 2D video</B><BR>
<A HREF="#dsfiles2dvideo">DS Files - 2D Video</A><BR>
<BR>
For Display Power Control (and Display Swap), and VRAM Allocation, see<BR>
<A HREF="#dspowercontrol">DS Power Control</A><BR>
<A HREF="#dspowermanagementdevice">DS Power Management Device</A><BR>
<A HREF="#dsmemorycontrolvram">DS Memory Control - VRAM</A><BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dsvideostuff"></A>
  DS Video Stuff
</FONT></TD></TR></TABLE><BR>
<B>DS Display Dimensions / Timings</B><BR>
Dot clock = 5.585664 MHz (=33.513982 MHz / 6)<BR>
H-Timing: 256 dots visible, 99 dots blanking, 355 dots total (15.7343KHz)<BR>
V-Timing: 192 lines visible, 71 lines blanking, 263 lines total (59.8261 Hz)<BR>
The V-Blank cycle for the 3D Engine consists of the 23 lines, 191..213.<BR>
Screen size 62.5mm x 47.0mm (each) (256x192 pixels)<BR>
Vertical space between screens 22mm (equivalent to 90 pixels)<BR>
<BR>
<B>400006Ch - NDS9 - MASTER_BRIGHT - 16bit - Master Brightness Up/Down</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-4   Factor used for 6bit R,G,B Intensities (0-16, values &gt;16 same as 16)
          Brightness up:   New = Old + (63-Old) * Factor/16
          Brightness down: New = Old - Old      * Factor/16
  5-13  Not used
  14-15 Mode (0=Disable, 1=Up, 2=Down, 3=Reserved)
  16-31 Not used
</TD></TR></TABLE>
<BR>
<B>DISPSTAT/VCOUNT</B><BR>
The LY and LYC values are in range 0..262, so LY/LYC values have been expanded
to 9bit values: LY = VCOUNT Bit 0..8, and LYC=DISPSTAT Bit8..15,7.<BR>
VCOUNT register is write-able, allowing to synchronize linked DS consoles.<BR>
For proper synchronization:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  write new LY values only in range of 202..212
  write only while old LY values are in range of 202..212
</TD></TR></TABLE>
DISPSTAT/VCOUNT supported by NDS9 (Engine A Ports, without separate Engine B
Ports), and by NDS7 (allowing to synchronize NDS7 with display timings).<BR>
Similar as on GBA, the VBlank flag isn't set in the last line (ie. only in
lines 192..261, but not in line 262).<BR>
Although the drawing time is only 1536 cycles (256*6), the NDS9 H-Blank flag is
"0" for a total of 1606 cycles (and, for whatever reason, a bit longer, 1613
cycles in total, on NDS7).<BR>
<BR>
<B>VRAM Waitstates</B><BR>
The display controller performs VRAM-reads once every 6 clock cycles, a 1 cycle
waitstate is generated if the CPU simultaneously accesses VRAM. With capture
enabled, additionally VRAM-writes take place once every 6 cycles, so the total
VRAM-read/write access rate is then once every 3 cycles.<BR>
<BR>
<B>DS Window Glitches</B><BR>
The DS counts scanlines in range 0..262 (0..106h), of which only the lower 8bit
are compared with the WIN0V/WIN1V register settings. Respectively, Y1
coordinates 00h..06h will be triggered in scanlines 100h-106h by mistake. That
means, the window gets activated within VBlank period, and will be active in
scanline 0 and up (that is no problem with Y1=0, but Y1=1..6 will appear as if
if Y1 would be 0). Workaround would be to disable the Window during VBlank, or
to change Y1 during VBlank (to a value that does not occur during VBlank
period, ie. 7..191).<BR>
Also, there's a problem to fit the 256 pixel horizontal screen resolution into
8bit values: X1=00h is treated as 0 (left-most), X2=00h is treated as 100h
(right-most). However, the window is not displayed if X1=X2=00h; the window
width can be max 255 pixels.<BR>
<BR>
<B>2D Engines</B><BR>
Includes two 2D Engines, called A and B. Both engines are accessed by the ARM9
processor, each using different memory and register addresses:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Region______Engine A______________Engine B___________
  I/O Ports   4000000h              4001000h
  Palette     5000000h (1K)         5000400h (1K)
  BG VRAM     6000000h (max 512K)   6200000h (max 128K)
  OBJ VRAM    6400000h (max 256K)   6600000h (max 128K)
  OAM         7000000h (1K)         7000400h (1K)
</TD></TR></TABLE>
Engine A additionally supports 3D and large-screen 256-color Bitmaps, plus
main-memory-display and vram-display modes, plus capture unit.<BR>
<BR>
<B>Viewing Angles</B><BR>
The LCD screens are best viewed at viewing angles of 90 degrees. Colors may
appear distorted, and may even become invisible at other viewing angles.<BR>
When the console is handheld, both screens can be turned into preferred
direction. When the console is settled on a table, only the upper screen can be
turned, but the lower screen is stuck into horizontal position - which results
in rather bad visibility (unless the user moves his/her head directly above of
it).<BR>
<BR>
<B>4000070h - NDS9 - TVOUTCNT - Unknown (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0-3  "COMMAND"  (?)
  Bit4-7  "COMMAND2" (?)
  Bit8-11 "COMMAND3" (?)
</TD></TR></TABLE>
This register has been mentioned in an early I/O map from Nintendo, as far as I
know, the register isn't used by any games/firmware/bios, not sure if it does
really exist on release-version, or if it's been prototype stuff...?<BR>
<BR>
<B>DS-Lite Screens</B><BR>
The screens in the DS-Lite seem to allow a wider range of vertical angles.<BR>
The bad news is that the colors of the DS-Lite are (no surprise) not backwards
compatible with older NDS and GBA displays. The good news is that Nintendo has
finally reached near-CRT-quality (without blurred colors), so one could hope
that they won't show up with more displays with other colors in future.<BR>
Don't know if there's an official/recommended way to detect DS-Lite displays
(?) possible methods would be whatever values in Firmware header, or by
functionality of Power Managment device, or (not too LCD-related) by Wifi Chip
ID.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dsvideobgmodescontrol"></A>
  DS Video BG Modes / Control
</FONT></TD></TR></TABLE><BR>
<B>4000000h - NDS9 - DISPCNT</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit  Engine Expl.
  0-2   A+B   BG Mode
  3     A     BG0 2D/3D Selection (instead CGB Mode) (0=2D, 1=3D)
  4     A+B   Tile OBJ Mapping        (0=2D; max 32KB, 1=1D; max 32KB..256KB)
  5     A+B   Bitmap OBJ 2D-Dimension (0=128x512 dots, 1=256x256 dots)
  6     A+B   Bitmap OBJ Mapping      (0=2D; max 128KB, 1=1D; max 128KB..256KB)
  7-15  A+B   Same as GBA
  16-17 A+B   Display Mode (Engine A: 0..3, Engine B: 0..1, GBA: Green Swap)
  18-19 A     VRAM block (0..3=VRAM A..D) (For Capture &amp; above Display Mode=2)
  20-21 A+B   Tile OBJ 1D-Boundary   (see Bit4)
  22    A     Bitmap OBJ 1D-Boundary (see Bit5-6)
  23    A+B   OBJ Processing during H-Blank (was located in Bit5 on GBA)
  24-26 A     Character Base (in 64K steps) (merged with 16K step in BGxCNT)
  27-29 A     Screen Base (in 64K steps) (merged with 2K step in BGxCNT)
  30    A+B   BG Extended Palettes   (0=Disable, 1=Enable)
  31    A+B   OBJ Extended Palettes  (0=Disable, 1=Enable)
</TD></TR></TABLE>
<BR>
<B>BG Mode</B><BR>
Engine A BG Mode (DISPCNT LSBs) (0-6, 7=Reserved)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Mode  BG0      BG1      BG2      BG3
  0     Text/3D  Text     Text     Text
  1     Text/3D  Text     Text     Affine
  2     Text/3D  Text     Affine   Affine
  3     Text/3D  Text     Text     Extended
  4     Text/3D  Text     Affine   Extended
  5     Text/3D  Text     Extended Extended
  6     3D       -        Large    -
</TD></TR></TABLE>
Of which, the "Extended" modes are sub-selected by BGxCNT bits:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  BGxCNT.Bit7 BGxCNT.Bit2 Extended Affine Mode Selection
  0           CharBaseLsb rot/scal with 16bit bgmap entries (Text+Affine mixup)
  1           0           rot/scal 256 color bitmap
  1           1           rot/scal direct color bitmap
</TD></TR></TABLE>
Engine B: Same as above, except that: Mode 6 is reserved (no Large screen
bitmap), and BG0 is always Text (no 3D support).<BR>
Affine = formerly Rot/Scal mode (with 8bit BG Map entries)<BR>
Large Screen Bitmap = rot/scal 256 color bitmap (using all 512K of 2D VRAM)<BR>
<BR>
<B>Display Mode (DISPCNT.16-17):</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0  Display off (screen becomes white)
  1  Graphics Display (normal BG and OBJ layers)
  2  Engine A only: VRAM Display (Bitmap from block selected in DISPCNT.18-19)
  3  Engine A only: Main Memory Display (Bitmap DMA transfer from Main RAM)
</TD></TR></TABLE>
Mode 2-3 display a raw direct color bitmap (15bit RGB values, the upper bit in
each halfword is unused), without any further BG,OBJ,3D layers, these modes are
completely bypassing the 2D/3D engines as well as any 2D effects, however the
Master Brightness effect can be applied to these modes. Mode 2 is particulary
useful to display captured 2D/3D images (in that case it can indirectly use the
2D/3D engine).<BR>
<BR>
<B>BGxCNT</B><BR>
character base extended from bit2-3 to bit2-5 (bit4-5 formerly unused)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  engine A screen base: BGxCNT.bits*2K + DISPCNT.bits*64K
  engine B screen base: BGxCNT.bits*2K + 0
  engine A char base: BGxCNT.bits*16K + DISPCNT.bits*64K
  engine B char base: BGxCNT.bits*16K + 0
</TD></TR></TABLE>
char base is used only in tile/map modes (not bitmap modes)<BR>
screen base is used in tile/map modes,<BR>
screen base used in bitmap modes as BGxCNT.bits*16K, without DISPCNT.bits*64K<BR>
screen base however NOT used at all for Large screen bitmap mode<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  bgcnt size  text     rotscal    bitmap   large bmp
  0           256x256  128x128    128x128  512x1024
  1           512x256  256x256    256x256  1024x512
  2           256x512  512x512    512x256  -
  3           512x512  1024x1024  512x512  -
</TD></TR></TABLE>
bitmaps that require more than 128K VRAM are supported on engine A only.<BR>
<BR>
For BGxCNT.Bit7 and BGxCNT.Bit2 in Extended Affine modes, see above BG Mode
description (extended affine doesn't include 16-color modes, so color depth bit
can be used for mode selection. Also, bitmap modes do not use charbase, so
charbase.0 can be used for mode selection as well).<BR>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  for BG0CNT, BG1CNT only: bit13 selects extended palette slot
                           (BG0: 0=Slot0, 1=Slot2, BG1: 0=Slot1, 1=Slot3)
</TD></TR></TABLE>
<BR>
Direct Color Bitmap BG, and Direct Color Bitmap OBJ<BR>
BG/OBJ Supports 32K colors (15bit RGB value) - so far same as GBAs BG.<BR>
However, the upper bit (Bit15) is used as Alpha flag. That is,
Alpha=0=Transparent, Alpha=1=Normal (ie. on the NDS, Direct Color values
0..7FFFh are NOT displayed).<BR>
<BR>
Unlike GBA bitmap modes, NDS bitmap modes are supporting the Area Overflow bit
(BG2CNT and BG3CNT, Bit 13).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dsvideoobjs"></A>
  DS Video OBJs
</FONT></TD></TR></TABLE><BR>
<B>DS OBJ Priority</B><BR>
The GBA has been assigning OBJ priority in respect to the 7bit OAM entry
number, regardless of the OBJs 2bit BG-priority attribute (which allowed to
specify invalid priority orders). That problem has been fixed in DS mode by
combining the above two values into a 9bit priority value.<BR>
<BR>
<B>OBJ Tile Mapping (DISPCNT.4,20-21):</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit4  Bit20-21  Dimension Boundary Total ;Notes
  0     x         2D        32       32K   ;Same as GBA 2D Mapping
  1     0         1D        32       32K   ;Same as GBA 1D Mapping
  1     1         1D        64       64K
  1     2         1D        128      128K
  1     3         1D        256      256K  ;Engine B: 128K max
</TD></TR></TABLE>
TileVramAddress = TileNumber * BoundaryValue<BR>
Even if the boundary gets changed, OBJs are kept composed of 8x8 tiles.<BR>
<BR>
<B>Bitmap OBJ Mapping (DISPCNT.6,5,22):</B><BR>
Bitmap OBJs are 15bit Direct Color data, plus 1bit Alpha flag (in bit15).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit6 Bit5 Bit22 Dimension    Boundary   Total ;Notes
  0    0    x     2D/128 dots  8x8 dots   128K  ;Source Bitmap width 128 dots
  0    1    x     2D/256 dots  8x8 dots   128K  ;Source Bitmap width 256 dots
  1    0    0     1D           128 bytes  128K  ;Source Width = Target Width
  1    0    1     1D           256 bytes  256K  ;Engine A only
  1    1    x     Reserved
</TD></TR></TABLE>
In 1D mapping mode, the Tile Number is simply multiplied by the boundary value.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1D_BitmapVramAddress = TileNumber(0..3FFh) * BoundaryValue(128..256)
  2D_BitmapVramAddress = (TileNo AND MaskX)*10h + (TileNo AND NOT MaskX)*80h
</TD></TR></TABLE>
In 2D mode, the Tile Number is split into X and Y indices, the X index is
located in the LSBs (ie. MaskX=0Fh, or MaskX=1Fh, depending on DISPCNT.5).<BR>
<BR>
<B>OBJ Attribute 0 and 2</B><BR>
Setting the OBJ Mode bits (Attr 0, Bit10-11) to a value of 3 has been
prohibited in GBA, however, in NDS it selects the new Bitmap OBJ mode; in that
mode, the Color depth bit (Attr 0, Bit13) should be set to zero; also in that
mode, the color bits (Attr 2, Bit 12-15) are used as Alpha-OAM value (instead
of as palette setting).<BR>
<BR>
<B>OBJ Vertical Wrap</B><BR>
On the GBA, a large OBJ (with 64pix height, scaled into double-size region of
128pix height) located near the bottom of the screen has been wrapped to the
top of the screen (and was NOT displayed at the bottom of the screen).<BR>
This problem has been "corrected" in the NDS (except in GBA mode), that is, on
the NDS, the OBJ appears BOTH at the top and bottom of the screen. That isn't
necessarily better - the advantage is that one can manually enable/disable the
OBJ in the desired screen-half on IRQ level; that'd be required only if the
wrapped portion is non-transparent.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dsvideoextendedpalettes"></A>
  DS Video Extended Palettes
</FONT></TD></TR></TABLE><BR>
<B>Extended Palettes</B><BR>
When allocating extended palettes, the allocated memory is not mapped to the
CPU bus, so the CPU can access extended palette only when temporarily
de-allocating it.<BR>
<BR>
Color 0 of all standard/extended palettes is transparent, color 0 of BG
standard palette 0 is used as backdrop. extended palette memory must be
allocated to VRAM.<BR>
<BR>
BG Extended Palette enabled in DISPCNT Bit 30, when enabled,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 standard palette --&gt; 16-color tiles (with 16bit bgmap entries) (text)
                      256-color tiles (with 8bit bgmap entries) (rot/scal)
                      256-color bitmaps
                      backdrop-color (color 0)
 extended palette --&gt; 256-color tiles (with 16bit bgmap entries)(text,rot/scal)
</TD></TR></TABLE>
Allocated VRAM is split into 4 slots of 8K each (32K used in total), normally
BG0..3 are using Slot 0..3, however BG0 and BG1 can be optionally changed to
BG0=Slot2, and BG1=Slot3 via BG0CNT and BG1CNT.<BR>
<BR>
OBJ Extended Palette enabled in DISPCNT Bit 31, when enabled,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 16 colors x 16 palettes --&gt; standard palette memory (=256 colors)
 256 colors x 16 palettes --&gt; extended palette memory (=4096 colors)
</TD></TR></TABLE>
Extended OBJ palette memory must be allocated to VRAM F, G, or I (which are
16K) of which only the first 8K are used for extended palettes (=1000h 16bit
entries).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dsvideocaptureandmainmemorydisplaymode"></A>
  DS Video Capture and Main Memory Display Mode
</FONT></TD></TR></TABLE><BR>
<B>4000064h - NDS9 - DISPCAPCNT - 32bit - Display Capture Control Register (R/W)</B><BR>
Capture is supported for Display Engine A only.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-4   EVA               (0..16 = Blending Factor for Source A)
  5-7   Not used
  8-12  EVB               (0..16 = Blending Factor for Source B)
  13-15 Not used
  16-17 VRAM Write Block  (0..3 = VRAM A..D) (VRAM must be allocated to LCDC)
  18-19 VRAM Write Offset (0=00000h, 0=08000h, 0=10000h, 0=18000h)
  20-21 Capture Size      (0=128x128, 1=256x64, 2=256x128, 3=256x192 dots)
  22-23 Not used
  24    Source A          (0=Graphics Screen BG+3D+OBJ, 1=3D Screen)
  25    Source B          (0=VRAM, 1=Main Memory Display FIFO)
  26-27 VRAM Read Offset  (0=00000h, 0=08000h, 0=10000h, 0=18000h)
  28    Not used
  29-30 Capture Source    (0=Source A, 1=Source B, 2/3=Sources A+B blended)
  31    Capture Enable    (0=Disable/Ready, 1=Enable/Busy)
</TD></TR></TABLE>
Notes:<BR>
VRAM Read Block (VRAM A..D) is selected in DISPCNT Bits 18-19.<BR>
VRAM Read Block can be (or must be ?) allocated to LCDC (MST=0).<BR>
VRAM Read Offset is ignored (zero) in VRAM Display Mode (DISPCNT.16-17).<BR>
VRAM Read/Write Offsets wrap to 00000h when exceeding 1FFFFh (max 128K).<BR>
Capture Sizes less than 256x192 capture the upper-left portion of the screen.<BR>
Blending factors EVA and EVB are used only if "Source A+B blended" selected.<BR>
After setting the Capture Enable bit, capture starts at next line 0, and the
capture enable/busy bit is then automatically cleared (in line 192, regardless
of the capture size).<BR>
<BR>
Capture data is 15bit color depth (even when capturing 18bit 3D-images).<BR>
Capture A:  Dest_Intensity = SrcA_Intensitity ; Dest_Alpha=SrcA_Alpha.<BR>
Capture B:  Dest_Intensity = SrcB_Intensitity ; Dest_Alpha=SrcB_Alpha.<BR>
Capture A+B (blending):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 Dest_Intensity = (  (SrcA_Intensitity * SrcA_Alpha * EVA)
                   + (SrcB_Intensitity * SrcB_Alpha * EVB) ) / 16
 Dest_Alpha = (SrcA_Alpha AND (EVA&gt;0)) OR (SrcB_Alpha AND EVB&gt;0))
</TD></TR></TABLE>
<BR>
Capture provides a couple of interesting effects.<BR>
For example, 3D Engine output can be captured via source A (to LCDC-allocated
VRAM), in the next frame, either Graphics Engine A or B can display the
captured 3D image in VRAM image as BG2, BG3, or OBJ (from BG/OBJ-allocated
VRAM); this method requires to switch between LCDC- and BG/OBJ-allocation.<BR>
Another example would be to capture Engine A output, the captured image can be
displayed (via VRAM Display mode) in the following frames, simultaneously the
new Engine A output can be captured, blended with the old captured image; in
that mode moved objects will leave traces on the screen; this method works with
a single LCDC-allocated VRAM block.<BR>
<A HREF="#dsvideodisplaysystemblockdiagram">DS Video Display System Block Diagram</A><BR>
<BR>
<B>4000068h - NDS9 - DISP_MMEM_FIFO - 32bit - Main Memory Display FIFO (R?/W)</B><BR>
Intended to send 256x192 pixel 32K color bitmaps by DMA directly<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 - to Screen A             (set DISPCNT to Main Memory Display mode), or
 - to Display Capture unit (set DISPCAPCNT to Main Memory Source).
</TD></TR></TABLE>
The FIFO can receive 4 words (8 pixels) at a time, each pixel is a 15bit RGB
value (the upper bit, bit15, is unused).<BR>
Set DMA to Main Memory mode, 32bit transfer width, word count set to 4,
destination address to DISP_MMEM_FIFO, source address must be in Main Memory.<BR>
Transfer starts at next frame.<BR>
Main Memory Display/Capture is supported for Display Engine A only.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dsvideodisplaysystemblockdiagram"></A>
  DS Video Display System Block Diagram
</FONT></TD></TR></TABLE><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
             _____________               __________
  VRAM A --&gt;| 2D Graphics |--------OBJ-&gt;|          |
  VRAM B --&gt;| Engine A    |--------BG3-&gt;| Layering |
  VRAM C --&gt;|             |--------BG2-&gt;| and      |
  VRAM D --&gt;|             |--------BG1-&gt;| Special  |
  VRAM E --&gt;|             |   ___       | Effects  |
  VRAM F --&gt;|             |-&gt;|SEL|      |          |          ______
  VRAM G --&gt;| - - - - - - |  |BG0|-BG0-&gt;|          |----o---&gt;|      |
            | 3D Graphics |-&gt;|___|      |__________|    |    |Select|
            | Engine      |                             |    |Video |
            |_____________|--------3D----------------.  |    |Input |
             _______      _______              ___   |  |    |      |
            |       |    |       |&lt;-----------|SEL|&lt;-'  |    |and   |--&gt;
            |       |    |       |    _____   |A  |     |    |      |
  VRAM A &lt;--|Select |    |Select |   |     |&lt;-|___|&lt;----'    |Master|
  VRAM B &lt;--|Capture|&lt;---|Capture|&lt;--|Blend|   ___           |Bright|
  VRAM C &lt;--|Dest.  |    |Source |   |_____|&lt;-|SEL|&lt;----.    |A     |
  VRAM D &lt;--|       |    |       |            |B  |     |    |      |
            |_______|    |_______|&lt;-----------|___|&lt;-.  |    |      |
             _______                                 |  |    |      |
  VRAM A --&gt;|Select |                                |  |    |      |
  VRAM B --&gt;|Display|--------------------------------o------&gt;|      |
  VRAM C --&gt;|VRAM   |                                   |    |      |
  VRAM D --&gt;|_______|   _____________                   |    |      |
                       |Main Memory  |                  |    |      |
  Main   ------DMA----&gt;|Display FIFO |------------------o---&gt;|______|
  Memory               |_____________|
             _____________               __________           ______
  VRAM C --&gt;| 2D Graphics |--------OBJ-&gt;| Layering |         |      |
  VRAM D --&gt;| Engine B    |--------BG3-&gt;| and      |         |Master|
  VRAM H --&gt;|             |--------BG2-&gt;| Special  |--------&gt;|Bright|--&gt;
  VRAM I --&gt;|             |--------BG1-&gt;| Effects  |         |B     |
            |_____________|--------BG0-&gt;|__________|         |______|
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dsfiles2dvideo"></A>
  DS Files - 2D Video
</FONT></TD></TR></TABLE><BR>
eg. used in DSi Launcher "rom:\layout\cmn\launcher_d.szs\.."<BR>
<A HREF="http://www.romhacking.net/documents/[469]nds_formats.htm"><FONT COLOR=#808080>http://www.romhacking.net/documents/[469]nds_formats.htm</FONT></A>
<BR>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 ____________________________ Nitro Color Palette _____________________________
</TD></TR></TABLE>
<BR>
<B>Header</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4    Chunk ID "RLCN" (aka NCLR backwards, Nitro Color Resource)
  004h 2    Byte Order    (FEFFh)
  006h 2    Version       (0100h)
  008h 4    Total Filesize
  00Ch 2    Offset to "TTLP" Chunk, aka Size of "RLCN" Chunk (0010h)
  00Eh 2    Total number of following Chunks (1=TTLP) (or 2=TTLP+PMCP ?)
</TD></TR></TABLE>
<BR>
<B>TTLP Chunk</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4    Chunk ID "TTLP" (aka PLTT backwards, Palette data)
  004h 4    Chunk Size (eg. 0218h)
  008h 4    Reportedly Color Depth (ie. "tile usage info") (3=4bpp, 4=8bpp)
  00Ch 4    Zero
  010h 4    Palette Data Size in bytes (eg. 200h) (or 200h-N? no, blah!)
  014h 4    Offset from TTLP+8 to Palette Data? (always 10h)
  018h N*2  Palete Data (16bit colors, 0000h..7FFFh)
</TD></TR></TABLE>
Most DSi titles use full 200h-byte palettes (Paper Plane has a smaller one in
Graphics.NARC\Seq\pause.zcl). There seem to be no DSi titles with PMCP chunks.<BR>
<BR>
<B>PMCP Chunk (if any) (reportedly exists, but not in DSi Launcher...?)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4    Chunk ID "PMCP" (aka PCMP backwards, Palette CMP?)
  004h 4    Chunk Size (reportedly always 12h ???)
  008h 2    Number of palettes in file (uh?)
  00Ah 2    Unused (BEEFh=Bullshit)
  00Ch 4    Offset from PMCP+8 to Palette IDs? (always 08h)
  DATA N*2  "Palette ID numbers for each palette (starting from 0)"
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 ___________________________ Nitro Character Tiles ____________________________
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  eg. DSi Launcher "rom:\debug\DebugFont.NCGR"         -- with SOPC chunk
  eg. DSi Launcher "rom:\layout\cmn\launcher_d.szs\.." -- without SOPC chunk
</TD></TR></TABLE>
<BR>
<B>Header</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4    Chunk ID "RGCN" (aka NCGR backwards, Nitro Char Graphics Resource)
  004h 2    Byte Order    (FEFFh)
  006h 2    Version       (0101h) (unknown if 0100h does also exist?)
  008h 4    Total Filesize
  00Ch 2    Offset to "RAHC" Chunk, aka Size of "RGCN" Chunk (0010h)
  00Eh 2    Total number of following Chunks (1=RAHC, or 2=RAHC+SOPC)
</TD></TR></TABLE>
<BR>
<B>RAHC Chunk</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4    Chunk ID "RAHC" (aka CHAR backwards)
  004h 4    Chunk Size (eg. 1420h)
  008h 2    Tile Data Size in Kilobytes   ;\or both set to FFFFh
  00Ah 2    Unknown (always 20h)          ;/(when size&lt;&gt;N*1024)
  00Ch 4    Color Depth (3=4bpp, 4=8bpp)
  010h 2    Zero   ;or 10h (when SOPC not exists? kbyte size rounded up?)
  012h 2    Zero   ;or 20h (when SOPC not exists?)
  014h 4    Zero
  018h 4    Tile Data Size in Bytes (eg. 1400h)
  01Ch 4    Offset from RAHC+8 to Tile Data?  ;=always 18h
  020h ...  Tile Data (eg. 20h-byte zerofilled for 4bpp SPC char?)
</TD></TR></TABLE>
Nonzero [10h,12h] spotted in Paper Plane "rom:\Graphics.NARC\Plane\plane.zcg".<BR>
<BR>
<B>SOPC Chunk (only present if Tile Data size is N*1024 bytes)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4    Chunk ID "SOPC" (aka CPOS backwards)
  004h 4    Chunk Size (10h)
  008h 4    Zero
  00Ch 2    Same as [00Ah] in RAHC chunk? (always 20h)
  00Eh 2    Same as [008h] in RAHC chunk? (size in kilobytes)
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 __________________________ Unknown Character Tiles ___________________________
</TD></TR></TABLE>
<BR>
Apart from above NCGR, there is reportedly another tile format:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  NCGR (Nitro Character Graphic Resource) - Graphical Tiles --&gt; see above
  NBGR (Nitro Basic Graphic Resource)     - Graphical Tiles --&gt; what ???
</TD></TR></TABLE>
If it does really exist for real... the header ID be "RGBN" (aka NBGR
backwards), and file extension might be NBGR? But even if so, it's unknown
if/when/where/why that NBGR format is used. If the "B" is for "Basic" then
might have less features than NCGR, or maybe it might be "B" for non-tiled
Bitmaps, or whatever?<BR>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 ___________________________ Nitro BG Maps Screens ____________________________
</TD></TR></TABLE>
<BR>
<B>Header</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4    Chunk ID "RCSN" (aka NSCR backwards, Nitro Screen Resource)
  004h 2    Byte Order    (FEFFh)
  006h 2    Version       (0100h)
  008h 4    Total Filesize
  00Ch 2    Offset to "NRCS" Chunk, aka Size of "RCSN" Chunk (0010h)
  00Eh 2    Total number of following Chunks (1=NRCS)
</TD></TR></TABLE>
<BR>
<B>NRCS Chunk</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4    Chunk ID "NRCS" (aka SCRN backwards, Screen)
  004h 4    Chunk Size
  008h 4    Screen Width in pixels
  00Ah 2    Screen Height in pixels
  00Ch 4    Zero
  010h 4    Screen Data Size (width/8)*(height/8)*2
  014h N*2  Screen Data (16bit BG Map entries, palette+xyflip+tileno)
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 ____________________________ Nitro OBJ Animations ____________________________
</TD></TR></TABLE>
<BR>
<B>Header</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4    Chunk ID "RNAN" (aka NANR backwards, Nitro Animation Resource)
  004h 2    Byte Order    (FEFFh)
  006h 2    Version       (0100h)
  008h 4    Total Filesize
  00Ch 2    Offset to "KNBA" Chunk, aka Size of "RNAN" Chunk (0010h)
  00Eh 2    Total number of following Chunks (1=KNBA, or 3=KNBA+LBAL+TXEU)
</TD></TR></TABLE>
One chunk exists in DSi Launcher<BR>
Three chunks exist in DSi Flipnote "rom:ManualData.Eu\md2res_narc.blz\data\obj<BR>
<BR>
<B>KNBA Chunk</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4    Chunk ID "KNBA" (aka ABNK backwards, Animation Bank)
  004h 4    Chunk Size (always padded to 4-byte boundary if LABL chunk follows)
  008h 2    Number of 16-byte Animation Blocks ;implies NumLabels in LABL chunk
  00Ah 2    Number of 8-byte Frame Blocks
  00Ch 4    Offset from KNBA+8 to Animation Blocks ;=18h
  010h 4    Offset from KNBA+8 to Frame Blocks     ;=[0Ch]+[08h]*10h
  014h 4    Offset from KNBA+8 to Frame Data       ;=[10h]+[0Ah]*8
  018h 8    Zero
  DATA ..   Animation Blocks (16-byte entries)
   00h 4      Number of Frames
   04h 2      Unknown        (0)
   06h 2      Unknown Always (1)   ;reportedly "always unknown"
   08h 4      Unknown        (1..2)
   0Ch 4      Offset from FrameBlock+0 to First Frame
  DATA ..   Frame Blocks (8-byte entries)
   00h 4      Offset from FrameData+0 to whatever?   (always 4-byte aligned?)
   04h 2      Frame Width   ;3Ch or 01..06h   ;Time in 60Hz units? num meta's?
   06h 2      Unused (usually 0000h, or BEEFh=Bullshit)
  DATA ..   Frame Data (2-byte entries)
   00h 2      Unknown 16bit values? (maybe CELL index or whatever??)  (CCCCh=?)
</TD></TR></TABLE>
<BR>
<B>LBAL Chunk</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4    Chunk ID "LBAL" (aka LABL backwards, Labels)
  004h 4    Chunk Size (not padded to 4-byte size, following TXEU is unaligned)
  008h 4*N  Offsets from LabelArea+0 to Labels (for each Animation Block)
  ...  ..   Label Area (ASCII Strings, terminated by 00h)
</TD></TR></TABLE>
The LabelArea starts at LBAL+8+NumLabels*4 (whereas, NumLabels is found in KNBA
chunk).<BR>
<BR>
<B>TXEU Chunk</B><BR>
Caution: Not 4-byte aligned (the preceeding LBAL chunk can have odd size).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4    Chunk ID "TXEU" (aka UEXT backwards, Whatever Extension or so?)
  004h 4    Chunk Size (0Ch)
  008h 4    Unknown (usually 0) (reportedly 0 or 1)
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 __________________________ Nitro OBJ Metatile Cells __________________________
</TD></TR></TABLE>
<BR>
<B>Header</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4    Chunk ID "RECN" (aka NCER backwards, Nitro Cell Resource)
  004h 2    Byte Order    (FEFFh)
  006h 2    Version       (0100h)
  008h 4    Total Filesize
  00Ch 2    Offset to "KBEC" Chunk, aka Size of "RECN" Chunk (0010h)
  00Eh 2    Total number of following Chunks (1=KBEC, or 3=KBEC+LBAL+TXEU)
</TD></TR></TABLE>
<BR>
<B>KBEC Chunk</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4    Chunk ID "KBEC" (aka CEBK backwards, Cell Bank)
  004h 4    Chunk Size (always padded to 4-byte boundary if LABL chunk follows)
  008h 2    Number of Metatiles
  00Ah 2    Metatiles Entry Size (0=Normal 8 bytes, 1=Extended 16 bytes)
              (DSi Launcher ..layout\cmn\launcher_u\.. uses 16-byte size)
  00Ch 4    Offset from KBEC+8 to Metatile Table? (18h)
  010h 4    Boundary Size (?)       (but is ZERO in layout\cmn\launcher_u\)
               "Specifies the area in which the image can be drawn,
               multiplied by 64, ie. 2 means that the area is 128x128 pixels."
  014h 0Ch  Zero
  020h ..   Metatile Table (8 bytes each) (or 16 bytes)
  ...  ..   OBJ Attribute Table (6-bytes each)
</TD></TR></TABLE>
Metatile Table entries are (8-byte or 16-byte):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 2    Number of OBJs
  002h 2    Unknown
  004h 4    OBJ Data Offset (from begin of OBJ Attr Table)
 (008h 2)   Unknown (can be 02h,10h,48h,74h)
 (00Ah 2)   Unknown (can be 08h)
 (00Ch 2)   Unknown (can be FFA0h..FFF0h) ;\maybe extra coordinate offsets?
 (00Eh 2)   Unknown (can be FFF0h..FFF9h) ;/
</TD></TR></TABLE>
OBJ Attribute Table...<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  starts at Number of Cells * 8 | each cell is made up of 6 bytes)
</TD></TR></TABLE>
The 6-byte OBJ Attributes seem to be in normal OAM format, containing the
coordinates, tile number, tile size, and other flags (however, the coordinates
contain signed values; ie. one needs to add the current OBJ position to those
values). For details on the OBJ Attributes, see:<BR>
<A HREF="#lcdobjoamattributes">LCD OBJ - OAM Attributes</A><BR>
<BR>
<B>LBAL and TEXU Chunks (if any)</B><BR>
Same as in Animation files (see there). In fact, the content seems to be SAME
as the corresponding Animation file (for pairs of filename.NANR and
filename.NCER), and the number of labels must be obtained from the NANR file's
KNBA chunk (as such, it's rather useless to have LBAL in NCER files, except
perhaps for error checking that the correct file pair was loaded).<BR>
<BR>
Note: DSi Launcher layout\cmn\logodemo.szs has KBEC Chunk Size 2B6h (although
the filesize is padded as if it were 2B8h bytes) (the file has no LBAL chunk,
so it's unclear if/how it were aligned if present).<BR>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 ____________________________ Nitro Unknown Files  ____________________________
</TD></TR></TABLE>
<BR>
DSi Deep Psyche has two extra file types:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  .NMAR file (with "RAMN" header ID, and "KNBA"+"LBAL" chunks)
  .NMCR file (with "RCMN" header ID, and "KBCM" chunk)
</TD></TR></TABLE>
The purpose is unknown, but they are probably also animating something...<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  OBJ with 16bit x/y (instead 9bit/8bit)?
  OBJ with fractional x/y-stepping (moving/motion)?
  OBJ rotation/scaling?
  BG scroll offsets?
  BG tile replacement?
</TD></TR></TABLE>
Going by the filename (a01_obj01.NMAR) they seem to be OBJ related. Labels
include things like "a01_upNN" and "a01_windowNN".<BR>
The chunks seem to resemble those in RNAN/RECN files (Animation+Cells). Except,
the KBCM has 8-byte entries (unlike the 6-byte ones in KBEC):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 2    Unknown (000xh..007Ah, maybe time or so?)
  002h 2    Unknown (signed 16bit?)
  004h 2    Unknown (signed 16bit?)
  006h 2    Unknown (0x21h, with x=0..8)
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 _________________________ Nitro More Unknown Files  __________________________
</TD></TR></TABLE>
<BR>
Some 2D folders contain more unknown files (eg. DSi Camera
"rom:layout\cmn\fusion_camera.szs"):<BR>
<BR>
<B>JNBL (whatever, with .bnbl extension)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4     ID "JNBL"
  004h 2     Zero
  006h 2     Number of 6-byte entries (01h or more)
  008h N*6   Unknown
</TD></TR></TABLE>
<BR>
<B>JNCL (whatever, with .bncl extension)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4     ID "JNCL"
  004h 2     Zero (0000h)
  006h 2     Number of 8-byte entries (01h or more)
  008h N*8   Unknown (eg. 80h,10h,C0h,20h,00h,00h,00h,00h)
</TD></TR></TABLE>
<BR>
<B>JNLL (whatever, with .bnll extension)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4     ID "JNLL"
  004h 2     Zero (0000h)
  006h 2     Number of 16-byte entries (01h or more)
  008h N*16  Unknown (eg. 80h,50h,60h,10h,7Ch,29h,FFh,FDh,0Dh,19h,0,0,0,0,0,0)
</TD></TR></TABLE>
<BR>
<B>BNGL (whatever, with .bngl extension)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4   ID "BNGL"   ;this same as file extension (not JNGL)
  004h 2   Zero (0000h)
  006h 2   Number of ?-byte entries (01h or more)
  008h 2   Unknown (can be 02h,04h,06h,0Ah)
  00Ah 2   Number of ?-byte other entries maybe (01h or more)
  ...
  ...      Entries?
  ...      Other Entries?
  ...      Maybe More Other Entries?
</TD></TR></TABLE>
Filesize can range from 18h bytes to 24Ah bytes (or maybe yet smaller/biggger).<BR>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 ______________________________ .ntft and .ntfp _______________________________
</TD></TR></TABLE>
<BR>
<B>.ntft file</B><BR>
Probably texture data (maybe for use as extra 2D layer), size is usually/always
a power of 2 (ranging from 80h bytes to at least 64Kbytes (or even 512Kbytes?).
Color depth can be 16bit or 8bit (and maybe less). Files with less than 16bit
are bundled with a .ntfp palette file.<BR>
<BR>
<B>.ntfp file</B><BR>
Probably texture palette, with 16bit color numbers. The files can be quite
small (eg. only 6 or 8 bytes).<BR>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 ______________________________ .wmif and .wmpf _______________________________
</TD></TR></TABLE>
<BR>
DSi Sudoku rom:\Textures\ has "Wild Magic" .wmif and .wmpf (image+palette)
files.<BR>
<BR>
<B>.wmif file</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 1Bh  ID "Wild Magic Image File 3.00",00h
  01Bh 4    Palette Filename Length (eg. 0Dh)
  01Fh LEN  Palette Filename        (eg. "BG_Board.wmpf")
  ...  4    Texture Format (6=4bpp, 7=8bpp)
  ...  4    Texture Width in pixels
  ...  4    Texture Height in pixels
  ...  ..   Texture data
</TD></TR></TABLE>
<BR>
<B>.wmpf file</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 1Dh  ID "Wild Magic Palette File 1.00",00h
  01Dh 4    Zero?
  021h 4    Number of Colors
  025h ..   Colors, 16bit (0000h..7FFFh)
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dsfiles3dvideomostlyunknown"></A>
  DS Files - 3D Video (mostly unknown)
</FONT></TD></TR></TABLE><BR>
Some Nintendo DS games are use the following set of Nitro Studio files for 3D
Models:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  .NSBMD (ID="BMD0") - Nitro Polygon Model
  .NSBTX (ID="BTX0") - Nitro Texture and Palette
  .NSBCA (ID="BCA0") - Nitro Skeletal Character Animation
  .NSBTP (ID="BTP0") - Nitro Texture Pattern-swap Animation
  .NSBTA (ID="BTA0") - Nitro Texture UV-change Animation (aka texcoords?)
  .NSBMA (ID="BMA0") - Nitro Material-swap Animation (whut?)
  .NSBVA (ID="BVA0") - Nitro Vis... Animation?
</TD></TR></TABLE>
Unknown which games are actually using that format... probably some mid-NDS-era
titles from Nintendo (early NDS launch titles didn't use it, 3rd party NDS
titles tend to use custom formats, and later DSi mini-games don't support 3D
graphics at all).<BR>
<BR>
Below is an attempt to clean up rather confusing specs (hopefully appearing
less confusing, but probably containing some misinterpretations in cases where
the original specs where too confusing; the much-too-much confusing parts are
left intact and marked as unknown what they might be meant to mean).<BR>
<A HREF="#dsfiles3dvideobmd0modeldata">DS Files - 3D Video BMD0 (Model Data)</A><BR>
<A HREF="#dsfiles3dvideobtx0texture">DS Files - 3D Video BTX0 (Texture)</A><BR>
<A HREF="#dsfiles3dvideobca0characterskeletalanimation">DS Files - 3D Video BCA0 (Character Skeletal Animation)</A><BR>
<A HREF="#dsfiles3dvideobtp0bta0bma0nva0unknownanimations">DS Files - 3D Video BTP0/BTA0/BMA0/NVA0 (Unknown Animations)</A><BR>
Note: The format resembles the later CGFX format used on 3DS.<BR>
<BR>
<B>Dict "typedef struct Header" - alike "DICT" on 3DS?</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 1   Dummy 0
  001h 1   Amount of "objects"
  002h 2   Size of this Header (that is... what? header up to names?)
  ...  ..  Probably followed by the three sections mentioned below...?
</TD></TR></TABLE>
Unknown Section ;maybe Name lookup (Patricia Tree or Hash or so)?<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 Sub-Header
  000h 2   Size of this Sub-Header, always = 8
  002h 2   Size of this Unknown Section (that is... N*?+8 ...?)
  004h 4   Constant = 0000017Fh
 Unknown Data (repeats * Amount of "objects")
  008h 4   Unknown     ;1st object
  00Ch 4   ...         ;2nd object? or 2nd word of 1st object?
  etc                  ;etc?
</TD></TR></TABLE>
Data Info Section<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 The Data content depends on what the Dict is used for. It can contain
 4 or 8 bytes of data stored directly, or it can contain a 2 or 4 byte
 offset to larger data).
  000h 2      Size of each Data entry (siz) (usually 4 or 8)
  002h 2      Size of this Data Info Section (that is... N*siz+8 ...?)
  004h N*siz  Data (siz bytes, for each "object")
</TD></TR></TABLE>
Name Section<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h N*16   Name String (in ASCII maybe?) (for each "object")
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dsfiles3dvideobmd0modeldata"></A>
  DS Files - 3D Video BMD0 (Model Data)
</FONT></TD></TR></TABLE><BR>
Aka NSBMD<BR>
<BR>
<B>BMD0 Header</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4     ID "BMD0" (Basic Model Data)
  004h 2     Byte Order (FEFFh)
  006h 2     Version? (reportedly 1 or 2, in whatever audio/video files?)
  008h 4     Total Filesize
  00Ch 2     Size of this structure (always 16 ???)
  00Eh 2     Number of chunks (1=MDL0 or 2=MDL0+TEX0)
  010h 4     Offset to MDL0 Chunk
  014h 4     Offset to TEX0 Chunk (if any?) (otherwise TEX0 is in NSBTX file)
</TD></TR></TABLE>
<BR>
<B>MDL0 Chunk</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4     Chunk ID "MDL0" (Model Block)
  004h 4     Chunk Size
  008h ..    Model Dict (with 32bit offsets to Models from "Block_MDL0")
  ...  ..    Models
</TD></TR></TABLE>
<BR>
<B>Model (all offsets are relative to this Model section)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4    Size of Model (including these 4 bytes)
  004h 4    Offset of Additional Model Data          ;whut?
  008h 4    Offset of Texture &amp; Palette Offset       ;?
  00Ch 4    Offset of Display List Start             ;?
  010h 4    Offset of Display List End               ;?
  014h 1    Unknown
  015h 1    Unknown
  016h 1    Unknown
  017h 1    Amount of Objects           ;\
  018h 1    Amount of Materials         ; what for?
  019h 1    Amount of Polygons          ; is that just some usage comment,
  020h 4    Unknown                     ; for statistical purposes?
  024h 2    Amount of Vertices          ;
  026h 2    Amount of Surfaces          ;
  028h 2    Amount of Triangles         ;
  02Ah 2    Amount of Quads             ;/
  02Ch 2    Bounding box X      (signed fixed point 1.3.12)
  02Eh 2    Bounding box Y      (signed fixed point 1.3.12)
  030h 2    Bounding box Z      (signed fixed point 1.3.12)
  032h 2    Bounding box Width  (signed fixed point 1.3.12)
  034h 2    Bounding box Height (signed fixed point 1.3.12)
  036h 2    Bounding box Depth  (signed fixed point 1.3.12)
  038h 4    Runtime use data
  03Ch 4    Runtime use data
  040h ..   Polygonal Object Dict (with 32bit offsets to Objects from
                                                 "this Object Header")
  ...  ..   Object Definitions
</TD></TR></TABLE>
<BR>
<B>Object Definition (repeats * Amount of objects)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 In each definition:
  000h 1   Transform Flag byte
  001h 1   Unknown
  002h 1   Unknown
  003h 1   Unknown
  ...  4   Translation X (s32 signed fixed point 1.3.12)  ;\
  ...  4   Translation Y (s32 signed fixed point 1.3.12)  ; when Flags.0=0
  ...  4   Translation Z (s32 signed fixed point 1.3.12)  ;/
  ...  4   Scale X       (s32 signed fixed point 1.3.12)  ;\
  ...  4   Scale Y       (s32 signed fixed point 1.3.12)  ; when Flags.2=0
  ...  4   Scale Z       (s32 signed fixed point 1.3.12)  ;/
  ...  4   Rotation A    (s32 whatever, fixed point?)     ;\
  ...  4   Rotation B    (s32 whatever, fixed point?)     ; when Flags.1=0
  ...  4   Rotation C    (s32 whatever, fixed point?)     ; and Flags.3=0
  ...  4   Rotation D    (s32 whatever, fixed point?)     ;/
  ...  2   Pivot Rotation A (signed fixed point 1.3.12)   ;\when Flags.1=0
  ...  2   Pivot Rotation B (signed fixed point 1.3.12)   ;/and Flags.3=1
</TD></TR></TABLE>
Unknown how above "1.3.12" can be "s32" (maybe actually 17.3.12 ?)<BR>
The Transform Flag bits are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0    Translation   (0=Yes, 1=No)
  1    Rotation      (0=Yes, 1=No)
  2    Scaling       (0=Yes, 1=No)
  3    Rotation Type (0=Rotate A,B,C,D, 1=Pivot A,B)
  4-7  Pivot Matrix  (0..8, see below) (used when bit1=0 and bit3=1)
</TD></TR></TABLE>
Pivot matrix type (0..8):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0:  | 1  0  0|  1:  | 0  1  0|  2:  | 0  0  1|
      | 0  A  B|      | A  0  B|      | A  B  0|
      | 0  B -A|      | B  0 -A|      | B -A  0|
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  3:  | 0  A  B|  4:  | A  0  B|  5:  | A  B  0|
      | 1  0  0|      | 0  1  0|      | 0  0  1|
      | 0  B -A|      | B  0 -A|      | B -A  0|
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  6:  | 0  A  B|  7:  | A  0  B|  8:  | A  B  0|
      | 0  B -A|      | B  0 -A|      | B -A  0|
      | 1  0  0|      | 0  1  0|      | 0  0  1|
</TD></TR></TABLE>
Non-Pivot does probably also use some kind of matrix made of A,B,C,D...?<BR>
<BR>
<B>Bone/Skeleton Section  &lt;-- what is that? does it follow after above?</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h ..    Definitions
</TD></TR></TABLE>
Each definition consists of 1 Command Byte + Parameters. Each Parameter is 1
byte.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Cmd  Params  Description
  06h  3       params: Object ID, Parent ID, dummy 0
  26h  4       params: Object ID, Parent ID, dummy 0, Stack ID
  46h  4       params: Object ID, Parent ID, dummy 0, Stack ID
  66h  5       params: Object ID, Parent ID, dummy 0, Stack ID, Restore ID
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h  0       NOP (empty command)
  01h  0       End of Bone/Skeleton Section
  02h  2       params: Node ID, Visibility
  03h  1       Set Polygon Stack ID?
  04h  3       params: Material ID, 05h, Polygon ID
  05h  1       ??
  06h  3       params: Object ID, Parent ID, Dummy 0
  07h  1       ??
  08h  1       ??
  09h  8       ??
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0Bh  0       BEGIN (indicate begin of Polygon/Material pairing)
  2Bh  0       END (indicate end of Polygon/Material pairing)
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  These are Material/Polygon pairing commands, 4 bytes.
  The lower nibble of 2nd Parameter must be 5.
  04h  3       Material ID, 05, Polygon ID
  24h  3       ...
  44h  3       ...
</TD></TR></TABLE>
<BR>
<B>Texture &amp; Palette Offset  &lt;-- what is that, addressed from Model [008h] ?</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
    000h 2   Offset of Texture Section (relative to Texture &amp; Palette Offset)
    002h 2   Offset of Palette Section (relative to Texture &amp; Palette Offset)
</TD></TR></TABLE>
<BR>
<B>Material Section          &lt;-- WHAT is THAT ??? and WHERE is it ???</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
    Dict struct Header;// Material Header: one Header object for each material
    {// The 'Data' for this Header is like so:
      000h 4   Offset of Material Definition, relative to the start of
                 this Material Section
    }
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
    Texture Section
      Dict struct Header;// Texture Header: one Header object for each texture
      {// The u32 'Data' for this Header is like so:
          000h 2   Offset of Matching Data (relative to Texture &amp; Palette
                     Offset)
          002h 2   Amount of associated Materials (a texture can be in more
                     than one material)
      }
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
    Palette Section
      Dict struct Header;// Palette Header: one Header object for each palette
      {// The u32 'Data' for this Header is like so:
          000h 2   Offset of Matching Data (relative to Texture &amp; Palette
                     Offset)
          002h 2   Amount of associated Materials (a palette can be in more
                     than one material)
      }
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
    Material Definition (repeats * Amount of Materials)
      ;// Usually 48 bytes for each material
</TD></TR></TABLE>
<BR>
<B>Polygon Section</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
    Dict struct Header;// Polygon Header: one Header object for each material
    {// The 'Data' for this Header is like so:
        000h 4   Offset of Polygon Definition, relative to the start of this
                   Polygon Section
    }
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
    Polygon Definition (repeats * Amount of Polygons) (10h-bytes each)
      000h 4   Unknown
      004h 4   Unknown
      008h 4   Offset of Display List, relative to Polygon Definition
      00Ch 4   Size of Display List
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
    Display List
      // The Display List is actually packed geometry command.
      // See the DStek specification for more information:
      // <A HREF="http://www.akkit.org/info/gbatek.htm#ds3dvideo"><FONT COLOR=#808080>http://www.akkit.org/info/gbatek.htm#ds3dvideo</FONT></A>    ;uh?
</TD></TR></TABLE>
<BR>
<BR>
<B>TEX0 Chunk</B><BR>
Reportedly same as in BTX0 files, see there for details.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dsfiles3dvideobtx0texture"></A>
  DS Files - 3D Video BTX0 (Texture)
</FONT></TD></TR></TABLE><BR>
The NSBTX file format stores texture image and palette information.<BR>
The "TEX0" Block can be found in certain NSBMD files, not just in NSBTX files.<BR>
<BR>
<B>BTX0 Header</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4     ID "BTX0" (Basic Texture)
  004h 2     Byte Order (FEFFh)
  006h 2     Version? (reportedly 1 or 2, in whatever audio/video files?)
  008h 4     Total Filesize
  00Ch 2     Size of this structure (always 16 ???)
  00Eh 2     Number of chunks (1=TEX0)
  010h 4     Offset to TEX0 Chunk
</TD></TR></TABLE>
<BR>
<B>TEX0 Chunk</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4     Chunk ID "TEX0" (Texture Block)
  004h 4     Chunk Size
  008h 4     Padding (0)
  00Ch 2     Texture Data Size (bitshift &lt;&lt; 3)             ;\
  00Eh 2     Texture Dict Offset (03Ch)                    ; Texture
  010h 4     Padding (0)                                   ;
  014h 4     Texture Data Offset                           ;/
  018h 4     Padding (0)
  01Ch 2     Compressed Texture Data Size (bitshift &lt;&lt; 3)  ;\&lt;-- Size
  01Eh 2     Compressed Texture Dict? Offset (03Ch, again?); &lt;-- Dict?
  020h 4     Padding (0)                                   ;
  024h 4     Compressed Texture Data Offset                ; &lt;-- Data
  028h 4     Compressed Texture Info Data Offset           ;/&lt;-- InfoData?
  02Ch 4     Padding (0)
  030h 4     Palette Data Size (bitshift &lt;&lt; 3)             ;\
  034h 4     Palette Dict Offset                           ; Palette
  038h 4     Palette Data Offset                           ;/
  03Ch ..    Texture Dict (with 8-byte entries, see below)
  N/A? ?     Compressed Texture Dict? (maybe here? with whatever entries?)
  ...  ..    Palette Dict (with 4-byte entries, see below)
  ...  ..    Texture Data Section     (unknown... maybe bitmap/pixels?)
  ...  ..    Compressed Texture Data Section            (unknown...)
  ...  ..    Compressed Texture Info Data Section       (unknown...)
  ...  ..    Palette Data Section     (unknown... maybe palette/colors?)
</TD></TR></TABLE>
<BR>
<B>Format of 8-byte entries in Texture Dict:</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 2     Texture Offset (bitshift &lt;&lt; 3), relative to the start
                                             of Texture Data
  002h 2     Parameters   ;&lt;-- probably "upper 16bit of TEXIMAGE_PARAM" ?
                The format is, using knock-out description:
                bit:  15..............0
                   0 b --CFFFHHHWWW-----   &lt;-- uh, is that "0 b" and 17bits???
                where:
                  C = Palette ID
                  F = Format (0-7)
                  H = Height (8 &lt;&lt; Height)
                  W = Width (8 &lt;&lt; Width)
                To Calculate the Data Size of a Texture:
                Bit Depth = Format: &lt;0, 8, 2, 4, 8, 2, 8, 16&gt;
                Width * Height * BitDepth / 8
  004h 1     Width (should match W &lt;&lt; 3)
  005h 1     Unknown (is 00h or 80h)
  006h 1     Height? (can be 0, 1, 2, 4, 8)
  007h 1     Unknown (is 80h)
</TD></TR></TABLE>
<BR>
<B>Compressed Texture Dict? (maybe here? with whatever entries?)</B><BR>
Compressed Texture might have a Dict, too? with whatever entries?<BR>
<BR>
<B>Format of 4-byte entries in Palette Dict:</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h   2   u16 ;// (bitshift &lt;&lt; 3) Palette Offset, relative to the start
                                                     of Palette Data
  000h?  2   u16 ;// Unknown (is 0 or 1)
</TD></TR></TABLE>
<BR>
Texture Data Section:<BR>
Compressed Texture Data Section:<BR>
Compressed Texture Info Data Section:<BR>
Palette Data Section:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Unknown
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dsfiles3dvideobca0characterskeletalanimation"></A>
  DS Files - 3D Video BCA0 (Character Skeletal Animation)
</FONT></TD></TR></TABLE><BR>
The NSBCA file format stores character skeletal/bone/joint animation data.<BR>
<BR>
<B>BCA0 Header</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4     ID "BCA0" (Basic Character Animation)
  004h 2     Byte Order (FEFFh)
  006h 2     Version? (reportedly 1 or 2, in whatever audio/video files?)
  008h 4     Total Filesize
  00Ch 2     Size of this structure (always 16 ???)
  00Eh 2     Number of chunks (1=JNT0)
  010h 4     Offset to JNT0 Chunk
</TD></TR></TABLE>
<BR>
<B>JNT0 Chunk</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4     Chunk ID "JNT0" (Joint Block)
  004h 4     Chunk Size
  008h ..    Joint Dict (with 32bit offsets to Joints, from "Block_JNT0")
</TD></TR></TABLE>
<BR>
<B>Joints</B><BR>
Reportedly Joints "repeats * Amount of Objects"<BR>
Uh, with Amount of Objects stored inside of below?<BR>
Maybe rather meant to mean that Joints exist for each Model (not Object)?<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4    ID 'J.AC' (Joint Animation Content ?)
  004h 2    Amount of Frames
  006h 2    Amount of Objects (should be same as in BMD0 file)
  008h 4    Unknown
  00Ch 4    Offset to Unknown1 chunk. Relative to start of this block.
  010h 4    Offset to Unknown2 chunk. Relative to start of this block.
  014h 4    Object Info Offset (repeats * Amount of Objects), relative
               to start of this Joint Section.
               uh, is above meant to be Offset to first Object?
               or an array with Offsets to all Objects?
  ...  ..   Object Info, for each object (supposedly here?)
  ...  ..   Unknown1
  ...  ..   Unknown2
  ...  ..   Reportedly "end of file" (is that possible with multiple joints?)
</TD></TR></TABLE>
<BR>
<B>Object Info - Repeats * Number of Objects</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
    000h 2   Flag - Indicates what sort of Transformations are applied.
              Bit0  -  Unused?
              Bit1  T  Translate  (0=Yes; data follows, 1=No?)
              Bit2  -  Unused?
              Bit3  X  Affects how WHICH data is stored but dunno WHERE?
              Bit4  Y  Affects how WHICH data is stored but dunno WHERE?
              Bit5  Z  Affects how WHICH data is stored but dunno WHERE?
              Bit6  R  Rotate     (0=Yes; data follows, 1=No?)
              Bit7  -  Unused?
              Bit8  r  Affects how WHICH data is stored but dunno WHERE?
              Bit9  S  Scale      (0=Yes; data follows, 1=No?)
              Bit10 -  Unused?
              Bit11 x  Affects how WHICH data is stored but dunno WHERE?
              Bit12 y  Affects how WHICH data is stored but dunno WHERE?
              Bit13 z  Affects how WHICH data is stored but dunno WHERE?
              Bit14 -  Unused?
              Bit15 -  Unused?
    002h 1   Unknown   (reportedly u32, 1-byte wide ???)
    003h 1   ID Number (reportedly u32, 1-byte wide ???)
  *** (Unknown what below crap means, it does probably refer to multiple
  *** entries, for Translate, Rotate, and Scale; and possibly even to
  *** multiple sub-entries for X,Y,Z or whatever?)
  Transformation Info (Translation XYZ, Rotation, Scale XYZ) when WHAT=1
    000h 4   Actual value (uh, WHICH value?)
  Transformation Info (Translation XYZ, Rotation, Scale XYZ) when WHAT=0
    000h 2   Unknown - typically 0000h
    002h 2   Unknown
    004h 4   Offset to data. Relative to "(Object Info Offset + 4)".
</TD></TR></TABLE>
<BR>
<B>Unknown1 - Repeats until Unknown2</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 2   Reportedly 36, 32 &amp; 0.
  002h 2   Unknown (reportedly signed)
  004h 2   Unknown (reportedly signed)
</TD></TR></TABLE>
<BR>
<B>Unknown2 - Repeats until end of file</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  "All transformation offsets point somewhere in this section.
  It's clearly broken up into parts (Translation, Rotation &amp; Scale),
  however I'm not totally sure how data is store in here yet."
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dsfiles3dvideobtp0bta0bma0nva0unknownanimations"></A>
  DS Files - 3D Video BTP0/BTA0/BMA0/NVA0 (Unknown Animations)
</FONT></TD></TR></TABLE><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 ____________ DS Files - 3D Video BTP0 (Texture Pattern Animation) ____________
</TD></TR></TABLE>
<BR>
<B>BTP0 Header</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4     ID "BTP0" (Texture Pattern Animation)
  ...  ..    XXX
</TD></TR></TABLE>
<BR>
<B>PAT0 Chunk</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4     Chunk ID "PAT0" (Pattern Block)
  004h 4     Chunk Size
  ...  ..    Unknown
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 ________________ DS Files - 3D Video BTA0 (Texture Animation) ________________
</TD></TR></TABLE>
<BR>
<B>BTA0 Header</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4     ID "BTA0" (Texture Animation)
  ...  ..    XXX
</TD></TR></TABLE>
<BR>
<B>SRT0 Chunk</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4     Chunk ID "SRT0"   (maybe short for Scale/Rotate/Translate?)
  004h 4     Chunk Size
  ...  ..    Unknown
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 _______________ DS Files - 3D Video BMA0 (Material Animation) ________________
</TD></TR></TABLE>
<BR>
<B>BMA0 Header</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4     ID "BMA0" (Material Animation)
  ...  ..    XXX
</TD></TR></TABLE>
<BR>
<B>MAT0 Chunk</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4     Chunk ID "MAT0" (Material Block)
  004h 4     Chunk Size
  ...  ..    Unknown
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 ____________________ DS Files - 3D Video BVA0 (Unknown?) _____________________
</TD></TR></TABLE>
<BR>
<B>BVA0 Header</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4     ID "BVA0" (whatever Vis... Animation?)
  ...  ..    XXX
</TD></TR></TABLE>
<BR>
<B>VIS0 Chunk</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4     Chunk ID "VIS0" (Visibility...?)
  004h 4     Chunk Size
  ...  ..    Unknown
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="ds3dvideo"></A>
  DS 3D Video
</FONT></TD></TR></TABLE><BR>
<A HREF="#ds3doverview">DS 3D Overview</A><BR>
<A HREF="#ds3diomap">DS 3D I/O Map</A><BR>
<A HREF="#ds3ddisplaycontrol">DS 3D Display Control</A><BR>
<A HREF="#ds3dgeometrycommands">DS 3D Geometry Commands</A><BR>
<A HREF="#ds3dmatrixloadmultiply">DS 3D Matrix Load/Multiply</A><BR>
<A HREF="#ds3dmatrixtypes">DS 3D Matrix Types</A><BR>
<A HREF="#ds3dmatrixstack">DS 3D Matrix Stack</A><BR>
<A HREF="#ds3dmatrixexamplesprojection">DS 3D Matrix Examples (Projection)</A><BR>
<A HREF="#ds3dmatrixexamplesrotatescaletranslate">DS 3D Matrix Examples (Rotate/Scale/Translate)</A><BR>
<A HREF="#ds3dmatrixexamplesmathsbasics">DS 3D Matrix Examples (Maths Basics)</A><BR>
<A HREF="#ds3dpolygonattributes">DS 3D Polygon Attributes</A><BR>
<A HREF="#ds3dpolygondefinitionsbyvertices">DS 3D Polygon Definitions by Vertices</A><BR>
<A HREF="#ds3dpolygonlightparameters">DS 3D Polygon Light Parameters</A><BR>
<A HREF="#ds3dshadowpolygons">DS 3D Shadow Polygons</A><BR>
<A HREF="#ds3dtextureattributes">DS 3D Texture Attributes</A><BR>
<A HREF="#ds3dtextureformats">DS 3D Texture Formats</A><BR>
<A HREF="#ds3dtexturecoordinates">DS 3D Texture Coordinates</A><BR>
<A HREF="#ds3dtextureblending">DS 3D Texture Blending</A><BR>
<A HREF="#ds3dtoonedgefogalphablendingantialiasing">DS 3D Toon, Edge, Fog, Alpha-Blending, Anti-Aliasing</A><BR>
<A HREF="#ds3dstatus">DS 3D Status</A><BR>
<A HREF="#ds3dtests">DS 3D Tests</A><BR>
<A HREF="#ds3drearplane">DS 3D Rear-Plane</A><BR>
<A HREF="#ds3dfinal2doutput">DS 3D Final 2D Output</A><BR>
<BR>
3D is more or less (about 92%) understood and described.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="ds3doverview"></A>
  DS 3D Overview
</FONT></TD></TR></TABLE><BR>
The NDS 3D hardware consists of a Geometry Engine, and a Rendering Engine.<BR>
<BR>
<B>Geometry Engine (Precalculate coordinates &amp; assign polygon attributes)</B><BR>
Geometry commands can be sent via Ports 4000440h and up (or alternately,
written directly to Port 4000400h).<BR>
The commands include matrix and vector multiplications, the purpose is to
rotate/scale/translate coordinates (vertices), the resulting coordinates are
stored in Vertex RAM.<BR>
Moreover, it allows to assign attributes to the polygons and vertices, that
includes vertex colors (or automatically calculated light colors), texture
attributes, number of vertices per polygon (three or four), and a number of
flags, these attributes are stored in Polygon RAM. Polygon RAM also contains
pointers to the corresponding vertices in Vertex RAM.<BR>
<BR>
<B>Swap Buffers (Pass data from the Geometry Engine to the Rendering Engine)</B><BR>
The hardware includes two sets of Vertex/Polygon RAM, one used by the Geometry
Engine, one by the Rendering Engine. The SwapBuffers command simply exchanges
these buffers (so the new Geometry Data is passed to the Rendering Engine) (and
the old buffer is emptied, so the Geometry engine can write new data to it).
Additionally, the two parameter bits from the &lt;previous&gt; SwapBuffers
command are copied to the Geometry Engine.<BR>
Data that is NOT swapped: SwapBuffers obviously can't swap Texture memory (so
software must take care that Texture memory is kept mapped throughout
rendering). Moreover, the rendering control registers (ports 4000060h, and
4000330h..40003BFh) are not swapped (so that values must be kept intact during
rendering, too).<BR>
<BR>
<B>Rendering Engine (Display Output)</B><BR>
The Rendering Engine draws the various Polygons, and outputs them as BG0 layer
to the 2D Video controller (which may then output them to the screen, or to the
video capture unit). The Rendering part is done automatically by hardware, so
the software has little influence on it.<BR>
Rendering is done scanline-by-scanline, so there's only a limited number of
clock cycles per scanline, which is limiting the maximum number of polygons per
scanline. However, due to the 48-line cache (see below), some scanlines are
allowed to exceed that maximum.<BR>
Rendering starts 48 lines in advance (while still in the Vblank period) (and
does then continue throughout the whole display period), the rendered data is
written to a small cache that can hold up to 48 scanlines.<BR>
<BR>
<B>Scanline Cache vs Framebuffer</B><BR>
Note: There's only the 48-line cache (not a full 192-line framebuffer to store
the whole rendered image). That is perfectly reasonable since animated data is
normally drawn only once (so there would be no need to store it). That,
assuming that the Geometry Engine presents new data every frame (otherwise, if
the Geometry software is too slow, or if the image isn't animated, then the
hardware is automatically rendering the same image again, and again).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="ds3diomap"></A>
  DS 3D I/O Map
</FONT></TD></TR></TABLE><BR>
<B>3D I/O Map</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Address  Siz Name            Expl.
<B>  Rendering Engine (per Frame settings)</B>
  4000060h 2   DISP3DCNT       3D Display Control Register (R/W)
  4000320h 1   RDLINES_COUNT   Rendered Line Count Register (R)
  4000330h 10h EDGE_COLOR      Edge Colors 0..7 (W)
  4000340h 1   ALPHA_TEST_REF  Alpha-Test Comparision Value (W)
  4000350h 4   CLEAR_COLOR     Clear Color Attribute Register (W)
  4000354h 2   CLEAR_DEPTH     Clear Depth Register (W)
  4000356h 2   CLRIMAGE_OFFSET Rear-plane Bitmap Scroll Offsets (W)
  4000358h 4   FOG_COLOR       Fog Color (W)
  400035Ch 2   FOG_OFFSET      Fog Depth Offset (W)
  4000360h 20h FOG_TABLE       Fog Density Table, 32 entries (W)
  4000380h 40h TOON_TABLE      Toon Table, 32 colors (W)
<B>  Geometry Engine (per Polygon/Vertex settings)</B>
  4000400h 40h GXFIFO          Geometry Command FIFO (W)
  4000440h ... ...             Geometry Command Ports (see below)
  4000600h 4   GXSTAT          Geometry Engine Status Register (R and R/W)
  4000604h 4   RAM_COUNT       Polygon List &amp; Vertex RAM Count Register (R)
  4000610h 2   DISP_1DOT_DEPTH 1-Dot Polygon Display Boundary Depth (W)
  4000620h 10h POS_RESULT      Position Test Results (R)
  4000630h 6   VEC_RESULT      Vector Test Results (R)
  4000640h 40h CLIPMTX_RESULT  Read Current Clip Coordinates Matrix (R)
  4000680h 24h VECMTX_RESULT   Read Current Directional Vector Matrix (R)
</TD></TR></TABLE>
<BR>
<B>Geometry Commands (can be invoked by Port Address, or by Command ID)</B><BR>
Table shows Port Address, Command ID, Number of Parameters, and Clock Cycles.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Address  Cmd Pa.Cy.
  N/A      00h -  -   NOP - No Operation (for padding packed GXFIFO commands)
  4000440h 10h 1  1   MTX_MODE - Set Matrix Mode (W)
  4000444h 11h -  17  MTX_PUSH - Push Current Matrix on Stack (W)
  4000448h 12h 1  36  MTX_POP - Pop Current Matrix from Stack (W)
  400044Ch 13h 1  17  MTX_STORE - Store Current Matrix on Stack (W)
  4000450h 14h 1  36  MTX_RESTORE - Restore Current Matrix from Stack (W)
  4000454h 15h -  19  MTX_IDENTITY - Load Unit Matrix to Current Matrix (W)
  4000458h 16h 16 34  MTX_LOAD_4x4 - Load 4x4 Matrix to Current Matrix (W)
  400045Ch 17h 12 30  MTX_LOAD_4x3 - Load 4x3 Matrix to Current Matrix (W)
  4000460h 18h 16 35* MTX_MULT_4x4 - Multiply Current Matrix by 4x4 Matrix (W)
  4000464h 19h 12 31* MTX_MULT_4x3 - Multiply Current Matrix by 4x3 Matrix (W)
  4000468h 1Ah 9  28* MTX_MULT_3x3 - Multiply Current Matrix by 3x3 Matrix (W)
  400046Ch 1Bh 3  22  MTX_SCALE - Multiply Current Matrix by Scale Matrix (W)
  4000470h 1Ch 3  22* MTX_TRANS - Mult. Curr. Matrix by Translation Matrix (W)
  4000480h 20h 1  1   COLOR - Directly Set Vertex Color (W)
  4000484h 21h 1  9*  NORMAL - Set Normal Vector (W)
  4000488h 22h 1  1   TEXCOORD - Set Texture Coordinates (W)
  400048Ch 23h 2  9   VTX_16 - Set Vertex XYZ Coordinates (W)
  4000490h 24h 1  8   VTX_10 - Set Vertex XYZ Coordinates (W)
  4000494h 25h 1  8   VTX_XY - Set Vertex XY Coordinates (W)
  4000498h 26h 1  8   VTX_XZ - Set Vertex XZ Coordinates (W)
  400049Ch 27h 1  8   VTX_YZ - Set Vertex YZ Coordinates (W)
  40004A0h 28h 1  8   VTX_DIFF - Set Relative Vertex Coordinates (W)
  40004A4h 29h 1  1   POLYGON_ATTR - Set Polygon Attributes (W)
  40004A8h 2Ah 1  1   TEXIMAGE_PARAM - Set Texture Parameters (W)
  40004ACh 2Bh 1  1   PLTT_BASE - Set Texture Palette Base Address (W)
  40004C0h 30h 1  4   DIF_AMB - MaterialColor0 - Diffuse/Ambient Reflect. (W)
  40004C4h 31h 1  4   SPE_EMI - MaterialColor1 - Specular Ref. &amp; Emission (W)
  40004C8h 32h 1  6   LIGHT_VECTOR - Set Light's Directional Vector (W)
  40004CCh 33h 1  1   LIGHT_COLOR - Set Light Color (W)
  40004D0h 34h 32 32  SHININESS - Specular Reflection Shininess Table (W)
  4000500h 40h 1  1   BEGIN_VTXS - Start of Vertex List (W)
  4000504h 41h -  1   END_VTXS - End of Vertex List (W)
  4000540h 50h 1  392 SWAP_BUFFERS - Swap Rendering Engine Buffer (W)
  4000580h 60h 1  1   VIEWPORT - Set Viewport (W)
  40005C0h 70h 3  103 BOX_TEST - Test if Cuboid Sits inside View Volume (W)
  40005C4h 71h 2  9   POS_TEST - Set Position Coordinates for Test (W)
  40005C8h 72h 1  5   VEC_TEST - Set Directional Vector for Test (W)
</TD></TR></TABLE>
All cycle timings are counted in 33.51MHz units. NORMAL commands takes 9..12
cycles, depending on the number of enabled lights in PolyAttr (Huh, 9..12 (four
timings) cycles for 0..4 (five settings) lights?) Total execution time of
SwapBuffers is Duration until VBlank, plus 392 cycles.<BR>
In MTX_MODE=2 (Simultanous Set), MTX_MULT/TRANS take additional 30 cycles.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="ds3ddisplaycontrol"></A>
  DS 3D Display Control
</FONT></TD></TR></TABLE><BR>
<B>4000060h - DISP3DCNT - 3D Display Control Register (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Texture Mapping      (0=Disable, 1=Enable)
  1     PolygonAttr Shading  (0=Toon Shading, 1=Highlight Shading)
  2     Alpha-Test           (0=Disable, 1=Enable) (see ALPHA_TEST_REF)
  3     Alpha-Blending       (0=Disable, 1=Enable) (see various Alpha values)
  4     Anti-Aliasing        (0=Disable, 1=Enable)
  5     Edge-Marking         (0=Disable, 1=Enable) (see EDGE_COLOR)
  6     Fog Color/Alpha Mode (0=Alpha and Color, 1=Only Alpha) (see FOG_COLOR)
  7     Fog Master Enable    (0=Disable, 1=Enable)
  8-11  Fog Depth Shift      (FOG_STEP=400h shr FOG_SHIFT) (see FOG_OFFSET)
  12    Color Buffer RDLINES Underflow (0=None, 1=Underflow/Acknowledge)
  13    Polygon/Vertex RAM Overflow    (0=None, 1=Overflow/Acknowledge)
  14    Rear-Plane Mode                (0=Blank, 1=Bitmap)
  15-31 Not used
</TD></TR></TABLE>
<BR>
<B>4000540h - Cmd 50h - SWAP_BUFFERS - Swap Rendering Engine Buffer (W)</B><BR>
SwapBuffers exchanges the two sets of Polygon/Vertex RAM buffers, that is, the
newly defined polygons/vertices are passed to the rendering engine (and will be
displayed in following frame(s)). The other buffer is emptied, and passed to
the Geometry Engine (to be filled with new polygons/vertices by Geometry
Commands).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Translucent polygon Y-sorting (0=Auto-sort, 1=Manual-sort)
  1     Depth Buffering  (0=With Z-value, 1=With W-value)
        (mode 1 does not function properly with orthogonal projections)
  2-31  Not used
</TD></TR></TABLE>
SwapBuffers isn't executed until next VBlank (Scanline 192) (the Geometry
Engine is halted for that duration). SwapBuffers should not be issued within
Begin/End. The two parameter bits of the SwapBuffers command are used for the
following gxcommands (ie. not for the old gxcommands prior to SwapBuffers).<BR>
SwapBuffers does lock-up the 3D hardware if an incomplete polygon list has been
defined (eg. a triangle with only 2 vertices). On lock-up, only 2D video is
kept working, any wait-loops for GXSTAT.27 will hang the program. Once lock-up
has occured, there seems to be no way to recover by software, not by sending
the missing veric(es), and not even by pulsing POWCNT1.Bit2-3.<BR>
<BR>
<B>4000580h - Cmd 60h - VIEWPORT - Set Viewport (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-7   Screen/BG0 Coordinate X1 (0..255) (For Fullscreen: 0=Left-most)
  8-15  Screen/BG0 Coordinate Y1 (0..191) (For Fullscreen: 0=Bottom-most)
  16-23 Screen/BG0 Coordinate X2 (0..255) (For Fullscreen: 255=Right-most)
  24-31 Screen/BG0 Coordinate Y2 (0..191) (For Fullscreen: 191=Top-most)
</TD></TR></TABLE>
Coordinate 0,0 is the lower-left (unlike for 2D where it'd be upper-left).<BR>
The 3D view-volume (size as defined by the Projection Matrix) is automatically
scaled to match into the Viewport area. Although polygon vertices are clipped
to the view-volume, some vertices may still exceed to X2,Y1 (lower-right)
boundary by one pixel, due to some sort of rounding errors. The Viewport
settings don't affect the size or position of the 3D Rear-Plane. Viewport
should not be issued within Begin/End.<BR>
<BR>
<B>4000610h - DISP_1DOT_DEPTH - 1-Dot Polygon Display Boundary Depth (W)</B><BR>
1-Dot Polygons are very small, or very distant polygons, which would be
rendered as a single pixel on screen. Polygons with a depth value greater (more
distant) than DISP_1DOT_DEPTH can be automatically hidden; in order to reduce
memory consumption, or to reduce dirt on the screen.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-14  W-Coordinate (Unsigned, 12bit integer, 3bit fractional part)
  15-31 Not used                 (0000h=Closest, 7FFFh=Most Distant)
</TD></TR></TABLE>
The DISP_1DOT_DEPTH comparision can be enabled/disabled per polygon (via
POLYGON_ATTR.Bit13), so "important" polygons can be displayed regardless of
their size and distance.<BR>
Note: The comparision is always using the W-coordinate of the vertex (not the
Z-coordinate) (ie. no matter if using Z-buffering, or W-buffering). The polygon
is rendered if at least one of its vertices is having a w-coordinate less or
equal than DISP_1DOT_DEPTH. NB. despite of checking the w-coords of ALL
vertices, the polygon is rendered using the color/depth/texture of its FIRST
vertex.<BR>
Note: The hardware does round-up the width and height of all polygons to at
least 1, so polygons of 0x0, 1x0, 0x1, and 1x1 dots will be all rounded-up to a
size of 1x1. Of which, the so-called "1dot" depth check is applied only to the
0x0 dot variant (so "0dot" depth check would be a better name for it).<BR>
Caution: Although DISP_1DOT_DEPTH is a Geometry Engine parameter, it is NOT
routed through GXFIFO, ie. changes will take place immediately, and will affect
all following polygons, including such that are still in GXFIFO. Workaround:
ensure that GXFIFO is empty before changing this parameter.<BR>
<BR>
<B>4000340h - ALPHA_TEST_REF - Alpha-Test Comparision Value (W)</B><BR>
Alpha Test can be enabled in DISP3DCNT.Bit2. When enabled, pixels are rendered
only if their Alpha value is GREATER than ALPHA_TEST_REF. Otherwise, when
disabled, pixels are rendered only if their Alpha value is GREATER than zero.
Alpha Test is performed on the final polygon pixels (ie. after texture
blending).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-4   Alpha-Test Comparision Value (0..31) (Draw pixels if Alpha&gt;AlphaRef)
  5-31  Not used
</TD></TR></TABLE>
Value 00h is effectively the same as when Alpha Test is disabled. Value 1Fh
hides all polygons, including opaque ones.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="ds3dgeometrycommands"></A>
  DS 3D Geometry Commands
</FONT></TD></TR></TABLE><BR>
<B>4000400h - GXFIFO - Geometry Command FIFO (W) (mirrored up to 400043Fh?)</B><BR>
Used to send packed commands, unpacked commands,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-7   First  Packed Command (or Unpacked Command)
  8-15  Second Packed Command (or 00h=None)
  16-23 Third  Packed Command (or 00h=None)
  24-31 Fourth Packed Command (or 00h=None)
</TD></TR></TABLE>
and parameters,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-31  Parameter data for the previously sent (packed) command(s)
</TD></TR></TABLE>
to the Geometry engine.<BR>
<BR>
<B>FIFO / PIPE Number of Entries</B><BR>
The FIFO has 256 entries, additionally, there is a PIPE with four entries
(giving a total of 260 entries). If the FIFO is empty, and if the PIPE isn't
full, then data is moved directly into the PIPE, otherwise it is moved into the
FIFO. If the PIPE runs half empty (less than 3 entries) then 2 entries are
moved from the FIFO to the PIPE. The state of the FIFO can be obtained in
GXSTAT.Bit16-26, observe that there may be still data in the PIPE, even if the
FIFO is empty. Check the busy flag in GXSTAT.Bit27 to see if the PIPE or FIFO
contains data (or if a command is still executing).<BR>
Each PIPE/FIFO entry consists of 40bits of data (8bit command code, plus 32bit
parameter value). Commands without parameters occupy 1 entry, and Commands with
N parameters occupy N entries.<BR>
<BR>
<B>Sending Commands by Ports 4000440h..40005FFh</B><BR>
Geometry commands can be indirectly sent to the FIFO via ports 4000440h and up.<BR>
For a command with N paramters: issue N writes to the port.<BR>
For a command without parameters: issue one dummy-write to the port.<BR>
That mechanism puts the 8bit command + 32bit parameter into the FIFO/PIPE.<BR>
If the FIFO is full, then a wait is generated until data is removed from the
FIFO, ie. the STR opcode gets freezed, during the wait, the bus cannot be used
even by DMA, interrupts, or by the NDS7 CPU.<BR>
<BR>
<B>GXFIFO Access via DMA</B><BR>
Larger pre-calculated data blocks can be sent directly to the FIFO. This is
usually done via DMA (use DMA in Geometry Command Mode, 32bit units,
Dest=4000400h/fixed, Length=NumWords, Repeat=0). The timings are handled
automatically, ie. the system (should) doesn't freeze when the FIFO is full
(see below Overkill note though). DMA starts when the FIFO becomes less than
half full, the DMA does then write 112 words to the GXFIFO register (or less,
if the remaining DMA transfer length gets zero).<BR>
<BR>
<B>GXFIFO Access via STR,STRD,STM</B><BR>
If desired, STR,STRD,STM opcodes can be used to write to the FIFO.<BR>
Opcodes that write more than one 32bit value (ie. STRD and STM) can be used to
send ONE UNPACKED command, plus any parameters which belong to that command.
After that, there must be a 1 cycle delay before sending the next command (ie.
one cannot sent more than one command at once with a single opcode, each
command must be invoked by a new opcode). STRD and STM can be used because the
GXFIFO register is mirrored to 4000400h..43Fh (16 words).<BR>
As with Ports 4000440h and up, the CPU gets stopped if (and as long as) the
FIFO is full.<BR>
<BR>
<B>GXFIFO / Unpacked Commands</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  - command1 (upper 24bit zero)
  - parameter(s) for command1 (if any)
  - command2 (upper 24bit zero)
  - parameter(s) for command2 (if any)
  - command3 (upper 24bit zero)
  - parameter(s) for command3 (if any)
</TD></TR></TABLE>
<BR>
<B>GXFIFO / Packed Commands</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  - command1,2,3,4 packed into one 32bit value (all bits used)
  - parameter(s) for command1 (if any)
  - parameter(s) for command2 (if any)
  - parameter(s) for command3 (if any)
  - parameter(s) for command4 (top-most packed command MUST have parameters)
  - command5,6 packed into one 32bit value (upper 16bit zero)
  - parameter(s) for command5 (if any)
  - parameter(s) for command6 (top-most packed command MUST have parameters)
  - command7,8,9 packed into one 32bit value (upper 8bit zero)
  - parameter(s) for command7 (if any)
  - parameter(s) for command8 (if any)
  - parameter(s) for command9 (top-most packed command MUST have parameters)
</TD></TR></TABLE>
Packed commands are first decompressed and then stored in command the FIFO.<BR>
<BR>
<B>GXFIFO DMA Overkill on Packed Commands Without Parameters</B><BR>
Normally, the 112 word limit ensures that the FIFO (256 entries) doesn't get
full, however, this limit is much too high for sending a lot of "Packed
Commands Without Parameters" (ie. PUSH, IDENTITY, or END) - eg. sending 112 x
Packed(00151515h) to GXFIFO would write 336 x Cmd(15h) to the FIFO, which is
causing the FIFO to get full, and which is causing the DMA (and CPU) to be
paused (for several seconds, in WORST case) until enough FIFO commands have
been processed to allow the DMA to finish the 112 word transfer.<BR>
Not sure if there's much chance to get Overkills in practice. Normally most
commands DO have parameters, and so, usually even LESS than 112 FIFO entries
are occupied (since 8bit commands with 32bit parameters are merged into single
40bit FIFO entries).<BR>
<BR>
<B>Invalid GX commands</B><BR>
Invalid commands (anything else than 10h..1Ch, 20h..2Bh, 30h..33h, 40h..41h,
50h, 60h, or 70h..72h) seem to be simply ignored by the hardware (at least,
testing has confirmed that they do not fetch any parameters from the gxfifo).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="ds3dmatrixloadmultiply"></A>
  DS 3D Matrix Load/Multiply
</FONT></TD></TR></TABLE><BR>
<B>4000440h - Cmd 10h - MTX_MODE - Set Matrix Mode (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-1   Matrix Mode (0..3)
         0  Projection Matrix
         1  Position Matrix (aka Modelview Matrix)
         2  Position &amp; Vector Simultaneous Set mode (used for Light+VEC_TEST)
         3  Texture Matrix (see DS 3D Texture Coordinates chapter)
  2-31  Not used
</TD></TR></TABLE>
Selects the current Matrix, all following MTX commands (load, multiply, push,
pop, etc.) are applied to that matrix. In Mode 2, all MTX commands are applied
to both the Position and Vector matrices. There are two special cases:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  MTX_SCALE in Mode 2:                  uses ONLY Position Matrix
  MTX_PUSH/POP/STORE/RESTORE in Mode 1: uses BOTH Position AND Vector Matrices
</TD></TR></TABLE>
Ie. the four stack commands act like mode 2 (even when in mode 1; keeping the
two stacks somewhat in sync), and scale acts like mode 1 (even when in mode 2;
keeping the light vector length's intact).<BR>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 vice-versa for the scale command.
</TD></TR></TABLE>
For the above cases, the commands do always act like mode 1, even when they are
i<BR>
<BR>
<B>4000454h - Cmd 15h - MTX_IDENTITY - Load Unit Matrix to Current Matrix (W)</B><BR>
Sets C=I. Parameters: None<BR>
The Identity Matrix (I), aka Unit Matrix, consists of all zeroes, with a
diagonal row of ones. A matrix multiplied by the Unit Matrix is left unchanged.<BR>
<BR>
<B>4000458h - Cmd 16h - MTX_LOAD_4x4 - Load 4x4 Matrix to Current Matrix (W)</B><BR>
Sets C=M. Parameters: 16, m[0..15]<BR>
<BR>
<B>400045Ch - Cmd 17h - MTX_LOAD_4x3 - Load 4x3 Matrix to Current Matrix (W)</B><BR>
Sets C=M. Parameters: 12, m[0..11]<BR>
<BR>
<B>4000460h - Cmd 18h - MTX_MULT_4x4 - Multiply Current Matrix by 4x4 Matrix (W)</B><BR>
Sets C=M*C. Parameters: 16, m[0..15]<BR>
<BR>
<B>4000464h - Cmd 19h - MTX_MULT_4x3 - Multiply Current Matrix by 4x3 Matrix (W)</B><BR>
Sets C=M*C. Parameters: 12, m[0..11]<BR>
<BR>
<B>4000468h - Cmd 1Ah - MTX_MULT_3x3 - Multiply Current Matrix by 3x3 Matrix (W)</B><BR>
Sets C=M*C. Parameters: 9, m[0..8]<BR>
<BR>
<B>400046Ch - Cmd 1Bh - MTX_SCALE - Multiply Current Matrix by Scale Matrix (W)</B><BR>
Sets C=M*C. Parameters: 3, m[0..2]<BR>
Note: MTX_SCALE doesn't change Vector Matrix (even when in MTX_MODE=2) (that's
done so for keeping the length of the light vector's intact).<BR>
<BR>
<B>4000470h - Cmd 1Ch - MTX_TRANS - Mult. Curr. Matrix by Translation Matrix (W)</B><BR>
Sets C=M*C. Parameters: 3, m[0..2] (x,y,z position)<BR>
<BR>
<B>4000640h..67Fh - CLIPMTX_RESULT - Read Current Clip Coordinates Matrix (R)</B><BR>
This 64-byte region (16 words) contains the m[0..15] values of the Current Clip
Coordinates Matrix, arranged in 4x4 Matrix format. Make sure that the Geometry
Engine is stopped (GXSTAT.27) before reading from these registers.<BR>
The Clip Matrix is internally used to convert vertices to screen coordinates,
and is internally re-calculated anytime when changing the Position or
Projection matrices:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  ClipMatrix = PositionMatrix * ProjectionMatrix
</TD></TR></TABLE>
To read only the Position Matrix, or only the Projection Matrix: Use Load
Identity on the OTHER matrix, so the ClipMatrix becomes equal to the DESIRED
matrix (multiplied by the Identity Matrix, which has no effect on the result).<BR>
<BR>
<B>4000680h..6A3h - VECMTX_RESULT - Read Current Directional Vector Matrix (R)</B><BR>
This 36-byte region (9 words) contains the m[0..8] values of the Current
Directional Vector Matrix, arranged in 3x3 Matrix format (the fourth row/column
may contain any values).<BR>
Make sure that the Geometry Engine is stopped (GXSTAT.27) before reading from
these registers.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="ds3dmatrixtypes"></A>
  DS 3D Matrix Types
</FONT></TD></TR></TABLE><BR>
Essentially, all matrices in the NDS are 4x4 Matrices, consisting of 16 values,
m[0..15]. Each element is a signed fixed-point 32bit number, with a fractional
part in the lower 12bits.<BR>
The other Matrix Types are used to reduce the number of parameters being
transferred, for example, 3x3 Matrix requires only nine parameters, the other
seven elements are automatically set to 0 or 1.0 (whereas "1.0" means "1 SHL
12" in 12bit fixed-point notation).<BR>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
<B>   _      4x4 Matrix       _        _    Identity Matrix    _</B>
  | m[0]  m[1]  m[2]  m[3]  |      |  1.0   0     0     0    |
  | m[4]  m[5]  m[6]  m[7]  |      |  0     1.0   0     0    |
  | m[8]  m[9]  m[10] m[11] |      |  0     0     1.0   0    |
  |_m[12] m[13] m[14] m[15]_|      |_ 0     0     0     1.0 _|
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
<B>   _      4x3 Matrix       _        _  Translation Matrix   _</B>
  | m[0]  m[1]  m[2]   0    |      |  1.0   0     0     0    |
  | m[3]  m[4]  m[5]   0    |      |  0     1.0   0     0    |
  | m[6]  m[7]  m[8]   0    |      |  0     0     1.0   0    |
  |_m[9]  m[10] m[11]  1.0 _|      |_m[0]  m[1]  m[2]   1.0 _|
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
<B>   _      3x3 Matrix       _        _     Scale Matrix      _</B>
  | m[0]  m[1]  m[2]   0    |      | m[0]   0     0     0    |
  | m[3]  m[4]  m[5]   0    |      |  0    m[1]   0     0    |
  | m[6]  m[7]  m[8]   0    |      |  0     0    m[2]   0    |
  |_ 0     0     0     1.0 _|      |_ 0     0     0     1.0 _|
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="ds3dmatrixstack"></A>
  DS 3D Matrix Stack
</FONT></TD></TR></TABLE><BR>
<B>Matrix Stack</B><BR>
The NDS has three Matrix Stacks, and two Matrix Stack Pointers (the Coordinate
Matrix stack pointer is also shared for Directional Matrix Stack).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Matrix Stack________Valid Stack Area____Stack Pointer___________________
  Projection Stack    0..0  (1 entry)     0..1  (1bit) (GXSTAT: 1bit)
  Coordinate Stack    0..30 (31 entries)  0..63 (6bit) (GXSTAT: 5bit only)
  Directional Stack   0..30 (31 entries)  (uses Coordinate Stack Pointer)
  Texture Stack       One..None?          0..1  (1bit) (GXSTAT: N/A)
</TD></TR></TABLE>
Which of the stacks/matrices depends on the current Matrix Mode (as usually,<BR>
but with one exception; stack operations MTX_PUSH/POP/STORE/RESTORE in Mode 1
are acting same as in Mode 2):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  MTX_MODE = 0      --&gt; Projection Stack
  MTX_MODE = 1 or 2 --&gt; BOTH Coordinate AND Directional Stack
  MTX_MODE = 3      --&gt; Texture Stack
</TD></TR></TABLE>
The initial value of the Stack Pointers is zero, the current value of the
pointers can be read from GXSTAT (read-only), that register does also indicate
stack overflows (errors flag gets set on read/write to invalid entries, ie.
entries 1 or 1Fh..3Fh). For all stacks, the upper half (ie. 1 or 20h..3Fh) are
mirrors of the lower half (ie. 0 or 0..1Fh).<BR>
<BR>
<B>4000444h - Cmd 11h - MTX_PUSH - Push Current Matrix on Stack (W)</B><BR>
Parameters: None. Sets [S]=C, and then S=S+1.<BR>
<BR>
<B>4000448h - Cmd 12h - MTX_POP - Pop Current Matrix from Stack (W)</B><BR>
Sets S=S-N, and then C=[S].<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Parameter Bit0-5:  Stack Offset (signed value, -30..+31) (usually +1)
  Parameter Bit6-31: Not used
</TD></TR></TABLE>
Offset N=(+1) pops the most recently pushed value, larger offsets of N&gt;1
will "deallocate" N values (and load the Nth value into C). Zero or negative
values can be used to pop previously "deallocated" values.<BR>
The stack has only one level (at address 0) in projection mode, in that mode,
the parameter value is ignored, the offset is always +1 in that mode.<BR>
<BR>
<B>400044Ch - Cmd 13h - MTX_STORE - Store Current Matrix on Stack (W)</B><BR>
Sets [N]=C. The stack pointer S is not used, and is left unchanged.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Parameter Bit0-4:  Stack Address (0..30) (31 causes overflow in GXSTAT.15)
  Parameter Bit5-31: Not used
</TD></TR></TABLE>
The stack has only one level (at address 0) in projection mode, in that mode,
the parameter value is ignored.<BR>
<BR>
<B>4000450h - Cmd 14h - MTX_RESTORE - Restore Current Matrix from Stack (W)</B><BR>
Sets C=[N]. The stack pointer S is not used, and is left unchanged.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Parameter Bit0-4:  Stack Address (0..30) (31 causes overflow in GXSTAT.15)
  Parameter Bit5-31: Not used
</TD></TR></TABLE>
The stack has only one level (at address 0) in projection mode, in that mode,
the parameter value is ignored.<BR>
<BR>
In Projection mode, the parameter for POP, STORE, and RESTORE is unused - not
sure if the parameter (ie. a dummy value) is - or is not - to be written to the
command FIFO?<BR>
There appear to be actually 32 entries in Coordinate &amp; Directional Stacks,
entry 31 appears to exist, and appears to be read/write-able (although the
stack overflow flag gets set when accessing it).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="ds3dmatrixexamplesprojection"></A>
  DS 3D Matrix Examples (Projection)
</FONT></TD></TR></TABLE><BR>
The most important matrix is the Projection Matrix (to be initialized with
MTX_MODE=0 via MTX_LOAD_4x4 command). It does specify the dimensions of the
view volume.<BR>
<BR>
With Perspective Projections more distant objects will appear smaller, with
Orthogonal Projects the size of the objects is always same regardless of their
distance.<BR>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
<B>  Perspective Projection     Orthogonal Projection</B>
                   __                  __________
       top __..--''  |            top |          |
          |   view   |                |   view   |
  Eye ----|---------&gt;|        Eye ----|---------&gt;|
          |__volume  |                |  volume  |
     bottom  ''--..__|          bottom|__________|
        near        far             near        far
</TD></TR></TABLE>
<BR>
Correctly initializing the projection matrix (as shown in the examples below)
can be quite difficult (mind that fixed point multiply/divide requires to
adjust the fixed-point width before/after calculation). For beginners, it may
be recommended to start with a simple Identity Matrix (MTX_IDENTITY command)
used as Projection Matrix (ie. Ortho with t,b,l,r set to +/-1).<BR>
<BR>
<B>Orthogonal Projections (Ortho)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  | (2.0)/(r-l)       0             0            0     |
  |      0       (2.0)/(t-b)        0            0     |
  |      0            0        (2.0)/(n-f)       0     |
  | (l+r)/(l-r)  (b+t)/(b-t)   (n+f)/(n-f)      1.0    |
</TD></TR></TABLE>
n,f specify the distance from eye to near and far clip planes. t,b,l,r are the
coordinates of near clip plane (top,bottom,left,right). For a symmetrical view
(ie. the straight-ahead view line centered in the middle of viewport) t,b,l,r
should be usually t=+ysiz/2, b=-ysiz/2, r=+xsiz/2, l=-xsiz/2; the (xsiz/ysiz)
ratio should be usually equal to the viewport's (width/heigh) ratio. Examples
for a asymmetrical view would be b=0 (frog's view), or t=0 (bird's view).<BR>
<BR>
<B>Left-Right Asymmetrical Perspective Projections (Frustum)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  | (2*n)/(r-l)       0             0            0     |
  |      0       (2*n)/(t-b)        0            0     |
  | (r+l)/(r-l)  (t+b)/(t-b)   (n+f)/(n-f)     -1.0    |
  |      0            0       (2*n*f)/(n-f)      0     |
</TD></TR></TABLE>
n,f,t,b,l,r have same meanings as above (Ortho), the difference is that more
distant objects will appear smaller with Perspective Projection (unlike
Orthogonal Projection where the size isn't affected by the distance).<BR>
<BR>
<B>Left-Right Symmetrical Perspective Projections (Perspective)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  | cos/(asp*sin)     0             0            0     |
  |      0         cos/sin          0            0     |
  |      0            0        (n+f)/(n-f)     -1.0    |
  |      0            0       (2*n*f)/(n-f)      0     |
</TD></TR></TABLE>
Quite the same as above (Frustum), but with symmetrical t,b values (which are
in this case obtained from a vertical view range specified in degrees), and l,r
are matched to the aspect ratio of the viewport (asp=height/width).<BR>
<BR>
<B>Moving the Camera</B><BR>
After initializing the Projection Matrix, you may multiply it with Rotate
and/or Translation Matrices to change camera's position and view direction.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="ds3dmatrixexamplesrotatescaletranslate"></A>
  DS 3D Matrix Examples (Rotate/Scale/Translate)
</FONT></TD></TR></TABLE><BR>
<B>Identity Matrix</B><BR>
The MTX_IDENTITY command can be used to initialize the Position Matrix before
doing any Translation/Scaling/Rotation, for example:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Load(Identity)                           ;no rotation/scaling used
  Load(Identity), Mul(Rotate), Mul(Scale)  ;rotation/scaling (not so efficient)
  Load(Rotate), Mul(Scale)                 ;rotation/scaling (more efficient)
</TD></TR></TABLE>
<BR>
<B>Rotation Matrices</B><BR>
Rotation can be performed with MTX_MULT_3x3 command, simple examples are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Around X-Axis          Around Y-Axis          Around Z-Axis
  | 1.0  0     0   |     | cos   0    sin |     | cos   sin   0   |
  | 0    cos   sin |     | 0     1.0  0   |     | -sin  cos   0   |
  | 0    -sin  cos |     | -sin  0    cos |     | 0     0     1.0 |
</TD></TR></TABLE>
<BR>
<B>Scale Matrix</B><BR>
The MTX_SCALE command allows to adjust the size of the polygon. The x,y,z
parameters should be normally all having the same value, x=y=z (unless if you
want to change only the height of the object, for example). Identical results
can be obtained with MTX_MULT commands, however, when using lighting
(MTX_MODE=2), then scaling should be done ONLY with MTX_SCALE (which keeps the
length of the light's directional vector intact).<BR>
<BR>
<B>Translation Matrix</B><BR>
The MTX_TRANS command allows to move polygons to the desired position. The
polygon VTX commands are spanning only a small range of coordinates (near
zero-coordinate), so translation is required to move the polygons to other
locations in the world coordinates. Aside from that, translation is useful for
moved objects (at variable coordinates), and for re-using an object at various
locations (eg. you can create a forest by translating a tree to different
coordinates).<BR>
<BR>
<B>Matrix Multiply Order</B><BR>
The Matrix must be set up BEFORE sending the Vertices (which are then
automatically multiplied by the matrix). When using multiple matrices
multiplied with each other: Mind that, for matrix maths A*B is NOT the same as
B*A. For example, if you combine Rotate and Translate Matrices, the object will
be either rotated around it's own zero-coordinate, or around world-space
zero-coordinate, depending on the multiply order.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="ds3dmatrixexamplesmathsbasics"></A>
  DS 3D Matrix Examples (Maths Basics)
</FONT></TD></TR></TABLE><BR>
Below is a crash-course on matrix maths. Most of it is carried out
automatically by the hardware. So this chapter is relevant only if you are
interested in details about what happens inside of the 3D engine.<BR>
<BR>
<B>Matrix-by-Matrix Multiplication</B><BR>
Matrix multiplication, C = A * B, is possible only if the number of columns in
A is equal to the number of rows in B, so it works fine with the 4x4 matrices
which are used in the NDS. For the multiplication, assume matrix C to consist
of elements cyx, and respecitively, matrix A and B to consist of elements ayx
and byx. So that C = A * B looks like:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  | c11 c12 c13 c14 |     | a11 a12 a13 a14 |     | b11 b12 b13 b14 |
  | c21 c22 c23 c24 |  =  | a21 a22 a23 a24 |  *  | b21 b22 b23 b24 |
  | c31 c32 c33 c34 |     | a31 a32 a33 a34 |     | b31 b32 b33 b34 |
  | c41 c42 c43 c44 |     | a41 a42 a43 a44 |     | b41 b42 b43 b44 |
</TD></TR></TABLE>
Each element in C is calculated by multiplying the elements from one row in A
by the elements from the corresponding column in B, and then taking the sum of
the products, ie.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  cyx = ay1*b1x + ay2*b2x + ay3*b3x + ay4*b4x
</TD></TR></TABLE>
In total, that requires 64 multiplications (four multiplications for each of
the 16 cyx elements), and 48 additions (three per cyx element), the hardware
carries out that operation at a relative decent speed of 30..35 clock cycles,
possibly by performing several multiplications simultaneously with separate
multiply units.<BR>
Observe that for matrix multiplication, A*B is NOT the same as B*A.<BR>
<BR>
<B>Matrix-by-Vector &amp; Vector-by-Matrix Multiplication</B><BR>
Vectors are Matrices with only one row, or only one column. Multiplication
works as for normal matrices; the number of rows/columns must match up,
repectively, row-vectors can be multiplied by matrices; and matrices can be
multiplied by column-vectors (but not vice-versa). Eg. C = A * B:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
                                                  | b11 b12 b13 b14 |
  | c11 c12 c13 c14 |  =  | a11 a12 a13 a14 |  *  | b21 b22 b23 b24 |
                                                  | b31 b32 b33 b34 |
                                                  | b41 b42 b43 b44 |
</TD></TR></TABLE>
The formula for calculating the separate elements is same as above,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  cyx = ay1*b1x + ay2*b2x + ay3*b3x + ay4*b4x
</TD></TR></TABLE>
Of which, C and A have only one y-index, so one may replace "cyx and ayx" by
"c1x and a1x", or completely leave out the y-index, ie. "cx and ax".<BR>
<BR>
<B>Matrix-by-Number Multiplication</B><BR>
Simply multiply all elements of the Matrix by the number, C = A * n:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  cyx = ayx*n
</TD></TR></TABLE>
Of course, works also with vectors (matrices with only one row/column).<BR>
<BR>
<B>Matrix-to-Matrix Addition/Subtraction</B><BR>
Both matrices must have the same number of rows &amp; columns, add/subtract all
elements with corresponding elements in other matrix, C = A +/- B:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  cyx = ayx +/- byx
</TD></TR></TABLE>
Of course, works also with vectors (two matrices with only one row/column).<BR>
<BR>
<B>Vectors</B><BR>
A vector, for example (x,y,z), consists of offsets along x-,y-, and z-axis. The
line from origin to origin-plus-offset is having two characteristics: A
direction, and a length.<BR>
The length (aka magnitude) can be calculated as L=sqrt(x^2+y^2+z^2).<BR>
<BR>
<B>Vector-by-Vector Multiplication</B><BR>
This can be processed as LineVector*RowVector, so the result is a number (aka
scalar) (aka a matrix with only 1x1 elements). Multiplying two (normalized)
vectors results in: "cos(angle)=vec1*vec2", ie. the cosine of the angle between
the two vectors (eg. used for light vectors). Multiplying a vector with itself,
and taking the square root of the result obtains its length, ie.
"length=sqrt(vec^2)".<BR>
That stuff should be done with 3-dimensional vectors (not 4-dimensionals).<BR>
<BR>
<B>Normalized Vectors</B><BR>
Normalized Vectors (aka Unit Vectors) are vectors with length=1.0. To normalize
a vector, divide its coordinates by its length, ie. x=x/L, y=y/L, z=z/L, the
direction remains the same, but the length is now 1.0.<BR>
On the NDS, normalized vectors should have a length of something less than 1.0
(eg. something like 0.99) because several NDS registers are limited to 1bit
sign, 0bit integer, Nbit fractional part (so vectors that are parallel to the
x,y,z axes, or that become parallel to them after rotation, cannot have a
length of 1.0).<BR>
<BR>
<B>Fixed-Point Numbers</B><BR>
The NDS uses fixed-point numbers (rather than floating point numbers). Addition
and Subtraction works as with normal integers, provided that the fractional
part is the same for both numbers. If it is not the same: Shift-left the value
with the smaller fractional part.<BR>
For multiplication, the fractional part of result is the sum of the fractional
parts (eg. 12bit fraction * 12bit fraction = 24bit fraction; shift-right the
result by 12 to convert it 12bit fraction). The NDS matrix multiply unit is
maintaining the full 24bit fraction when processing the<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  cyx = ay1*b1x + ay2*b2x + ay3*b3x + ay4*b4x
</TD></TR></TABLE>
formula, ie. the three additions are using full 24bit fractions (with
carry-outs to upper bits), the final result of the additions is then
shifted-right by 12.<BR>
For division, it's vice versa, the fractions of the operands are substracted,
24bit fraction / 12bit fraction = 12bit fraction. When dividing two 12bit
numbers, shift-left the first number by 12 before division to get a result with
12bit fractional part.<BR>
<BR>
<B>Four-Dimensional Matrices</B><BR>
The NDS uses four-dimensional matrices and vectors, ie. matrices with 4x4
elements, and vectors with 4 elements. The first three elements are associated
with the X,Y,Z-axes of the three-dimensional space. The fourth element is
somewhat a "W-axis".<BR>
With 4-dimensional matrices, the Translate matrix can be used to move an object
to another position. Ie. once when you've setup a matrix (which may consists of
pre-multiplied scaling, rotation, translation matrices), then that matrix can
be used on vertices to perform the rotation, scaling, translation all-at-once;
by a single Vector*Matrix operation.<BR>
With 3-dimensional matrices, translation would require a separate addition,
additionally to the multiply operation.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="ds3dpolygonattributes"></A>
  DS 3D Polygon Attributes
</FONT></TD></TR></TABLE><BR>
<B>40004A4h - Cmd 29h - POLYGON_ATTR - Set Polygon Attributes (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-3   Light 0..3 Enable Flags (each bit: 0=Disable, 1=Enable)
  4-5   Polygon Mode  (0=Modulation,1=Decal,2=Toon/Highlight Shading,3=Shadow)
  6     Polygon Back Surface   (0=Hide, 1=Render)  ;Line-segments are always
  7     Polygon Front Surface  (0=Hide, 1=Render)  ;rendered (no front/back)
  8-10  Not used
  11    Depth-value for Translucent Pixels    (0=Keep Old, 1=Set New Depth)
  12    Far-plane intersecting polygons       (0=Hide, 1=Render/clipped)
  13    1-Dot polygons behind DISP_1DOT_DEPTH (0=Hide, 1=Render)
  14    Depth Test, Draw Pixels with Depth    (0=Less, 1=Equal) (usually 0)
  15    Fog Enable                            (0=Disable, 1=Enable)
  16-20 Alpha      (0=Wire-Frame, 1..30=Translucent, 31=Solid)
  21-23 Not used
  24-29 Polygon ID (00h..3Fh, used for translucent, shadow, and edge-marking)
  30-31 Not used
</TD></TR></TABLE>
Writes to POLYGON_ATTR have no effect until next BEGIN_VTXS command.<BR>
Changes to the Light bits have no effect until lighting is re-calculated by
Normal command. The interior of Wire-frame polygons is transparent (Alpha=0),
and only the lines at the polygon edges are rendered, using a fixed Alpha value
of 31.<BR>
<BR>
<B>4000480h - Cmd 20h - COLOR - Directly Set Vertex Color (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Parameter 1, Bit 0-4    Red
  Parameter 1, Bit 5-9    Green
  Parameter 1, Bit 10-14  Blue
  Parameter 1, Bit 15-31  Not used
</TD></TR></TABLE>
The 5bit RGB values are internally expanded to 6bit RGB as follows:
X=X*2+(X+31)/32, ie. zero remains zero, all other values are X=X*2+1.<BR>
Aside from by using the Color command, the color can be also changed by
MaterialColor0 command (if MaterialColor0.Bit15 is set, it acts identical as
the Color Command), and by the Normal command (which calculates the color based
on light/material parameters).<BR>
<BR>
<B>Depth Test</B><BR>
The Depth Test compares the depth of the pixels of the polygon with the depth
of previously rendered polygons (or of the rear plane if there have been none
rendered yet). The new pixels are drawn if the new depth is Less (closer to the
camera), or if it is Equal, as selected by POLYGON_ATTR.Bit14.<BR>
Normally, Depth Equal would work only exact matches (ie. if the overlapping
polygons have exactly the same coordinates; and thus have the same rounding
errors), however, the NDS hardware is allowing "Equal" to have a tolerance of
+/-200h (within the 24bit depth range of 0..FFFFFFh), that may bypass rounding
errors, but it may also cause nearby polygons to be accidently treated to have
equal depth.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="ds3dpolygondefinitionsbyvertices"></A>
  DS 3D Polygon Definitions by Vertices
</FONT></TD></TR></TABLE><BR>
The DS supports polygons with 3 or 4 edges, triangles and quadliterals.<BR>
The position of the edges is defined by vertices, each consisting of (x,y,z)
values.<BR>
<BR>
For Line Segments, use Triangles with twice the same vertex, Line Segments are
rendered always because they do not have any front and back sides.<BR>
The Prohibited Quad shapes may produce unintended results, namely, that are
Quads with crossed sides, and quads with angles greater than 180 degrees.<BR>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Separate Tri.     Triangle Strips   Line Segment
  v0                 v2___v4____v6
  |\      v3         /|\  |\    /\     v0    v1
  | \     /\      v0( | \ | \  /  \     ------
  |__\   /__\        \|__\|__\/____\         v2
  v1 v2 v4  v5       v1   v3  v5   v7
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Separate Quads          Quadliteral Strips         Prohibited Quads
    v0__v3                 v0__v2____v4     v10__    v0__v3     v4
     /  \   v4____v7        /  \     |\ _____ / /v11   \/       |\
    /    \   |    \        /    \    | |v6 v8| /       /\     v5| \
   /______\  |_____\      /______\___|_|_____|/       /__\     /___\
   v1    v2  v5    v6     v1    v3  v5 v7   v9       v2   v1   v6   v7
</TD></TR></TABLE>
<BR>
The vertices are normally arranged anti-clockwise, except that: in
triangle-strips each second polygon uses clockwise arranged vertices, and
quad-strips are sorts of "up-down" arranged (whereas "up" and "down" may be
anywhere due to rotation). Other arrangements may result in quads with crossed
lines, or may swap the front and back sides of the polygon (above examples are
showing the front sides).<BR>
<BR>
<B>4000500h - Cmd 40h - BEGIN_VTXS - Start of Vertex List (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Parameter 1, Bit 0-1    Primitive Type (0..3, see below)
  Parameter 1, Bit 2-31   Not used
</TD></TR></TABLE>
Indicates the Start of a Vertex List, and its Primitive Type:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0  Separate Triangle(s)    ;3*N vertices per N triangles
  1  Separate Quadliteral(s) ;4*N vertices per N quads
  2  Triangle Strips         ;3+(N-1) vertices per N triangles
  3  Quadliteral Strips      ;4+(N-1)*2 vertices per N quads
</TD></TR></TABLE>
The BEGIN_VTX command should be followed by VTX_-commands to define the
Vertices of the list, and should be then terminated by END_VTX command.<BR>
BEGIN_VTX additionally applies changes to POLYGON_ATTR.<BR>
<BR>
<B>4000504h - Cmd 41h - END_VTXS - End of Vertex List (W)</B><BR>
Parameters: None. This is a Dummy command for OpenGL compatibility. It should
be used to terminate a BEGIN_VTX, VTX_&lt;values&gt; sequence. END_VTXS is
possibly required for Nintendo's software emulator? On real NDS consoles (and
in no$gba) it does have no effect, it can be left out, or can be issued
multiple times inside of a vertex list, without disturbing the display.<BR>
<BR>
<B>400048Ch - Cmd 23h - VTX_16 - Set Vertex XYZ Coordinates (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Parameter 1, Bit 0-15   X-Coordinate (signed, with 12bit fractional part)
  Parameter 1, Bit 16-31  Y-Coordinate (signed, with 12bit fractional part)
  Parameter 2, Bit 0-15   Z-Coordinate (signed, with 12bit fractional part)
  Parameter 2, Bit 16-31  Not used
</TD></TR></TABLE>
<BR>
<B>4000490h - Cmd 24h - VTX_10 - Set Vertex XYZ Coordinates (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Parameter 1, Bit 0-9    X-Coordinate (signed, with 6bit fractional part)
  Parameter 1, Bit 10-19  Y-Coordinate (signed, with 6bit fractional part)
  Parameter 1, Bit 20-29  Z-Coordinate (signed, with 6bit fractional part)
  Parameter 1, Bit 30-31  Not used
</TD></TR></TABLE>
Same as VTX_16, with only one parameter, with smaller fractional part.<BR>
<BR>
<B>4000494h - Cmd 25h - VTX_XY - Set Vertex XY Coordinates (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Parameter 1, Bit 0-15   X-Coordinate (signed, with 12bit fractional part)
  Parameter 1, Bit 16-31  Y-Coordinate (signed, with 12bit fractional part)
</TD></TR></TABLE>
The Z-Coordinate is kept unchanged, and re-uses the value from previous VTX.<BR>
<BR>
<B>4000498h - Cmd 26h - VTX_XZ - Set Vertex XZ Coordinates (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Parameter 1, Bit 0-15   X-Coordinate (signed, with 12bit fractional part)
  Parameter 1, Bit 16-31  Z-Coordinate (signed, with 12bit fractional part)
</TD></TR></TABLE>
The Y-Coordinate is kept unchanged, and re-uses the value from previous VTX.<BR>
<BR>
<B>400049Ch - Cmd 27h - VTX_YZ - Set Vertex YZ Coordinates (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Parameter 1, Bit 0-15   Y-Coordinate (signed, with 12bit fractional part)
  Parameter 1, Bit 16-31  Z-Coordinate (signed, with 12bit fractional part)
</TD></TR></TABLE>
The X-Coordinate is kept unchanged, and re-uses the value from previous VTX.<BR>
<BR>
<B>40004A0h - Cmd 28h - VTX_DIFF - Set Relative Vertex Coordinates (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Parameter 1, Bit 0-9    X-Difference (signed, with 9/12bit fractional part)
  Parameter 1, Bit 10-19  Y-Difference (signed, with 9/12bit fractional part)
  Parameter 1, Bit 20-29  Z-Difference (signed, with 9/12bit fractional part)
  Parameter 1, Bit 30-31  Not used
</TD></TR></TABLE>
Sets XYZ-Coordinate relative to the XYZ-Coordinates from previous VTX. In
detail: The 9bit fractional values are divided by 8 (sign expanded to 12bit
fractions, in range +/-0.125), and that 12bit fraction is then added to the old
vtx coordinates. The result of the addition should not overflow 16bit vertex
coordinate range (1bit sign, 3bit integer, 12bit fraction).<BR>
<BR>
<B>Notes on VTX commands</B><BR>
On each VTX command, the viewport coordinates of the vertex are calculated and
stored in Vertex RAM,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  ( xx, yy, zz, ww ) = ( x, y, z, 1.0 ) * ClipMatrix
</TD></TR></TABLE>
The actual screen position (in pixels) is then,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  screen_x = (xx+ww)*viewport_width / (2*ww) + viewport_x1
  screen_y = (yy+ww)*viewport_height / (2*ww) + viewport_y1
</TD></TR></TABLE>
Each VTX command that completes the definition of a polygon (ie. each 3rd for
Separate Trangles) does additionally store data in Polygon List RAM.<BR>
VTX commands may be issued only between Begin and End commands.<BR>
<BR>
<B>Clipping</B><BR>
Polygons are clipped to the 6 sides of the view volume (ie. to the left, right,
top, bottom, near, and far edges). If one or more vertic(es) exceed one of
these sides, then these vertic(es) are replaced by two newly created vertices
(which are located on the intersections of the polygon edges and the view
volume edge).<BR>
Depending on the number of clipped vertic(es), this may increase or decrease
the number of entries in Vertex RAM (ie. minus N clipped vertices, plus 2 new
vertices). Also, clipped polygons which are part of polygon strips are
converted to separate polygons (which does increase number of entries in Vertex
RAM). Polygons that are fully outside of the View Volume aren't stored in
Vertex RAM, nor in Polygon RAM (the only exception are polygons that are
located exactly one pixel below of, or right of lower/right edges, which appear
to be accidently stored in memory).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="ds3dpolygonlightparameters"></A>
  DS 3D Polygon Light Parameters
</FONT></TD></TR></TABLE><BR>
The lighting operation is performed by executing the Normal command (which sets
the VertexColor based on the Light/Material parameters) (to the rest of the
hardware it doesn't matter if the VertexColor was set by Color command or by
Normal command). Light is calculated only for the Front side of the polygon
(assuming that the Normal is matched to that side), so the Back side will be
(incorrectly) using the same color.<BR>
<BR>
<B>40004C8h - Cmd 32h - LIGHT_VECTOR - Set Light's Directional Vector (W)</B><BR>
Sets direction of the specified light (ie. the light selected in Bit30-31).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-9   Directional Vector's X component (1bit sign + 9bit fractional part)
  10-19 Directional Vector's Y component (1bit sign + 9bit fractional part)
  20-29 Directional Vector's Z component (1bit sign + 9bit fractional part)
  30-31 Light Number                     (0..3)
</TD></TR></TABLE>
Upon executing this command, the incoming vector is multiplied by the current
Directional Matrix, the result is then applied as LightVector. This allows to
rotate the light direction. However, normally, to keep the light unrotated, be
sure to use LoadIdentity (in MtxMode=2) before setting the LightVector.<BR>
<BR>
<B>40004CCh - Cmd 33h - LIGHT_COLOR - Set Light Color (W)</B><BR>
Sets the color of the specified light (ie. the light selected in Bit30-31).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-4   Red          (0..1Fh)      ;\light color this will be combined with
  5-9   Green        (0..1Fh)      ; diffuse, specular, and ambient colors
  10-14 Blue         (0..1Fh)      ;/upon execution of the normal command
  15-29 Not used
  30-31 Light Number (0..3)
</TD></TR></TABLE>
<BR>
<B>40004C0h - Cmd 30h - DIF_AMB - MaterialColor0 - Diffuse/Ambient Reflect. (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-4   Diffuse Reflection Red     ;\light(s) that directly hits the polygon,
  5-9   Diffuse Reflection Green   ; ie. max when NormalVector has opposite
  10-14 Diffuse Reflection Blue    ;/direction of LightVector
  15    Set Vertex Color (0=No, 1=Set Diffuse Reflection Color as Vertex Color)
  16-20 Ambient Reflection Red     ;\light(s) that indirectly hits the polygon,
  21-25 Ambient Reflection Green   ; ie. assuming that light is reflected by
  26-30 Ambient Reflection Blue    ;/walls/floor, regardless of LightVector
  31    Not used
</TD></TR></TABLE>
With Bit15 set, the lower 15bits are applied as VertexColor (exactly as when
when executing the Color command), the purpose is to use it as default color
(eg. when outcommenting the Normal command), normally, when using lighting, the
color setting gets overwritten (as soon as executing the Normal command).<BR>
<BR>
<B>40004C4h - Cmd 31h - SPE_EMI - MaterialColor1 - Specular Ref. &amp; Emission (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-4   Specular Reflection Red    ;\light(s) reflected towards the camera,
  5-9   Specular Reflection Green  ; ie. max when NormalVector is in middle of
  10-14 Specular Reflection Blue   ;/LightVector and ViewDirection
  15    Specular Reflection Shininess Table (0=Disable, 1=Enable)
  16-20 Emission Red               ;\light emitted by the polygon itself,
  21-25 Emission Green             ; ie. regardless of light colors/vectors,
  26-30 Emission Blue              ;/and no matter if any lights are enabled
  31    Not used
</TD></TR></TABLE>
Caution: Specular Reflection WON'T WORK when the ProjectionMatrix is rotated.<BR>
<BR>
<B>40004D0h - Cmd 34h - SHININESS - Specular Reflection Shininess Table (W)</B><BR>
Write 32 parameter words (each 32bit word containing four 8bit entries),
entries 0..3 in the first word, through entries 124..127 in the last word:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-7   Shininess 0 (unsigned fixed-point, 0bit integer, 8bit fractional part)
  8-15  Shininess 1 ("")
  16-23 Shininess 2 ("")
  24-31 Shininess 3 ("")
</TD></TR></TABLE>
If the table is disabled (by MaterialColor1.Bit15), then reflection will act as
if the table would be filled with linear increasing numbers.<BR>
<BR>
<B>4000484h - Cmd 21h - NORMAL - Set Normal Vector (W)</B><BR>
In short, this command does calculate the VertexColor, based on the various
light-parameters.<BR>
In detail, upon executing this command, the incoming vector is multiplied by
the current Directional Matrix, the result is then applied as NormalVector
(giving it the same rotation as used for the following polygon vertices).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-9   X-Component of Normal Vector (1bit sign + 9bit fractional part)
  10-19 Y-Component of Normal Vector (1bit sign + 9bit fractional part)
  20-29 Z-Component of Normal Vector (1bit sign + 9bit fractional part)
  30-31 Not used
</TD></TR></TABLE>
Defines the Polygon's Normal. And, does then update the Vertex Color; by
recursing the View Direction, the NormalVector, the LightVector(s), and
Light/Material Colors. The execution time of the Normal command varies
depending on the number of enabled light(s).<BR>
<BR>
<B>Additional Light Registers</B><BR>
Additionally to above registers, light(s) must be enabled in PolygonAttr (mind
that changes to PolygonAttr aren't applied until next Begin command). And, the
Directional Matrix must be set up correctly (in MtxMode=2) for the LightVector
and NormalVector commands.<BR>
<BR>
<B>Normal Vector</B><BR>
The Normal vector must point "away from the polygon surface" (eg. for the
floor, the Normal should point upwards). That direction is implied by the
polygon vertices, however, the hardware cannot automatically calculate it, so
it must be set manually with the Normal command (prior to the VTX-commands).<BR>
When using lighting, the Normal command must be re-executed after switching
Lighting on/off, or after changing light/material parameters. And, of course,
also before defining polygons with different orientation. Polygons with same
orientation (eg. horizontal polygon surfaces) and same material color can use
the same Normal. Changing the Normal per polygon gives differently colored
polygons with flat surfaces, changing the Normal per vertex gives the illusion
of curved surfaces.<BR>
<BR>
<B>Light Vector</B><BR>
Each light consists of parallel beams; similar to sunlight, which appears to us
(due to the great distance) to consist of parallel beams, all emmitted into the
same direction; towards Earth.<BR>
In reality, light is emitted into ALL directions, originated from the light
source (eg. a candle), the hardware doesn't support that type of non-parallel
light. However, the light vectors can be changed per polygon, so a polygon that
is located north of the light source may use different light direction than a
polygon that is east of the light source.<BR>
And, of course, Light 0..3 may (and should) have different directions.<BR>
<BR>
<B>Normalized Vectors</B><BR>
The Normal Vector and the Light Vectors should be normalized (ie. their length
should be 1.0) (in practice: something like 0.99, since the registers have only
fractional parts) (a length of 1.0 can cause overflows).<BR>
<BR>
<B>Lighting Limitations</B><BR>
The functionality of the light feature is limited to reflecting light to the
camera (light is not reflected to other polygons, nor does it cast shadows on
other polygons). However, independently of the lighting feature, the DS
hardware does allow to create shadows, see:<BR>
<A HREF="#ds3dshadowpolygons">DS 3D Shadow Polygons</A><BR>
<BR>
<B>Internal Operation on Normal Command</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  IF TexCoordTransformMode=2 THEN TexCoord=NormalVector*Matrix (see TexCoord)
  NormalVector=NormalVector*DirectionalMatrix
  VertexColor = EmissionColor
  FOR i=0 to 3
   IF PolygonAttrLight[i]=enabled THEN
    DiffuseLevel = max(0,-(LightVector[i]*NormalVector))
    ShininessLevel = max(0,(-HalfVector[i])*(NormalVector))^2
    IF TableEnabled THEN ShininessLevel = ShininessTable[ShininessLevel]
    ;note: below processed separately for the R,G,B color components...
    VertexColor = VertexColor + SpecularColor*LightColor[i]*ShininessLevel
    VertexColor = VertexColor + DiffuseColor*LightColor[i]*DiffuseLevel
    VertexColor = VertexColor + AmbientColor*LightColor[i]
   ENDIF
  NEXT i
</TD></TR></TABLE>
<BR>
<B>Internal Operation on Light_Vector Command (for Light i)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  LightVector[i] = (LightVector*DirectionalMatrix)
  HalfVector[i] = (LightVector[i]+LineOfSightVector)/2
</TD></TR></TABLE>
<BR>
<B>LineOfSightVector (how it SHOULD work)</B><BR>
Ideally, the LineOfSightVector should point from the camera to the vertic(es),
however, the vertic(es) are still unknown at time of normal command, so it is
just pointing from the camera to the screen, ie.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  LineOfSightVector = (0,0,-1.0)
</TD></TR></TABLE>
Moreover, the LineOfSightVector should be multiplied by the Projection Matrix
(so the vector would get rotated accordingly when the camera gets rotated),
and, after multiplication by a scaled matrix, it'd be required to normalize the
resulting vector.<BR>
<BR>
<B>LineOfSightVector (how it DOES actually work)</B><BR>
However, the NDS cannot normalize vectors by hardware, and therefore, it does
completely leave out the LineOfSightVector*ProjectionMatrix multiplication. So,
the LineOfSightVector is always (0,0,-1.0), no matter of any camera rotation.
That means,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Specular Reflection WON'T WORK when the ProjectionMatrix is rotated (!)
</TD></TR></TABLE>
So, if you want to rotate the "camera" (in MTX_MODE=0), then you must instead
rotate the "world" in the opposite direction (in MTX_MODE=2).<BR>
That problem applies only to Specular Reflection, ie. only if Lighting is used,
and only if the Specular Material Color is nonzero.<BR>
<BR>
<B>Maths Notes</B><BR>
Note on Vector*Vector multiplication: Processed as LineVector*RowVector, so the
result is a number (aka scalar) (aka a matrix with only 1x1 elements),
multiplying two (normalized) vectors results in: "cos(angle)=vec1*vec2", ie.
the cosine of the angle between the two vectors.<BR>
The various Normal/Light/Half/Sight vectors are only 3-dimensional (x,y,z), ie.
only the upper-left 3x3 matrix elements are used on multiplications with the
4x4 DirectionalMatrix.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="ds3dshadowpolygons"></A>
  DS 3D Shadow Polygons
</FONT></TD></TR></TABLE><BR>
The DS hardware's Light-function allows to reflect light to the camera, it does
not reflect light to other polygons, and it does not cast any shadows. For
shadows at fixed locations it'd be best to pre-calculate their shape and
position, and to change the vertex color of the shaded polygons.<BR>
Additionally, the Shadow Polygon feature can be used to create animated
shadows, ie. moved objects and variable light sources.<BR>
<BR>
<B>Shadow Polygons and Shadow Volume</B><BR>
The software must define a Shadow Volume (ie. the region which doesn't contain
light), the hardware does then automatically draw the shadow on all pixels
whose x/y/z-coordinates are inside of that region.<BR>
The Shadow Volume must be defined by several Shadow Polygons which are
enclosing the shaded region. The 'top' of the shadow volume should be usually
translated to the position of the object that casts the shadow, if the light
direction changes then the shadow volume should be also rotated to match the
light direction. The 'length' of the shadow volume should be (at least) long
enough to reach from the object to the walls/floor where the shadow is to be
drawn. The shadow volume must be passed TWICE to the hardware:<BR>
<BR>
<B>Step 1 - Shadow Volume for Mask</B><BR>
Set Polygon_Attr Mode=Shadow, PolygonID=00h, Back=Render, Front=Hide,
Alpha=01h..1Eh, and pass the shadow volume (ie. the shadow polygons) to the
geometry engine.<BR>
The Back=Render / Front=Hide setting causes the 'rear-side' of the shadow
volume to be rendered, of course only as far as it is in front of other
polygons. The Mode=Shadow / ID=00h setting causes the polygon NOT to be drawn
to the Color Buffer - instead, flags are set in the Stencil Buffer (to be used
in Step 2).<BR>
<BR>
<B>Step 2 - Shadow Volume for Rendering</B><BR>
Simply repeat step 1, but with Polygon_Attr Mode=Shadow, PolygonID=01h..3Fh,
Back=Render(what/why?), Front=Render, Alpha=01h..1Eh.<BR>
The Front=Render setting causes the 'front-side' of the shadow volume to be
rendered, again, only as far as it is in front of other polygons. The
Mode=Shadow / ID&gt;00h setting causes the polygon to be drawn to the Color
Buffer as usually, but only if the Stencil Buffer bits are zero (ie. the
portion from Step 1 is excluded) (additionally, Step 2 resets the stencil bits
after checking them). Moreover, the shadow is rendered only if its Polygon ID
differs from the ID in the Attribute Buffer.<BR>
<BR>
<B>Shadow Alpha and Shadow Color</B><BR>
The Alpha=Translucent setting in Step 1 and 2 ensures that the Shadow is drawn
AFTER the normal (opaque) polygons have been rendered. In Step 2 it does
additionally specify the 'intensity' of the shadow. For normal shadows, the
Vertex Color should be usually black, however, the shadow volume may be also
used as 'spotlight volume' when using other colors.<BR>
<BR>
<B>Rendering Order</B><BR>
The Mask Volume must be rendered prior to the Rendering Volume, ie. Step 1 and
2 must be performed in that order, and, to keep that order intact, Auto-sorting
must have been disabled in the previous Swap_Buffers command.<BR>
The shadow volume must be rendered after the 'target' polygons have been
rendered, for opaque targets this is done automatically (due to the translucent
alpha setting; translucent polygons are always rendered last, even with
auto-sort disabled).<BR>
<BR>
<B>Translucent Targets</B><BR>
Casting shadows on Translucent Polygons. First draw the translucent target
(with update depth buffer enabled, required for the shadow z-coordinates), then
draw the Shadow Mask/Rendering volumes.<BR>
Due to the updated depth buffer the shadow will be cast only on the translucent
target (not on any other polygons underneath of the translucent polygon). If
you want the shadow to appear on both: Draw draw the Shadow Mask/Rendering
volume TWICE (once before, and once after drawing the translucent target).<BR>
<BR>
<B>Polygon ID and Fog Enable</B><BR>
The "Render only if Polygon ID differs" feature (see Step 2) allows to prevent
the shadow to be cast on the object that casts the shadow (ie. the object and
shadow should have the same IDs). The feature also allows to select whether
overlapping shadows (with same/different IDs) are shaded once or twice.<BR>
The old Fog Enable flag in the Attribute Buffer is ANDed with the Fog Enable
flag of the Shadow Polygons, this allows to exclude Fog in shaded regions.<BR>
<BR>
<B>Shadow Volume Open/Closed Shapes</B><BR>
Normally, the shadow volume should have a closed shape, ie. should have
rear-sides (step 1), and corresponding front-sides (step 2) for all possible
viewing angles. That is required for the shadow to be drawn correctly, and also
for the Stencil Buffer to be reset to zero (in step 2, so that the stencil bits
won't disturb other shadow volumes).<BR>
Due to that, drawing errors may occur if the shadow volume's front or rear side
gets clipped by near/far clip plane.<BR>
One exception is that the volume doesn't need a bottom-side (with a suitable
volume length, the bottom may be left open, since it vanishes in the
floor/walls anyways).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="ds3dtextureattributes"></A>
  DS 3D Texture Attributes
</FONT></TD></TR></TABLE><BR>
<B>4000488h - Cmd 22h - TEXCOORD - Set Texture Coordinates (W)</B><BR>
Specifies the texture source coordinates within the texture bitmap which are to
be associated with the next vertex.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Parameter 1, Bit 0-15   S-Coordinate (X-Coordinate in Texture Source)
  Parameter 1, Bit 16-31  T-Coordinate (Y-Coordinate in Texture Source)
  Both values are 1bit sign + 11bit integer + 4bit fractional part.
  A value of 1.0 (=1 SHL 4) equals to one Texel.
</TD></TR></TABLE>
With Position 0.0 , 0.0 drawing starts from upperleft of the Texture.<BR>
With positive offsets, drawing origin starts more "within" the texture.<BR>
With negative offsets, drawing starts "before" the texture.<BR>
"When texture mapping, the Geometry Engine works faster if you issue commands
in the order TexCoord -&gt; Normal -&gt; Vertex."<BR>
<BR>
<B>40004A8h - Cmd 2Ah - TEXIMAGE_PARAM - Set Texture Parameters (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-15  Texture VRAM Offset div 8 (0..FFFFh -&gt; 512K RAM in Slot 0,1,2,3)
        (VRAM must be allocated as Texture data, see Memory Control chapter)
  16    Repeat in S Direction (0=Clamp Texture, 1=Repeat Texture)
  17    Repeat in T Direction (0=Clamp Texture, 1=Repeat Texture)
  18    Flip in S Direction   (0=No, 1=Flip each 2nd Texture) (requires Repeat)
  19    Flip in T Direction   (0=No, 1=Flip each 2nd Texture) (requires Repeat)
  20-22 Texture S-Size        (for N=0..7: Size=(8 SHL N); ie. 8..1024 texels)
  23-25 Texture T-Size        (for N=0..7: Size=(8 SHL N); ie. 8..1024 texels)
  26-28 Texture Format        (0..7, see below)
  29    Color 0 of 4/16/256-Color Palettes (0=Displayed, 1=Made Transparent)
  30-31 Texture Coordinates Transformation Mode (0..3, see below)
</TD></TR></TABLE>
Texture Formats:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0  No Texture
  1  A3I5 Translucent Texture
  2  4-Color Palette Texture
  3  16-Color Palette Texture
  4  256-Color Palette Texture
  5  4x4-Texel Compressed Texture
  6  A5I3 Translucent Texture
  7  Direct Texture
</TD></TR></TABLE>
Texture Coordinates Transformation Modes:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0  Do not Transform texture coordinates
  1  TexCoord source
  2  Normal source
  3  Vertex source
</TD></TR></TABLE>
The S-Direction equals to the horizontal direction of the source bitmap.<BR>
The T-Direction, T-repeat, and T-flip are the same in vertical direction.<BR>
For a "/" shaped texture, the S-clamp, S-repeat, and S-flip look like so:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Clamp _____  Repeat       Repeat+Flip
  _____/       ///////////  /\/\/\/\/\/
</TD></TR></TABLE>
With "Clamp", the texture coordinates are clipped to MinMax(0,Size-1), so the
texels at the edges of the texture bitmap are repeated (to avoid that effect,
fill the bitmap edges by texels with alpha=0, so they become invisible).<BR>
<BR>
<B>40004ACh - Cmd 2Bh - PLTT_BASE - Set Texture Palette Base Address (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-12   Palette Base Address (div8 or div10h, see below)
         (Not used for Texture Format 7: Direct Color Texture)
         (0..FFF8h/8 for Texture Format 2: ie. 4-color-palette Texture)
         (0..17FF0h/10h for all other Texture formats)
  13-31  Not used
</TD></TR></TABLE>
The palette data occupies 16bit per color, Bit0-4: Red, Bit5-9: Green,
Bit10-14: Blue, Bit15: Not used.<BR>
(VRAM must be allocated as Texture Palette, there can be up to 6 Slots
allocated, ie. the addressable 18000h bytes, see Memory Control chapter)<BR>
<BR>
<B>TexImageParam and TexPlttBase</B><BR>
Can be issued per polygon (except within polygon strips).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="ds3dtextureformats"></A>
  DS 3D Texture Formats
</FONT></TD></TR></TABLE><BR>
<B>Format 2: 4-Color Palette Texture</B><BR>
Each Texel occupies 2bit, the first Texel is located in LSBs of 1st byte.<BR>
In this format, the Palette Base is specified in 8-byte steps; all other
formats use 16-byte steps (see PLTT_BASE register).<BR>
<BR>
<B>Format 3: 16-Color Palette Texture</B><BR>
Each Texel occupies 4bit, the 1st Texel is located in LSBs of 1st byte.<BR>
<BR>
<B>Format 4: 256-Color Palette Texture</B><BR>
Each Texel occupies 8bit, the 1st Texel is located in 1st byte.<BR>
<BR>
<B>Format 7: Direct Color Texture</B><BR>
Each Texel occupies 16bit, the 1st Texel is located in 1st halfword.<BR>
Bit0-4: Red, Bit5-9: Green, Bit10-14: Blue, Bit15: Alpha<BR>
<BR>
<B>Format 1: A3I5 Translucent Texture (3bit Alpha, 5bit Color Index)</B><BR>
Each Texel occupies 8bit, the 1st Texel is located in 1st byte.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0-4: Color Index (0..31) of a 32-color Palette
  Bit5-7: Alpha       (0..7; 0=Transparent, 7=Solid)
</TD></TR></TABLE>
The 3bit Alpha value (0..7) is internally expanded into a 5bit Alpha value
(0..31) as follows: Alpha=(Alpha*4)+(Alpha/2).<BR>
<BR>
<B>Format 6: A5I3 Translucent Texture (5bit Alpha, 3bit Color Index)</B><BR>
Each Texel occupies 8bit, the 1st Texel is located in 1st byte.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0-2: Color Index (0..7) of a 8-color Palette
  Bit3-7: Alpha       (0..31; 0=Transparent, 31=Solid)
</TD></TR></TABLE>
<BR>
<B>Format 5: 4x4-Texel Compressed Texture</B><BR>
Consists of 4x4 Texel blocks in Slot 0 or 2, 32bit per block, 2bit per Texel,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0-7   Upper 4-Texel row (LSB=first/left-most Texel)
  Bit8-15  Next  4-Texel row ("")
  Bit16-23 Next  4-Texel row ("")
  Bit24-31 Lower 4-Texel row ("")
</TD></TR></TABLE>
Additional Palette Index Data for each 4x4 Texel Block is located in Slot 1,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0-13  Palette Offset in 4-byte steps; Addr=(PLTT_BASE*10h)+(Offset*4)
  Bit14-15 Transparent/Interpolation Mode (0..3, see below)
</TD></TR></TABLE>
whereas, the Slot 1 offset is related to above Slot 0 or 2 offset,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  slot1_addr = slot0_addr / 2           ;lower 64K of Slot1 assoc to Slot0
  slot1_addr = slot2_addr / 2 + 10000h  ;upper 64K of Slot1 assoc to Slot2
</TD></TR></TABLE>
The 2bit Texel values (0..3) are intepreted depending on the Mode (0..3),<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Texel  Mode 0       Mode 1             Mode 2         Mode 3
  0      Color 0      Color0             Color 0        Color 0
  1      Color 1      Color1             Color 1        Color 1
  2      Color 2      (Color0+Color1)/2  Color 2        (Color0*5+Color1*3)/8
  3      Transparent  Transparent        Color 3        (Color0*3+Color1*5)/8
</TD></TR></TABLE>
Mode 1 and 3 are using only 2 Palette Colors (which requires only half as much
Palette memory), the 3rd (and 4th) Texel Colors are automatically set to above
values (eg. to gray-shades if color 0 and 1 are black and white).<BR>
Note: The maximum size for 4x4-Texel Compressed Textures is 1024x512 or
512x1024 (which are both occupying the whole 128K in slot 0 or 2, plus 64K in
slot1), a larger size of 1024x1024 cannot be used because of the gap between
slot 0 and 2.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="ds3dtexturecoordinates"></A>
  DS 3D Texture Coordinates
</FONT></TD></TR></TABLE><BR>
For textured polygons, a texture coordinate must be associated with each vertex
of the polygon. The coordinates (S,T) are defined by TEXCOORD command
(typically issued prior to each VTX command), and can be optionally
automatically transformed, by the Transformation Mode selected in
TEXIMAGE_PARAM register.<BR>
<BR>
<B>Texture Matrix</B><BR>
Although the texture matrix is 4x4, with values m[0..15], only the left two
columns of this matrix are actually used. In Mode 2 and 3, the bottom row of
the matrix is replaced by S and T values from most recent TEXCOORD command.<BR>
<BR>
<B>Texture Coordinates Transformation Mode 0 - No Transform</B><BR>
The values are set upon executing the TEXCOORD command,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  ( S' T' )  =  ( S  T )
</TD></TR></TABLE>
Simple coordinate association, without using the Texture Matrix at all.<BR>
<BR>
<B>Texture Coordinates Transformation Mode 1 - TexCoord source</B><BR>
The values are calculated upon executing the TEXCOORD command,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
                                     | m[0]  m[1]  |
  ( S' T' )  =  ( S  T 1/16 1/16 ) * | m[4]  m[5]  |
                                     | m[8]  m[9]  |
                                     | m[12] m[13] |
</TD></TR></TABLE>
Can be used to produce a simple texture scrolling, rotation, or scaling, by
setting a translate, rotate, or scale matrix for the texture matrix.<BR>
<BR>
<B>Texture Coordinates Transformation Mode 2 - Normal source</B><BR>
The values are calculated upon executing the NORMAL command,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
                                     | m[0]  m[1]  |
  ( S' T' )  =  ( Nx  Ny  Nz 1.0 ) * | m[4]  m[5]  |
                                     | m[8]  m[9]  |
                                     | S     T     |
</TD></TR></TABLE>
Can be used to produce spherical reflection mapping by setting the texture
matrix to the current directional vector matrix, multiplied by a scaling matrix
that expands the directional vector space from -1.0..+1.0 to one half of the
texture size. For that purpose, translate the origin of the texture coordinate
to the center of the spherical texture by using TexCoord command (spherical
texture means a bitmap that contains some circle-shaped image).<BR>
<BR>
<B>Texture Coordinates Transformation Mode 3 - Vertex source</B><BR>
The values are calculated upon executing any VTX commands,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
                                     | m[0]  m[1]  |
  ( S' T' )  =  ( Vx  Vy  Vz 1.0 ) * | m[4]  m[5]  |
                                     | m[8]  m[9]  |
                                     | S     T     |
</TD></TR></TABLE>
Can be used to produce texture scrolls dependent on the View coordinates by
copying the current position coordinate matrix into the texture matrix. For
example, the PositionMatrix can be obtained via CLIPMTX_RESULT (see there for
details), and that values can be then manually copied to the TextureMatrix.<BR>
<BR>
<B>Sign+Integer+Fractional Parts used in above Formulas</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Matrix    m[..]     1+19+12 (32bit)
  Vertex    Vx,Vy,Vz  1+3+12  (16bit)
  Normal    Nx,Ny,Nz  1+0+9   (10bit)
  Constant  1.0       0+1+0   (1bit)
  Constant  1/16      0+0+4   (4bit)
  TexCoord  S,T       1+11+4  (16bit)
  Result    S',T'     1+11+4  (16bit) &lt;-------- clipped to that size !
</TD></TR></TABLE>
Observe that the S',T' values are clipped to 16bit size. Ie. after the
Vector*Matrix calaction, the result is shifted right (to make it having a 4bit
fraction), and the value is then masked to 16bit size.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="ds3dtextureblending"></A>
  DS 3D Texture Blending
</FONT></TD></TR></TABLE><BR>
Polygon pixels consist of a Vertex Color, and of Texture Colors.<BR>
These colors can be blended as described below. Or, to use only either one:<BR>
To use only the Vertex Color: Select No Texture in TEXIMAGE_PARAM.<BR>
To use only the Texture Color: Select Modulation Mode and Alpha=31 in
POLYGON_ATTR, and set COLOR to 7FFFh (white), or to gray values (to decrease
brightness of the texture color).<BR>
<BR>
<B>Vertex Color (Rv,Gv,Bv,Av)</B><BR>
The Vertex Color (Rv,Gv,Bv) can be changed per Vertex (either by Color, Normal,
or Material0 command), pixels between vertices are shaded to medium values of
the surrounding vertices. The Vertex Alpha (Av), can be changed only per
polygon (by PolygonAttr command).<BR>
<BR>
<B>Texture Colors (Rt,Gt,Bt,At)</B><BR>
The Texture Colors (Rt,Gt,Bt), and Alpha value (At), are defined by the Texture
Bitmap. For formats without Alpha value, assume At=31 (solid), and for formats
with 1bit Alpha assume At=A*31.<BR>
<BR>
<B>Shading Table Colors (Rs,Gs,Bs)</B><BR>
In Toon/Highlight Shading Mode, the red component of the Vertex Color (Rv) is
mis-used as an index in the Shading Table, ie. Rv is used to read Shading
Colors (Rs,Gs,Bs) from the table; the green and blue components of the Vertex
Color (Gv,Bv) are unused in this mode. The Vertex Alpha (Av) is kept used.<BR>
Shading is used in Polygon Mode 2, whether it is Toon or Highlight Shading is
selected in DISP3DCNT; this is a per-frame selection, so only either one can be
used.<BR>
<BR>
<B>Texture Blending - Modulation Mode (Polygon Attr Mode 0)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  R = ((Rt+1)*(Rv+1)-1)/64
  G = ((Gt+1)*(Gv+1)-1)/64
  B = ((Bt+1)*(Bv+1)-1)/64
  A = ((At+1)*(Av+1)-1)/64
</TD></TR></TABLE>
The multiplication result is decreased intensity (unless both factors are 63).<BR>
<BR>
<B>Texture Blending - Decal Mode (Polygon Attr Mode 1)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  R = (Rt*At + Rv*(63-At))/64  ;except, when At=0: R=Rv, when At=31: R=Rt
  G = (Gt*At + Gv*(63-At))/64  ;except, when At=0: G=Gv, when At=31: G=Gt
  B = (Bt*At + Bv*(63-At))/64  ;except, when At=0: B=Bv, when At=31: B=Bt
  A = Av
</TD></TR></TABLE>
The At value is used (only) as ratio for Texture color vs Vertex Color.<BR>
<BR>
<B>Texture Blending - Toon Shading (Polygon Mode 2, DISP3DCNT=Toon)</B><BR>
The vertex color Red component (Rv) is used as an index in the toon table.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  R = ((Rt+1)*(Rs+1)-1)/64   ;Rs=ToonTableRed[Rv]
  G = ((Gt+1)*(Gs+1)-1)/64   ;Gs=ToonTableGreen[Rv]
  B = ((Bt+1)*(Bs+1)-1)/64   ;Bs=ToonTableBlue[Rv]
  A = ((At+1)*(Av+1)-1)/64
</TD></TR></TABLE>
This is same as Modulation Mode, but using Rs,Gs,Bs instead Rv,Gv,Bv.<BR>
<BR>
<B>Texture Blending - Highlight Shading (Polygon Mode 2, DISP3DCNT=Highlight)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  R = ((Rt+1)*(Rs+1)-1)/64+Rs ;truncated to MAX=63
  G = ((Gt+1)*(Gs+1)-1)/64+Gs ;truncated to MAX=63
  B = ((Bt+1)*(Bs+1)-1)/64+Bs ;truncated to MAX=63
  A = ((At+1)*(Av+1)-1)/64
</TD></TR></TABLE>
Same as Toon Shading, with additional addition offset, the addition may
increase the intensity, however, it may also change the hue of the color.<BR>
<BR>
Above formulas are for 6bit RGBA values, ie. 5bit values internally expanded to
6bit as such: IF X&gt;0 THEN X=X*2+1.<BR>
<BR>
<B>Uni-Colored Textures</B><BR>
Although textures are normally containing "pictures", in some cases it makes
sense to use "blank" textures that are filled with a single color:<BR>
Wire-frame polygons are always having Av=31, however, they can be made
transparent by using Translucent Textures (ie. A5I3 or A3I5 formats) with
At&lt;31.<BR>
In Toon/Highlight shading modes, the Vertex Color is mis-used as table index,
however, Toon/Highlight shading can be used on uni-colored textures, which is
more or less the same as using Toon/Highlight shading on uni-colored
Vertex-colors.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="ds3dtoonedgefogalphablendingantialiasing"></A>
  DS 3D Toon, Edge, Fog, Alpha-Blending, Anti-Aliasing
</FONT></TD></TR></TABLE><BR>
<B>4000380h..3BFh - TOON_TABLE - Toon Table (W)</B><BR>
This 64-byte region contains the 32 toon colors (16bit per color), used for
both Toon and Highlight Shading. In both modes, the Red (R) component of the
RGBA vertex color is mis-used as index to obtain the new RGB value from the
toon table, vertex Alpha (A) is kept used as is.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0-4: Red, Bit5-9: Green, Bit10-14: Blue, Bit15: Not Used
</TD></TR></TABLE>
Shading can be enabled (per polygon) in Polygon_Attr, whether it is Toon or
Highlight Shading is set (per frame) in DISP3DCNT. For more info on shading,
see:<BR>
<A HREF="#ds3dtextureblending">DS 3D Texture Blending</A><BR>
<BR>
<B>4000330h..33Fh - EDGE_COLOR - Edge Colors 0..7 (W)</B><BR>
This 16-byte region contains the 8 edge colors (16bit per color), Edge Color 0
is used for Polygon ID 00h..07h, Color 1 for ID 08h..0Fh, and so on.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0-4: Red, Bit5-9: Green, Bit10-14: Blue, Bit15: Not Used
</TD></TR></TABLE>
Edge Marking allows to mark the edges of an object (whose polygons all have the
same ID) in a wire-frame style. Edge Marking can be enabled (per frame) in
DISP3DCNT. When enabled, the polygon edges are drawn at the edge color, but
only if the old ID value in the Attribute Buffer is different than the Polygon
ID of the new polygon, so no edges are drawn between connected or overlapping
polygons with same ID values.<BR>
Edge Marking is applied ONLY to opaque polygons (including wire-frames).<BR>
Edge Marking increases the size of opaque polygons (see notes below).<BR>
Edge Marking doesn't work very well with Anti-Aliasing (see Anti-Aliasing).<BR>
Technically, when rendering a polygon, it's edges (ie. the wire-frame region)
are flagged as possible-edges (but it's still rendered normally, without using
the edge-color). Once when all opaque polygons (*) have been rendered, the edge
color is applied to these flagged pixels, under following conditions: At least
one of the four surrounding pixels (up, down, left, right) must have different
polygon_id than the edge, and, the edge depth must be LESS than the depth of
that surrounding pixel (ie. no edges are rendered if the depth is GREATER or
EQUAL, even if the polygon_id differs). At the screen borders, edges seem to be
rendered in respect to the rear-plane's polygon_id entry (see Port 4000350h).<BR>
(*) Actually, edge-marking is reportedly performed not until all opaque AND
translucent polygons have been rendered. That brings up some effects/problems
when edges are covered by translucent polys: The edge-color is probably drawn
as is (ie. it'll overwrite the translucent color, rather than being blended
with the translucent color). And, any translucent polygons that do update the
depth buffer will cause total edge-marking malfunction (since edge-marking
involves the comparision of the current/surrounding pixel's depth values).<BR>
<BR>
<B>4000358h - FOG_COLOR - Fog Color (W)</B><BR>
Fog can be used to let more distant polygons to disappear in foggy grayness (or
in darkness, or other color). This is particulary useful to "hide" the far clip
plane. Fog can be enabled in DISP3DCNT.Bit7, moreover, when enabled, it can be
activated or deactivated per polygon (POLYGON_ATTR.Bit15), and per Rear-plane
(see there).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-4    Fog Color, Red     ;\
  5-9    Fog Color, Green   ; used only when DISP3DCNT.Bit6 is zero
  10-14  Fog Color, Blue    ;/
  15     Not used
  16-20  Fog Alpha          ;-used no matter of DISP3DCNT.Bit6
  21-31  Not used
</TD></TR></TABLE>
Whether or not fog is applied to a pixel depends on the Fog flag in the
framebuffer, the initial value of that flag can be defined in the rear-plane.
When rendering opaque pixels, the framebuffer's fog flag gets replaced by
PolygonAttr.Bit15. When rendering translucent pixels, the old flag in the
framebuffer gets ANDed with PolygonAttr.Bit15.<BR>
<BR>
<B>400035Ch - FOG_OFFSET - Fog Depth Offset (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-14   Fog Offset (Unsigned) (0..7FFFh)
  15-31  Not used
</TD></TR></TABLE>
FogDepthBoundary[0..31] (for FogDensity[0..31]) are defined as:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  FogDepthBoundary[n] = FOG_OFFSET + FOG_STEP*(n+1)   ;with n = 0..31
</TD></TR></TABLE>
Whereas FOG_STEP is derived from the FOG_SHIFT value in DISP3DCNT.Bit8-11
(FOG_STEP=400h shr FOG_SHIFT) (normally FOG_SHIFT should be 0..10 (bigger shift
amounts of 11..15 would cause FOG_STEP to become zero, so only Density[0] and
Density[31] would be used).<BR>
The meaning of the depth values depends on whether z-values or w-values are
stored in the framebuffer (see SwapBuffers.Bit1).<BR>
For translucent polygons, the depth value (and therefore: the amount of fog)
depends on the depth update bit (see PolygonAttr.Bit11).<BR>
<BR>
<B>4000360h..37Fh - FOG_TABLE - Fog Density Table (W)</B><BR>
This 32-byte region contains FogDensity[0..31] (used at FogDepthBoundary[n]),<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-6    Fog Density (00h..7Fh = None..Full) (usually increasing values)
  7      Not used
</TD></TR></TABLE>
FogDensity[0] is used for all pixels closer than FogDepthBoundary[0],
FogDensity[31] is used for all pixels more distant than FogDepthBoundary[0].<BR>
Density is linear interpolated for pixels that are between two Density depth
boundaries. The formula for Fog Blending is:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  FrameBuffer[R] = (FogColor[R]*Density + FrameBuffer[R]*(128-Density)) / 128
  FrameBuffer[G] = (FogColor[G]*Density + FrameBuffer[G]*(128-Density)) / 128
  FrameBuffer[B] = (FogColor[B]*Density + FrameBuffer[B]*(128-Density)) / 128
  FrameBuffer[A] = (FogColor[A]*Density + FrameBuffer[A]*(128-Density)) / 128
</TD></TR></TABLE>
If DISP3DCNT.Bit6 is set (=Alpha Only), then only FrameBuffer[A] is updated,
and FrameBuffer[RGB] are kepth unchanged. Density=127 is handled as if
Density=128.<BR>
Fog Glitch: The fog_alpha value appears to be ignored (treated as
fog_alpha=1Fh) in the region up to the first density boundary. However,
normally that value will be multiplied by zero (assumung that density[0] is
usually zero), so you won't ever notice that hardware glitch.<BR>
<BR>
<B>Alpha-Blending (Polygon vs FrameBuffer)</B><BR>
Alpha-Blending occurs for pixels of translucent polygons,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  FrameBuf[R] = (Poly[R]*(Poly[A]+1) + FrameBuf[R]*(31-(Poly[A])) / 32
  FrameBuf[G] = (Poly[G]*(Poly[A]+1) + FrameBuf[G]*(31-(Poly[A])) / 32
  FrameBuf[B] = (Poly[B]*(Poly[A]+1) + FrameBuf[B]*(31-(Poly[A])) / 32
  FrameBuf[A] = max(Poly[A],FrameBuf[A])
</TD></TR></TABLE>
There are three situations in which Alpha-Blending is bypassed (the old
Framebuf[R,G,B,A] value is then simply overwritten by Poly[R,G,B,A]):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1) Alpha-Blending is disabled                       (DISP3DCNT.Bit3=0)
  2) The polygon pixel is opaque                      (Poly[A]=31)
  3) The old framebuffer value is totally transparent (FrameBuf[A]=0)
</TD></TR></TABLE>
The third case can happen if the rear-plane was initialized with Alpha=0, which
causes the polygon not to be blended with the rear-plane (which may give better
results when subsequently blending the 3D layer with the 2D engine).<BR>
Note: Totally transparent pixels (with Poly[A]=0) are not rendered (ie. neither
FrameBuf[R,G,B,A] nor FrameBuf[Depth,Fog,PolyID,etc.] are updated.<BR>
<BR>
<B>Anti-Aliasing</B><BR>
Anti-Aliasing can be enabled in DISP3DCNT, when enabled, the edges of opaque
polygons will be anti-aliased (ie. the pixels at the edges may become
translucent).<BR>
Anti-Aliasing is not applied on translucent polygons. And, Anti-Aliasing is not
applied on the interiors of the poylgons (eg. an 8x8 chessboard texture will be
anti-aliased only at the board edges, not at the edges of the 64 fields).<BR>
Anti-Aliasing is (accidently) applied to opaque 1dot polygongs, line-segments
and wire-frames (which results in dirty lines with missing pixels, 1dot polys
become totally invisible), workaround is to use translucent dots, lines and
wires (eg. with alpha=30).<BR>
Anti-Aliasing is (correctly) not applied to edges of Edge-Marked polygons, in
that special case even opaque line-segments and wire-frames are working even if
anti-aliasing is enabled (provided that they are edge-marked, ie. if their
polygon ID differs from the framebuffer's ID).<BR>
Anti-Aliasing is (accidently) making the edges of Edge-Marked polygons
translucent (with alpha=16 or so?), that reduces the contrast of the edge
colors. Moreover, if two of these translucent edges do overlap, then they are
blended twice (even if they have the same polygon_id, and even if the
depth_update bit in polygon_attr is set; both should normally prevent
double-blending), that scatters the brightness of such edges.<BR>
<BR>
<B>Polygon Size</B><BR>
In some cases, the NDS hardware doesn't render the lower/right edges of certain
polygons. That feature reduces rendering load, and, when rendering connected
polygons (eg. strips), then it'd be unnecessary to render that edges (since
they'd overlap with the upper/left edges of the other polygon). On the
contrary, if there's no connected polygon displayed, then the polygon may
appear smaller than expected. Small polygons with excluded edges are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Opaque polygons (except wire-frames) without Edge-Marking and Anti-Aliasing,
  and, all polygons with vertical right-edges (except line-segments).
  Plus, Translucent Polys when Alpha-Blending is disabled in DISP3DCNT.Bit3.
</TD></TR></TABLE>
All other polygons are rendered at full size with all edges included (except
vertical right edges). Note: To disable the small-polygon feature, you can
enable edge-marking (which does increase the polygon size, even if no edges are
drawn, ie. even if all polys do have the same ID).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="ds3dstatus"></A>
  DS 3D Status
</FONT></TD></TR></TABLE><BR>
<B>4000600h - GXSTAT - Geometry Engine Status Register (R and R/W)</B><BR>
Bit 30-31 are R/W. Writing "1" to Bit15 does reset the Error Flag (Bit15), and
additionally resets the Projection Stack Pointer (Bit13), and probably (?) also
the Texture Stack Pointer. All other GXSTAT bits are read-only.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     BoxTest,PositionTest,VectorTest Busy (0=Ready, 1=Busy)
  1     BoxTest Result  (0=All Outside View, 1=Parts or Fully Inside View)
  2-7   Not used
  8-12  Position &amp; Vector Matrix Stack Level (0..31) (lower 5bit of 6bit value)
  13    Projection Matrix Stack Level        (0..1)
  14    Matrix Stack Busy (0=No, 1=Yes; Currently executing a Push/Pop command)
  15    Matrix Stack Overflow/Underflow Error (0=No, 1=Error/Acknowledge/Reset)
  16-24 Number of 40bit-entries in Command FIFO  (0..256)
 (24)   Command FIFO Full (MSB of above)  (0=No, 1=Yes; Full)
  25    Command FIFO Less Than Half Full  (0=No, 1=Yes; Less than Half-full)
  26    Command FIFO Empty                (0=No, 1=Yes; Empty)
  27    Geometry Engine Busy (0=No, 1=Yes; Busy; Commands are executing)
  28-29 Not used
  30-31 Command FIFO IRQ (0=Never, 1=Less than half full, 2=Empty, 3=Reserved)
</TD></TR></TABLE>
When GXFIFO IRQ is enabled (setting 1 or 2), the IRQ flag (IF.Bit21) is set
while and as long as the IRQ condition is true (and attempts to acknowledge the
IRQ by writing to IF.Bit21 have no effect). So that, the IRQ handler must
either fill the FIFO, or disable the IRQ (setting 0), BEFORE trying to
acknowledge the IRQ.<BR>
<BR>
<B>4000604h - RAM_COUNT - Polygon List &amp; Vertex RAM Count Register (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-11   Number of Polygons currently stored in Polygon List RAM (0..2048)
  12-15  Not used
  16-28  Number of Vertices currently stored in Vertex RAM       (0..6144)
  13-15  Not used
</TD></TR></TABLE>
If a SwapBuffers command has been sent, then the counters are reset 10 cycles
(at 33.51MHz clock) after next VBlank.<BR>
<BR>
<B>4000320h - RDLINES_COUNT - Rendered Line Count Register (R)</B><BR>
Rendering starts in scanline 214, the rendered lines are stored in a buffer
that can hold up to 48 scanlines. The actual screen output begins after
scanline 262, the lines are then read from the buffer and sent to the display.
Simultaneously, the rendering engine keeps writing new lines to the buffer
(ideally at the same speed than display output, so the buffer would always
contain 48 pre-calculated lines).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-5    Minimum Number (minus 2) of buffered lines in previous frame (0..46)
  6-31   Not used
</TD></TR></TABLE>
If rendering becomes slower than the display output, then the number of
buffered lines decreases. Smaller values in RDLINES indicate that additional
load to the rendering engine may cause buffer underflows in further frames, if
so, the program should reduce the number of polygons to avoid display glitches.<BR>
Even if RDLINES becomes zero, it doesn't indicate whether actual buffer
underflows have occured or not (underflows are indicated in DISP3DCNT Bit12).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="ds3dtests"></A>
  DS 3D Tests
</FONT></TD></TR></TABLE><BR>
<B>40005C0h - Cmd 70h - BOX_TEST - Test if Cuboid Sits inside View Volume (W)</B><BR>
The BoxTest result indicates if one or more of the 6 faces of the box are fully
or parts of inside of the view volume. Can be used to reduce unnecessary
overload, ie. if the result is false, then the program can skip drawing of
objects which are inside of the box.<BR>
BoxTest verifies only if the faces of the box are inside view volume, and so,
it will return false if the whole view volume is located inside of the box
(still objects inside of the box may be inside of view).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Parameter 1, Bit 0-15   X-Coordinate
  Parameter 1, Bit 16-31  Y-Coordinate
  Parameter 2, Bit 0-15   Z-Coordinate
  Parameter 2, Bit 16-31  Width  (presumably: X-Offset?)
  Parameter 3, Bit 0-15   Height (presumably: Y-Offset?)
  Parameter 3, Bit 16-31  Depth  (presumably: Z-Offset?)
  All values are 1bit sign, 3bit integer, 12bit fractional part
</TD></TR></TABLE>
The result of the "coordinate+offset" additions should not overflow 16bit
vertex coordinate range (1bit sign, 3bit integer, 12bit fraction).<BR>
Before using BoxTest, be sure that far-plane-intersecting &amp; 1-dot polygons
are enabled, if they aren't: Send the PolygonAttr command (with bit12,13 set to
enable them), followed by dummy Begin and End commands (required to apply the
new PolygonAttr settings). BoxTest should not be issued within Begin/End.<BR>
After sending the BoxTest command, wait until GXSTAT.Bit0 indicates Ready, then
read the result from GXSTAT.Bit1.<BR>
<BR>
<B>40005C4h - Cmd 71h - POS_TEST - Set Position Coordinates for Test (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Parameter 1, Bit 0-15   X-Coordinate
  Parameter 1, Bit 16-31  Y-Coordinate
  Parameter 2, Bit 0-15   Z-Coordinate
  Parameter 2, Bit 16-31  Not used
  All values are 1bit sign, 3bit integer, 12bit fractional part.
</TD></TR></TABLE>
Multiplies the specified line-vector (x,y,z,1) by the clip coordinate matrix.<BR>
After sending the command, wait until GXSTAT.Bit0 indicates Ready, then read
the result from POS_RESULT registers. POS_TEST can be issued anywhere (except
within polygon strips, huh?).<BR>
Caution: POS_TEST overwrites the internal VTX registers, so the next vertex
should be &lt;fully&gt; defined by VTX_10 or VTX_16, otherwise, when using
VTX_XY, VTX_XZ, VTX_YZ, or VTX_DIFF, then the new vertex will be relative to
the POS_TEST coordinates (rather than to the previous vertex).<BR>
<BR>
<B>4000620h..62Fh - POS_RESULT - Position Test Results (R)</B><BR>
This 16-byte region (4 words) contains the resulting clip coordinates (x,y,z,w)
from the POS_TEST command. Each value is 1bit sign, 19bit integer, 12bit
fractional part.<BR>
<BR>
<B>40005C8h - Cmd 72h - VEC_TEST - Set Directional Vector for Test (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Parameter 1, Bit 0-9    X-Component
  Parameter 1, Bit 10-19  Y-Component
  Parameter 1, Bit 20-29  Z-Component
  Parameter 1, Bit 30-31  Not used
  All values are 1bit sign, 9bit fractional part.
</TD></TR></TABLE>
Multiplies the specified line-vector (x,y,z,0) by the directional vector
matrix. Similar as for the NORMAL command, it does require Matrix Mode 2 (ie.
Position &amp; Vector Simultaneous Set mode).<BR>
After sending the command, wait until GXSTAT.Bit0 indicates Ready, then read
the result ("the directional vector in the View coordinate space") from
VEC_RESULT registers.<BR>
<BR>
<B>4000630h..635h - VEC_RESULT - Vector Test Results (R)</B><BR>
This 6-byte region (3 halfwords) contains the resulting vector (x,y,z) from the
VEC_TEST command. Each value is 4bit sign, 0bit integer, 12bit fractional part.
The 4bit sign is either 0000b (positive) or 1111b (negative).<BR>
There is no integer part, so values &gt;=1.0 or &lt;-1.0 will cause overflows.<BR>
(Eg. +1.0 aka 1000h will be returned as -1.0 aka F000h due to overflow and
sign-expansion).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="ds3drearplane"></A>
  DS 3D Rear-Plane
</FONT></TD></TR></TABLE><BR>
Other docs seem to refer to this as Clear-plane, rather than Rear-plane,
anyways, the plane can be an image, so it isn't always "cleared".<BR>
The view order is as such:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  --&gt; 2D Layers --&gt; 3D Polygons --&gt; 3D Rear-plane --&gt; 2D Layers --&gt; 2D Backdrop
</TD></TR></TABLE>
The rear-plane can be disabled (by making it transparent; alpha=0), so that the
2D layers become visible as background.<BR>
2D layers can be moved in front of, or behind the 3D layer-group (which is
represented as BG0 to the 2D Engine), 2D layers behind BG0 can be used instead
of, or additionally to the rear-plane.<BR>
<BR>
The rear-plane can be initialized via below two registers (so all pixels in the
plane have the same colors and attributes), this method is used when
DISP3DCNT.14 is zero:<BR>
<BR>
<B>4000350h - CLEAR_COLOR - Clear Color Attribute Register (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-4    Clear Color, Red
  5-9    Clear Color, Green
  10-14  Clear Color, Blue
  15     Fog (enables Fog to the rear-plane) (doesn't affect Fog of polygons)
  16-20  Alpha
  21-23  Not used
  24-29  Clear Polygon ID (affects edge-marking, at the screen-edges?)
  30-31  Not used
</TD></TR></TABLE>
<BR>
<B>4000354h - CLEAR_DEPTH - Clear Depth Register (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-14   Clear Depth (0..7FFFh) (usually 7FFFh = most distant)
  15     Not used
  16-31  See Port 4000356h, CLRIMAGE_OFFSET
</TD></TR></TABLE>
The 15bit Depth is expanded to 24bit as "X=(X*200h)+((X+1)/8000h)*1FFh".<BR>
<BR>
<B>Rear Color/Depth Bitmaps</B><BR>
Alternately, the rear-plane can be initialized by bitmap data (allowing to
assign different colors &amp; attributes to each pixel), this method is used
when DISP3DCNT.14 is set:<BR>
Consists of two bitmaps (one with color data, one with depth data), each
containing 256x256 16bit entries, and so, each occupying a whole 128K slot,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Rear Color Bitmap (located in Texture Slot 2)
    0-4    Clear Color, Red
    5-9    Clear Color, Green
    10-14  Clear Color, Blue
    15     Alpha (0=Transparent, 1=Solid) (equivalent to 5bit-alpha 0 and 31)
  Rear Depth Bitmap (located in Texture Slot 3)
    0-14   Clear Depth, expanded to 24bit as X=(X*200h)+((X+1)/8000h)*1FFh
    15     Clear Fog (Initial fog enable value)
</TD></TR></TABLE>
This method requires VRAM to be allocated to Texture Slot 2 and 3 (see Memory
Control chapter). Of course, in that case the VRAM is used as Rear-plane, and
cannot be used for Textures.<BR>
The bitmap method is restricted to 1bit alpha values (the register-method
allows to use a 5bit alpha value).<BR>
The Clear Polygon ID is kept defined in the CLEAR_COLOR register, even in
bitmap mode.<BR>
<BR>
<B>4000356h - CLRIMAGE_OFFSET - Rear-plane Bitmap Scroll Offsets (W)</B><BR>
The visible portion of the bitmap is 256x192 pixels (regardless of the viewport
setting, which is used only for polygon clipping). Internally, the bitmap is
256x256 pixels, so the bottom-most 64 rows are usually offscreen, unless
scrolling is used to move them into view.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0-7   X-Offset (0..255; 0=upper row of bitmap)
  Bit8-14  Y-Offset (0..255; 0=left column of bitmap)
</TD></TR></TABLE>
The bitmap wraps to the upper/left edges when exceeding the lower/right edges.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="ds3dfinal2doutput"></A>
  DS 3D Final 2D Output
</FONT></TD></TR></TABLE><BR>
The final 3D image (consisting of polygons and rear-plane) is passed to 2D
Engine A as BG0 layer (provided that DISPCNT is configured to use 3D as BG0).<BR>
<BR>
<B>Scrolling</B><BR>
The BG0HOFS register (4000010h) can be used the scroll the 3D layer
horizontally, the scroll region is 512 pixels, consisting of 256 pixels for the
3D image, followed by 256 transparent pixels, and then wrapped to the 3D image
again. Vertical scrolling (and rotation/scaling) cannot be used on the 3D
layer.<BR>
<BR>
<B>BG Priority Order</B><BR>
The lower 2bit of the BG0CNT register (4000008h) control the priority relative
to other BGs and OBJs, so the 3D layer can be in front of or behind 2D layers.
All other bits in BG0CNT have no effect on 3D, namely, mosaic cannot be used on
the 3D layer.<BR>
<BR>
<B>Special Effects</B><BR>
Special Effects Registers (4000050h..54h) can be used as such:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Brightness up/down with BG0 as 1st Target via EVY   (as for 2D)
  Blending with BG0 as 2nd Target via EVA/EVB         (as for 2D)
  Blending with BG0 as 1st Target via 3D Alpha-values (unlike as for 2D)
</TD></TR></TABLE>
The latter method probably (?) uses per-pixel 3D alpha values as such: EVA=A/2,
and EVB=16-A/2, without using the EVA/EVB settings in 4000052h.<BR>
<BR>
<B>Window Feature</B><BR>
Window Feature (4000040h..4Bh) can be used as for 2D.<BR>
"If the 3D screen has highest priority, then alpha-blending is always enabled,
regardless of the Window Control register's color effect enable flag [ie.
regardless of Bit5 of WIN0IN, WIN1IN, WINOBJ, WINOUT registers]"... not sure if
that is true, and if it superseedes the effect selection in Port 4000050h...?<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dssound"></A>
  DS Sound
</FONT></TD></TR></TABLE><BR>
<B>DS Sound Hardware</B><BR>
The DS contains 16 hardware sound channels.<BR>
The console contains two speakers, arranged left and right of the upper screen,
and so, provides stereo sound even without using the headphone socket.<BR>
<A HREF="#dssoundchannels015">DS Sound Channels 0..15</A><BR>
<A HREF="#dssoundcontrolregisters">DS Sound Control Registers</A><BR>
<A HREF="#dssoundcapture">DS Sound Capture</A><BR>
<A HREF="#dssoundblockdiagrams">DS Sound Block Diagrams</A><BR>
<A HREF="#dssoundnotes">DS Sound Notes</A><BR>
<BR>
<B>DS Sound Files</B><BR>
<A HREF="#dsfilessoundsdatetc">DS Files - Sound (SDAT etc.)</A><BR>
<BR>
<B>Power control</B><BR>
When restoring power supply to the sound circuit, do not output any sound
during the first 15 milliseconds.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dssoundchannels015"></A>
  DS Sound Channels 0..15
</FONT></TD></TR></TABLE><BR>
Each of the 16 sound channels occopies 16 bytes in the I/O region, starting
with channel 0 at 4000400h..400040Fh, up to channel 15 at 40004F0h..40004FFh.<BR>
<BR>
<B>40004x0h - NDS7 - SOUNDxCNT - Sound Channel X Control Register (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0-6    Volume Mul   (0..127=silent..loud)
  Bit7      Not used     (always zero)
  Bit8-9    Volume Div   (0=Normal, 1=Div2, 2=Div4, 3=Div16)
  Bit10-14  Not used     (always zero)
  Bit15     Hold         (0=Normal, 1=Hold last sample after one-shot sound)
  Bit16-22  Panning      (0..127=left..right) (64=half volume on both speakers)
  Bit23     Not used     (always zero)
  Bit24-26  Wave Duty    (0..7) ;HIGH=(N+1)*12.5%, LOW=(7-N)*12.5% (PSG only)
  Bit27-28  Repeat Mode  (0=Manual, 1=Loop Infinite, 2=One-Shot, 3=Prohibited)
  Bit29-30  Format       (0=PCM8, 1=PCM16, 2=IMA-ADPCM, 3=PSG/Noise)
  Bit31     Start/Status (0=Stop, 1=Start/Busy)
</TD></TR></TABLE>
All channels support ADPCM/PCM formats, PSG rectangular wave can be used only
on channels 8..13, and white noise only on channels 14..15.<BR>
<BR>
<B>40004x4h - NDS7 - SOUNDxSAD - Sound Channel X Data Source Register (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0-26  Source Address (must be word aligned, bit0-1 are always zero)
  Bit27-31 Not used
</TD></TR></TABLE>
<BR>
<B>40004x8h - NDS7 - SOUNDxTMR - Sound Channel X Timer Register (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0-15  Timer Value, Sample frequency, timerval=-(33513982Hz/2)/freq
</TD></TR></TABLE>
The PSG Duty Cycles are composed of eight "samples", and so, the frequency for
Rectangular Wave is 1/8th of the selected sample frequency.<BR>
For PSG Noise, the noise frequency is equal to the sample frequency.<BR>
<BR>
<B>40004xAh - NDS7 - SOUNDxPNT - Sound Channel X Loopstart Register (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0-15  Loop Start, Sample loop start position
           (counted in words, ie. N*4 bytes)
</TD></TR></TABLE>
<BR>
<B>40004xCh - NDS7 - SOUNDxLEN - Sound Channel X Length Register (W)</B><BR>
The number of samples for N words is 4*N PCM8 samples, 2*N PCM16 samples, or
8*(N-1) ADPCM samples (the first word containing the ADPCM header). The Sound
Length is not used in PSG mode.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0-21  Sound length (counted in words, ie. N*4 bytes)
  Bit22-31 Not used
</TD></TR></TABLE>
Minimum length (the sum of PNT+LEN) is 4 words (16 bytes), smaller values (0..3
words) are causing hang-ups (busy bit remains set infinite, but no sound output
occurs).<BR>
<BR>
In One-shot mode, the sound length is the sum of (PNT+LEN).<BR>
In Looped mode, the length is (1*PNT+Infinite*LEN), ie. the first part (PNT) is
played once, the second part (LEN) is repeated infinitely.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dssoundcontrolregisters"></A>
  DS Sound Control Registers
</FONT></TD></TR></TABLE><BR>
<B>4000500h - NDS7 - SOUNDCNT - Sound Control Register (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0-6   Master Volume       (0..127=silent..loud)
  Bit7     Not used            (always zero)
  Bit8-9   Left Output from    (0=Left Mixer, 1=Ch1, 2=Ch3, 3=Ch1+Ch3)
  Bit10-11 Right Output from   (0=Right Mixer, 1=Ch1, 2=Ch3, 3=Ch1+Ch3)
  Bit12    Output Ch1 to Mixer (0=Yes, 1=No) (both Left/Right)
  Bit13    Output Ch3 to Mixer (0=Yes, 1=No) (both Left/Right)
  Bit14    Not used            (always zero)
  Bit15    Master Enable       (0=Disable, 1=Enable)
  Bit16-31 Not used            (always zero)
</TD></TR></TABLE>
<BR>
<B>4000504h - NDS7 - SOUNDBIAS - Sound Bias Register (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0-9   Sound Bias    (0..3FFh, usually 200h)
  Bit10-31 Not used      (always zero)
</TD></TR></TABLE>
After applying the master volume, the signed left/right audio signals are in
range -200h..+1FFh (with medium level zero), the Bias value is then added to
convert the signed numbers into unsigned values (with medium level 200h).<BR>
BIAS output is always enabled, even when Master Enable (SOUNDCNT.15) is off.<BR>
<BR>
The sampling frequency of the mixer is 1.04876 MHz with an amplitude resolution
of 24 bits, but the sampling frequency after mixing with PWM modulation is
32.768 kHz with an amplitude resolution of 10 bits.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dssoundcapture"></A>
  DS Sound Capture
</FONT></TD></TR></TABLE><BR>
The DS contains 2 built-in sound capture devices that can capture output
waveform data to memory.<BR>
Sound capture 0 can capture output from left-mixer or output from channel 0.<BR>
Sound capture 1 can capture output from right-mixer or output from channel 2.<BR>
<BR>
<B>4000508h - NDS7 - SNDCAP0CNT - Sound Capture 0 Control Register (R/W)</B><BR>
<B>4000509h - NDS7 - SNDCAP1CNT - Sound Capture 1 Control Register (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0     Control of Associated Sound Channels (ANDed with Bit7)
            SNDCAP0CNT: Output Sound Channel 1 (0=As such, 1=Add to Channel 0)
            SNDCAP1CNT: Output Sound Channel 3 (0=As such, 1=Add to Channel 2)
            Caution: Addition mode works only if BOTH Bit0 and Bit7 are set.
  Bit1     Capture Source Selection
            SNDCAP0CNT: Capture 0 Source (0=Left Mixer, 1=Channel 0/Bugged)
            SNDCAP1CNT: Capture 1 Source (0=Right Mixer, 1=Channel 2/Bugged)
  Bit2     Capture Repeat        (0=Loop, 1=One-shot)
  Bit3     Capture Format        (0=PCM16, 1=PCM8)
  Bit4-6   Not used              (always zero)
  Bit7     Capture Start/Status  (0=Stop, 1=Start/Busy)
</TD></TR></TABLE>
<BR>
<B>4000510h - NDS7 - SNDCAP0DAD - Sound Capture 0 Destination Address (R/W)</B><BR>
<B>4000518h - NDS7 - SNDCAP1DAD - Sound Capture 1 Destination Address (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0-26  Destination address (word aligned, bit0-1 are always zero)
  Bit27-31 Not used (always zero)
</TD></TR></TABLE>
Capture start address (also used as re-start address for looped capture).<BR>
<BR>
<B>4000514h - NDS7 - SNDCAP0LEN - Sound Capture 0 Length (W)</B><BR>
<B>400051Ch - NDS7 - SNDCAP1LEN - Sound Capture 1 Length (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0-15  Buffer length (1..FFFFh words) (ie. N*4 bytes)
  Bit16-31 Not used
</TD></TR></TABLE>
Minimum length is 1 word (attempts to use 0 words are interpreted as 1 word).<BR>
<BR>
<B>SOUND1TMR - NDS7 - Sound Channel 1 Timer shared as Capture 0 Timer</B><BR>
<B>SOUND3TMR - NDS7 - Sound Channel 3 Timer shared as Capture 1 Timer</B><BR>
There are no separate capture frequency registers, instead, the sample
frequency of Channel 1/3 is shared for Capture 0/1. These channels are intended
to output the captured data, so it makes sense that both capture and sound
output use the same frequency.<BR>
<BR>
For Capture 0, a=0, b=1, x=0.<BR>
For Capture 1, a=2, b=3, x=1.<BR>
<BR>
<B>Capture Bugs</B><BR>
The NDS contains two hardware bugs which do occur when capturing data from
ch(a) (SNDCAPxCNT.Bit1=1), if so, either bug occurs depending on whether
ch(a)+ch(b) addition is enabled or disabled (SNDCAPxCNT.Bit0).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1) Both Negative Bug - SNDCAPxCNT Bit1=1, Bit0=0 (addition disabled)
   Capture data is accidently set to -8000h if ch(a) and ch(b) are both &lt;0.
   Otherwise the correct capture result is returned, ie. plain ch(a) data,
   not being affected by ch(b) (since addition is disabled).
   Workaround: Ensure that ch(a) and/or ch(b) are &gt;=0 (or disabled).
 2) Overflow Bug - SNDCAPxCNT Bit1=1, Bit0=1 (addition enabled)
   In this mode, Capture data isn't clipped to MinMax(-8000h,+7FFFh),
   instead, it is ANDed with FFFFh, so the sign bit is lost if the
   addition result ch(a)+ch(b) is less/greater than -8000h/+7FFFh.
   Workaround: Reduce ch(a)/ch(b) volume or data to avoid overflows.
</TD></TR></TABLE>
These bugs occur only for capture (speaker output remains intact), and they
occur only when capturing ch(a) (capturing mixer-output works flawless).<BR>
<BR>
<B>ch(a)+ch(b) Channel Addition</B><BR>
The ch(a)+ch(b) addition unit has 2 outputs, with slightly different results:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 1) Addition Result for Capture(x) when using capture source=ch(a):
  Addition is performed always, no matter of SOUNDCNT.Bit12/13.
  And, no matter of ch(a) enable, result is plain ch(b) if ch(a) is disabled.
  Result is 16bit (plus fraction) with overflow error (see Capture Bugs).
 2) Addition Result for Mixer (towards speakers, and capture source=mixer):
  Ch(b) is muted if ch(a) is disabled.
  Ch(b) is muted if ch(b) SOUNDCNT.Bit12/13 is set to "Ch(b) not to mixer".
  Result is 17bit (plus fraction) without overflow error.
</TD></TR></TABLE>
Addition mode can be used only if the &lt;corresponding&gt; capture unit is
enabled, ie. if SNDCAPxCNT (Bit0 AND Bit7)=1. If so, addition affects both
mixers (and so, may also affect the &lt;other&gt; capture unit if it reads from
mixer).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dssoundblockdiagrams"></A>
  DS Sound Block Diagrams
</FONT></TD></TR></TABLE><BR>
<B>Left Mixer with Capture 0</B><BR>
<B>(Right Mixer with Capture 1, respectively)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
                       _____
  Ch0.L -------------&gt;|     |  .------------------------------&gt; to Capture 0
               ___    |     |  |                  ___
  Ch1.L ---o-&gt;|Sel|--&gt;|     |  |       Ch0..Ch15 |   |
           |  |___|   |Left |--o----------------&gt;|   |
  Ch2.L ---|---------&gt;|Mixer|                    |Sel|   ______    ____
           |   ___    |     |                Ch1 |   |  |Master|  |Add |
  Ch3.L -o-|-&gt;|Sel|--&gt;|     | .-----------------&gt;|   |-&gt;|Volume|-&gt;|Bias|-&gt; L
         | |  |___|   |     | |                  |   |  |______|  |____|
  Ch4.L -|-|---------&gt;|     | |              Ch3 |   |
  ...   -|-|---------&gt;|     | | .---------------&gt;|   |
  Ch15.L-|-|---------&gt;|_____| | |   ___          |   |
         | '------------------o-|-&gt;|Add| Ch1+Ch3 |   |
         '----------------------o-&gt;|___|--------&gt;|___|
</TD></TR></TABLE>
<BR>
<B>Channel 0 and 1, Capture 0 with input from Left Mixer</B><BR>
<B>(Channel 2 and 3, Capture 1 with input from Right Mixer, respectively)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  ____     _________     ___     ___      ___
 |FIFO|--&gt;|Channel 0|--&gt;|Vol|--&gt;|Add|-o-&gt;|Pan|--&gt; Ch0.L
 |____|   |_________|   |___|   |___| |  |___|--&gt; Ch0.R
  ____     _________     ___      ^   |
 |FIFO|&lt;--|Capture 0|&lt;--|Sel|&lt;----|---'
 |____|   |_ _____ _|   |___|&lt;----|-------------- Left Mixer
  ____     _:Timer:_     ___     _|_      ___
 |FIFO|--&gt;|Channel 1|--&gt;|Vol|--&gt;|Sel|---&gt;|Pan|--&gt; Ch1.L
 |____|   |_________|   |___|   |___|    |___|--&gt; Ch1.R
</TD></TR></TABLE>
<BR>
<B>Channel 4 (Channel 5..15, respectively)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  ____     _________     ___              ___
 |FIFO|--&gt;|Channel 4|--&gt;|Vol|-----------&gt;|Pan|--&gt; Ch4.L
 |____|   |_________|   |___|            |___|--&gt; Ch4.R
</TD></TR></TABLE>
<BR>
The FIFO isn't used in PSG/Noise modes (supported on channel 8..15).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dssoundnotes"></A>
  DS Sound Notes
</FONT></TD></TR></TABLE><BR>
<B>Sound delayed Start/Restart (timing glitch)</B><BR>
A sound will be started/restarted when changing its start bit from 0 to 1,
however, the sound won't start immediately: PSG/Noise starts after 1 sample,
PCM starts after 3 samples, and ADPCM starts after 11 samples (3 dummy samples
as for PCM, plus 8 dummy samples for the ADPCM header).<BR>
<BR>
<B>Sound Stop (timing note)</B><BR>
In one-shot mode, the Busy bit gets cleared automatically at the BEGIN of the
last sample period, nethertheless (despite of the cleared Busy bit) the last
sample is kept output until the END of the last sample period (or, if the Hold
flag is set, then the last sample is kept output infinitely, that is, until
Hold gets cleared, or until the sound gets restarted).<BR>
<BR>
<B>Hold Flag (appears useless/bugged)</B><BR>
The Hold flag allows to keep the last sample being output infinitely after the
end of one-shot sounds. This feature is probably intended to allow to play two
continous one-shot sound blocks (without producing any scratch noise upon small
delays between both blocks, which would occur if the output level would drop to
zero).<BR>
However, the feature doesn't work as intended. As described above, PCM8/PCM16
sound starts are delayed by 3 samples. With Hold flag set, old output level is
acually kept intact during the 1st sample, but the output level drops to zero
during 2nd-3rd sample, before starting the new sound in 4th sample.<BR>
<BR>
<B>7bit Volume and Panning Values</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  data.vol   = data*N/128
  pan.left   = data*(128-N)/128
  pan.right  = data*N/128
  master.vol = data*N/128/64
</TD></TR></TABLE>
Register settings of 0..126,127 are interpreted as N=0..126,128.<BR>
<BR>
<B>Max Output Levels</B><BR>
When configured to max volume (and left-most or right-most panning), each
channel can span the full 10bit output range (-200h..1FFh) on one speaker, as
well as the full 16bit input range (-8000h..7FFFh) on one capture unit.<BR>
(It needs 2 channels to span the whole range on BOTH speakers/capture units.)<BR>
Together, all sixteen channels could thus reach levels up to -1E00h..21F0h
(with default BIAS=200h) on one speaker, and -80000h..+7FFF0h on one capture
unit. However, to avoid overflows, speaker outputs are clipped to
MinMax(0,3FFh), and capture inputs to MinMax(-8000h..+7FFFh).<BR>
<BR>
<B>Channel/Mixer Bit-Widths</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Step                           Bits  Min        Max
  0 Incoming PCM16 Data          16.0  -8000h     +7FFFh
  1 Volume Divider (div 1..16)   16.4  -8000h     +7FFFh
  2 Volume Factor (mul N/128)    16.11 -8000h     +7FFFh
  3 Panning (mul N/128)          16.18 -8000h     +7FFFh
  4 Rounding Down (strip 10bit)  16.8  -8000h     +7FFFh
  5 Mixer (add channel 0..15)    20.8  -80000h    +7FFF0h
  6 Master Volume (mul N/128/64) 14.21 -2000h     +1FF0h
  7 Strip fraction               14.0  -2000h     +1FF0h
  8 Add Bias (0..3FFh, def=200h) 15.0  -2000h+0   +1FF0h+3FFh
  9 Clip (min/max 0h..3FFh)      10.0  0          +3FFh
</TD></TR></TABLE>
Table shows integer.fractional bits, and min/max values (without fraction).<BR>
<BR>
<B>Capture Clipping/Rounding</B><BR>
Incoming ch(a) is NOT clipped, ch(a)+ch(b) may overflow (see Capture Bugs).<BR>
Incoming mixer data (20.8bits) is clipped to 16.8bits (MinMax -8000h..7FFFh).<BR>
For PCM8 capture format, the 16.8 bits are divided by 100h (=8.16 bits).<BR>
If the MSB of the fractional part is set, then data is rounded towards zero.<BR>
(Positive values are rounded down, negative values are rounded up.)<BR>
The fractional part is then discarded, and plain integer data is captured.<BR>
<BR>
<B>PSG Sound</B><BR>
The output volume equals to PCM16 values +7FFFh (HIGH) and -7FFFh (LOW).<BR>
PSG sound is always Infinite (the SOUNDxLEN Register, and the SOUNDxCNT Repeat
Mode bits have no effect). The PSG hardware doesn't support sound length,
sweep, or volume envelopes, however, these effects can be produced by software
with little overload (or, more typically, with enormous overload, depending on
the programming language used).<BR>
<BR>
<B>PSG Wave Duty (channel 8..13 in PSG mode)</B><BR>
Each duty cycle consists of eight HIGH or LOW samples, so the sound frequency
is 1/8th of the selected sample rate. The duty cycle always starts at the begin
of the LOW period when the sound gets (re-)started.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0  12.5% "_______-_______-_______-"
  1  25.0% "______--______--______--"
  2  37.5% "_____---_____---_____---"
  3  50.0% "____----____----____----"
  4  62.5% "___-----___-----___-----"
  5  75.0% "__------__------__------"
  6  87.5% "_-------_-------_-------"
  7   0.0% "________________________"
</TD></TR></TABLE>
The Wave Duty bits exist and are read/write-able on all channels (although they
are actually used only in PSG mode on channels 8-13).<BR>
<BR>
<B>PSG Noise (channel 14..15 in PSG mode)</B><BR>
Noise randomly switches between HIGH and LOW samples, the output levels are
calculated, at the selected sample rate, as such:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  X=X SHR 1, IF carry THEN Out=LOW, X=X XOR 6000h ELSE Out=HIGH
</TD></TR></TABLE>
The initial value when (re-)starting the sound is X=7FFFh. The formula is more
or less same as "15bit polynomial counter" used on 8bit Gameboy and GBA.<BR>
<BR>
<B>PCM8 and PCM16</B><BR>
Signed samples in range -80h..+7Fh (PCM8), or -8000h..+7FFFh (PCM16).<BR>
The output volume of PCM8=NNh is equal to PCM16=NN00h.<BR>
<BR>
<B>IMA-ADPCM Format</B><BR>
IMA-ADPCM is a Adaptive Differential Pulse Code Modulation (ADPCM) variant,
designed by International Multimedia Association (IMA), the format is used,
among others, in IMA-ADPCM compressed Windows .WAV files.<BR>
The NDS data consist of a 32bit header, followed by 4bit values (so each byte
contains two values, the first value in the lower 4bits, the second in upper 4
bits). The 32bit header contains initial values:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0-15   Initial PCM16 Value (Pcm16bit = -7FFFh..+7FFF) (not -8000h)
  Bit16-22  Initial Table Index Value (Index = 0..88)
  Bit23-31  Not used (zero)
</TD></TR></TABLE>
In theory, the 4bit values are decoded into PCM16 values, as such:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Diff = ((Data4bit AND 7)*2+1)*AdpcmTable[Index]/8      ;see rounding-error
  IF (Data4bit AND 8)=0 THEN Pcm16bit = Max(Pcm16bit+Diff,+7FFFh)
  IF (Data4bit AND 8)=8 THEN Pcm16bit = Min(Pcm16bit-Diff,-7FFFh)
  Index = MinMax (Index+IndexTable[Data4bit AND 7],0,88)
</TD></TR></TABLE>
In practice, the first line works like so (with rounding-error):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Diff = AdpcmTable[Index]/8
  IF (data4bit AND 1) THEN Diff = Diff + AdpcmTable[Index]/4
  IF (data4bit AND 2) THEN Diff = Diff + AdpcmTable[Index]/2
  IF (data4bit AND 4) THEN Diff = Diff + AdpcmTable[Index]/1
</TD></TR></TABLE>
And, a note on the second/third lines (with clipping-error):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Max(+7FFFh) leaves -8000h unclipped (can happen if initial PCM16 was -8000h)
  Min(-7FFFh) clips -8000h to -7FFFh (possibly unlike windows .WAV files?)
</TD></TR></TABLE>
Whereas, IndexTable[0..7] = -1,-1,-1,-1,2,4,6,8. And AdpcmTable [0..88] =<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0007h,0008h,0009h,000Ah,000Bh,000Ch,000Dh,000Eh,0010h,0011h,0013h,0015h
  0017h,0019h,001Ch,001Fh,0022h,0025h,0029h,002Dh,0032h,0037h,003Ch,0042h
  0049h,0050h,0058h,0061h,006Bh,0076h,0082h,008Fh,009Dh,00ADh,00BEh,00D1h
  00E6h,00FDh,0117h,0133h,0151h,0173h,0198h,01C1h,01EEh,0220h,0256h,0292h
  02D4h,031Ch,036Ch,03C3h,0424h,048Eh,0502h,0583h,0610h,06ABh,0756h,0812h
  08E0h,09C3h,0ABDh,0BD0h,0CFFh,0E4Ch,0FBAh,114Ch,1307h,14EEh,1706h,1954h
  1BDCh,1EA5h,21B6h,2515h,28CAh,2CDFh,315Bh,364Bh,3BB9h,41B2h,4844h,4F7Eh
  5771h,602Fh,69CEh,7462h,7FFFh
</TD></TR></TABLE>
The closest way to reproduce the AdpcmTable with 32bit integer maths appears:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  X=000776d2h, FOR I=0 TO 88, Table[I]=X SHR 16, X=X+(X/10), NEXT I
  Table[3]=000Ah, Table[4]=000Bh, Table[88]=7FFFh, Table[89..127]=0000h
</TD></TR></TABLE>
When using ADPCM and loops, set the loopstart position to the data part, rather
than the header. At the loop end, the SAD value is reloaded to the loop start
location, additionally index and pcm16 values are reloaded to the values that
have originally appeared at that location. Do not change the ADPCM loop start
position during playback.<BR>
<BR>
<B>Microphone Input</B><BR>
For Microphone (and Touchscreen) inputs, see<BR>
<A HREF="#dstouchscreencontrollertsc">DS Touch Screen Controller (TSC)</A><BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dsfilessoundsdatetc"></A>
  DS Files - Sound (SDAT etc.)
</FONT></TD></TR></TABLE><BR>
Sound data is often stored in a SDAT file (with SSEQ, SSAR, SBNK, SWAR, STRM
blocks inside of the SDAT files). Samples can be stored in SWAV files (or be
contained in SWAR's inside of SDAT files).<BR>
<A HREF="#dssoundfilessdatsounddataarchive">DS Sound Files - SDAT (Sound Data Archive)</A><BR>
<A HREF="#dssoundfilessseqsoundsequence">DS Sound Files - SSEQ (Sound Sequence)</A><BR>
<A HREF="#dssoundfilesssarsoundsequencearchive">DS Sound Files - SSAR (Sound Sequence Archive)</A><BR>
<A HREF="#dssoundfilessbnksoundbank">DS Sound Files - SBNK (Sound Bank)</A><BR>
<A HREF="#dssoundfilesswarsoundwavearchive">DS Sound Files - SWAR (Sound Wave Archive)</A><BR>
<A HREF="#dssoundfilesswavsoundwavedata">DS Sound Files - SWAV (Sound Wave Data)</A><BR>
<A HREF="#dssoundfilesstrmsoundwavestream">DS Sound Files - STRM (Sound Wave Stream)</A><BR>
Thanks: <A HREF="http://www.feshrine.net/hacking/doc/nds-sdat.php"><FONT COLOR=#808080>http://www.feshrine.net/hacking/doc/nds-sdat.php</FONT></A>
 - 2007 by kiwi.ds<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dssoundfilessdatsounddataarchive"></A>
  DS Sound Files - SDAT (Sound Data Archive)
</FONT></TD></TR></TABLE><BR>
<B>SDAT Header</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4     ID "SDAT"           ;alike "CSAR" on 3DS
  004h 2     Byte Order    (FEFFh)
  006h 2     Version       (0100h)
  008h 4     Total Filesize
  00Ch 2     Header Size (usually 40h)
  00Eh 2     Number of Blocks (usually 4 = SYMB+INFO+FAT+FILE) (or 3=no SYMB)
  010h 4+4   SYMB Block (Offset from SDAT+0, Size) ;=0,0 if above is 3=no SYMB
  018h 4+4   INFO Block (Offset from SDAT+0, Size) ;\
  020h 4+4   FAT  Block (Offset from SDAT+0, Size) ; always present
  028h 4+4   FILE Block (Offset from SDAT+0, Size) ;/
  030h 10h   Padding to 20h-byte boundary (0)
</TD></TR></TABLE>
The SYMB block exists in most SDAT files (except in some titles like Downhill
Jam and Over the Hedge).<BR>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 _________________________________ SYMB Block _________________________________
</TD></TR></TABLE>
<BR>
<B>Symbol Block (if present) (names for the corresponding items in INFO block)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4     ID "SYMB"
  004h 4     SYMB Block Size (rounded up to 4-byte boundary, unlike as in SDAT)
  008h 4     File List SSEQ    (Offset from SYMB+0) Sequences (songs)
  00Ch 4     Folder List SSAR  (Offset from SYMB+0) Sequence Archives (fx)
  010h 4     File List BANK    (Offset from SYMB+0) Banks
  014h 4     File List SWAR    (Offset from SYMB+0) Wave Archives (samples)
  018h 4     File List Player  (Offset from SYMB+0) Player (Group-related)
  01Ch 4     File List Group   (Offset from SYMB+0) Group (SSEQ+SSAR+BANK+SWAR)
  020h 4     File List Player2 (Offset from SYMB+0) Player2 (Stream-related)
  024h 4     File List STRM    (Offset from SYMB+0) Wave Stream
  028h 18h   Reserved (0)
  040h ..    File/Folder Lists (see below)
  ..   ..    File/Folder Name Strings (ASCII, terminated by 0)
  ..   ..    Padding to 4-byte boundary (0)
</TD></TR></TABLE>
File List's are having following format:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4       Number of entries in this list (can be 0=None)
  004h N*4     File Name (Offset from SYMB+0)
</TD></TR></TABLE>
Folder List (for SSAR):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4       Number of entries in this list (can be 0=None)
  004h N*(4+4) SSAR "Folder Name" and SSEQ "File List" (Offset's from SYMB+0)
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 _________________________________ INFO Block _________________________________
</TD></TR></TABLE>
<BR>
<B>Info Block</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4     ID "INFO"
  004h 4     INFO Block Size (same as in SDAT header)
  008h 4     Info List SSEQ    (Offset from INFO+0) Sequences (songs)
  00Ch 4     Info List SSAR    (Offset from INFO+0) Sequence Archives (fx)
  010h 4     Info List BANK    (Offset from INFO+0) Banks
  014h 4     Info List SWAR    (Offset from INFO+0) Wave Archives (samples)
  018h 4     Info List Player  (Offset from INFO+0) Player (Group-related)
  01Ch 4     Info List Group   (Offset from INFO+0) Group (SSEQ+SSAR+BANK+SWAR)
  020h 4     Info List Player2 (Offset from INFO+0) Player2 (Stream-related)
  024h 4     Info List STRM    (Offset from INFO+0) Wave Stream
  028h 18h   Reserved (0)
  ..   ..    Info Lists (see below)
  ..   ..    Info Entries (see below)
  ..   ..    Padding to 4-byte boundary (0)
</TD></TR></TABLE>
Info List's are having following format:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4     Number of entries in this list (can be 0=None)
  004h N*4   Info Entries (Offset from INFO+0)
</TD></TR></TABLE>
<BR>
<B>SSEQ Info Entry (Sequences, eg. songs)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 2   FAT fileID of SSEQ file      ;for accessing this file
  002h 2   Unknown
  004h 2   bnk         ;Associated BANK
  006h 1   vol         ;Volume
  007h 1   cpr
  008h 1   ppr
  009h 1   ply
  00Ah 2   Unknown (0)
</TD></TR></TABLE>
<BR>
<B>SSAR Info Entry (Sequence Archives, eg. collections of sound effects)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 2   FAT fileID of SSAR file
  002h 2   unknown
</TD></TR></TABLE>
Note: bnk/vol/cpr/ppr/ply is stored in the SSAR file (instead of in Info). The
actual sequences are also in SSAR? Or does the SSAR contain pointers to SSEQ
files?<BR>
<BR>
<B>BANK Info Entry (Banks)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 2   FAT fileID of SBNK file
  002h 2   unknown
  004h 2   1st SWAR   ;\
  006h 2   2nd SWAR   ; Associated Wave Archives (FFFFh=Unused entry)
  008h 2   3rd SWAR   ;
  00Ah 2   4th SWAR   ;/
</TD></TR></TABLE>
<BR>
<B>SWAR Info Entry (Wave Archives, eg. collections of instruments or effects)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 2   FAT fileID of SWAR file
  002h 2   unknown
</TD></TR></TABLE>
<BR>
<B>Player Info Entry (whatever)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 1   Unknown
  001h 3   Padding
  004h 4   Unknown
</TD></TR></TABLE>
<BR>
<B>Group Info Entry (whatever, list of files that must be loaded to memory?)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4       Number of items in this group
  004h N*(4+4) Array (with ID+Index pairs)
</TD></TR></TABLE>
ID values: 700h=SSEQ, 803h=SSAR, 601h=BANK, 402h=SWAR.<BR>
Index: Entry number in the corresponding SSEQ/SSAR/BANK/SWAR list.<BR>
<BR>
<B>Player2 Info Entry (whatever, Stream related?)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 1   nCount             ;number of USED entries in below array
  001h 16  v[16]              ;unknown array (UNUSED entries are set to FFh
  011h 7   Reserved (0)
</TD></TR></TABLE>
<BR>
<B>STRM Info Entry</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 2   FAT fileID of STRM file    ;for accessing the file
  002h 2   Unknown
  004h 1   vol            ;volume
  005h 1   pri            ;priority?
  006h 1   ply            ;play?
  007h 5   Reserved (0)
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 ____________________________ FAT and FILE Blocks _____________________________
</TD></TR></TABLE>
<BR>
<B>FAT Block</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4         ID "FAT "
  004h 4         FAT Block Size (same as in SDAT header) (0Ch+N*10h)
  008h 4         Number of files
  00Ch N*(4+4+8) File Entries (Offset from SDAT+0, Size, Zero)
</TD></TR></TABLE>
The 8-byte Zero entries can be used for storing data at runtime.<BR>
<BR>
<B>File Block</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4         ID "FILE"
  004h 4         FILE Block Size (same as in SDAT header)
  008h 4         Number of files (same as in FAT block)
  00Ch 4         Reserved (0)
  010h ..        Files (SSEQ,SSAR,SBNK,SWAR,STRM) (at offsets specified in FAT)
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dssoundfilessseqsoundsequence"></A>
  DS Sound Files - SSEQ (Sound Sequence)
</FONT></TD></TR></TABLE><BR>
It is a converted MIDI sequence. Linked to a BANK for instruments.<BR>
SSEQ is usually found inside of SDAT files (but also exists as standalone file,
eg. 3DS Circle Pad Pro test/calib, RomFS:\extrapad_bcwav_LZ.bin\*.sseq, and 3DS
Picture Picker, RomFS:\sound\csnd.LZ\*).<BR>
<BR>
<B>SSEQ Header</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4     ID "SSEQ"                                  ;\
  004h 2     Byte Order    (FEFFh)                      ;
  006h 2     Version       (0100h)                      ; Main header
  008h 4     Total Filesize                             ;
  00Ch 2     Header Size (usually 10h)                  ;
  00Eh 2     Number of Blocks (usually 1 = DATA)        ;/
  010h 4     ID "DATA"                                  ;\
  014h 4     Total Filesize, minus 10h                  ; Sub header
  018h 4     Offset to data (from SSEQ+0) (1Ch)         ;/
  01Ch ..    Arrays of sequence data..                  ;-
</TD></TR></TABLE>
<BR>
NB. For the details of the SSEQ file, please refer to loveemu's sseq2mid<BR>
<BR>
<B>Description</B><BR>
A SSEQ can have at maximum 16 tracks, notes in the range of 0..127 (middle C is
60). Each quartet note has a fixed tick length of 48. Tempo in the range of
1..240 BPM (default is 120). The SSEQ will not be played correctly if tempo
higher than 240.<BR>
<BR>
The SEQ player uses ARM7's Timer1 for timing. The ARM7's 4 Timers runs at 33MHz
(approximately 2^25). The SEQ player sets Timer1 reload value to 2728,
prescaler to F/64. So on about every 0.0052 sec (64*2728/33MHz) the SEQ Player
will be notified (1 cycle). As a quartet note has fixed tick value of 48, the
highest tempo that SEQ Player can handle is 240 BPM (60/(0.0052*48)).<BR>
<BR>
During each cycle, the SEQ player adds the tempo value to a variable. Then it
checks if the value exceeds 240. If it does, the SEQ player subtracts 240 from
the variable, and process the SSEQ file. Using this method, the playback is not
very precise but the difference is too small to be noticed.<BR>
<BR>
Take an example with tempo = 160 BPM, the SSEQ file is processed twice in 3
notifications.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  cycle  variable action
  1       0       Add 160
  2       160     Add 160
  3       320     Subtract 240, process once, add 160
  4       240     Subtract 240, process once, add 160
  5       160     Add 160
  6       320     Subtract 240, process once, add 160
  7       240     Subtract 240, process once, add 160
  8       160     Add 160
</TD></TR></TABLE>
<BR>
<B>Events</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  ID      Parameter             Description
  00h-7Fh Velocity: 1 byte [0..127]
          Duration: Variable Length
                                NOTE-ON. Duration is expressed in tick.
                                48 for quartet note.
                                Usually it is NOT a multiple of 3.
  80h     Duration: Variable Length
                                REST. It tells the SSEQ-sequencer to wait for
                                a certain tick. Usually it is a multiple of 3.
  81h     Bank &amp; Program Number:
          Variable Length
                                bits[0..7] is the program number,
                                bits[8..14] is the bank number.
                                Bank change is seldomly found,
                                so usually bank 0 is used.
  FEh     2 bytes Indicates which tracks are used.
          Bit0 for track 0, ... Bit15 for track 15.
          If the bit is set, the corresponding track is used.
                                Indication begin of multitrack. Must be in the
                                beginning of the first track to work. A series
                                of event 0x93 follows.
  93h     4 bytes 1st byte is track number [0..15]
          The other 3 bytes are the relative adress of track data.
          Add nDataOffset (usually 0x1C) to find out the absolute address.
                                SSEQ is similar to MIDI in that track data are
                                stored one after one track. Unlike mod music.
  94h     JUMP Address: 3 bytes
          (Add nDataOffset (usually 0x1C) to find out the absolute address.)
                                JUMP. A jump must be backward. So that the
                                song will loop forever.
  95h     CALL Address: 3 bytes
          (Add nDataOffset (usually 0x1C) to find out the absolute address.)
  A0h-BFh See loveemu's sseq2mid for more details.
                                Some arithmetic operations / comparions.
                                Affect how SSEQ is to be played.
  C0h     1 byte  PAN                (0..127, middle is 64, uh?)
  C1h     1 byte  VOLUME             (0..127)
  C2h     1 byte  MASTER VOLUME      (0..127)
  C3h     1 byte  TRANSPOSE (Channel Coarse Tuning) (0..64 = 64..128 in MIDI)
  C4h     1 byte  PITCH BEND
  C5h     1 byte  PITCH BEND RANGE
  C6h     1 byte  TRACK PRIORITY
  C7h     1 byte  MONO/POLY          (0=Poly, 1=Mono)
  C8h     1 byte  TIE (unknown)      (0=Off, 1=On)
  C9h     1 byte  PORTAMENTO CONTROL
  CAh     1 byte  MODULATION DEPTH   (0=Off, 1=On)
  CBh     1 byte  MODULATION SPEED
  CCh     1 byte  MODULATION TYPE    (0=Pitch, 1=Volume, 2=Pan)
  CDh     1 byte  MODULATION RANGE
  CEh     1 byte  PORTAMENTO ON/OFF
  CFh     1 byte  PORTAMENTO TIME
  D0h     1 byte  ATTACK RATE
  D1h     1 byte  DECAY RATE
  D2h     1 byte  SUSTAIN RATE
  D3h     1 byte  RELEASE RATE
  D4h     1 byte  LOOP START         (how many times to be looped)
  D5h     1 byte  EXPRESSION
  D6h     1 byte  PRINT VARIABLE     (unknown)
  E0h     2 byte  MODULATION DELAY
  E1h     2 byte  TEMPO
  E3h     2 byte  SWEEP PITCH
  FCh     -       LOOP END           (for LOOP START)
  FDh     -       RETURN from CALL command
  FFh     -       EOT: End Of Track
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dssoundfilesssarsoundsequencearchive"></A>
  DS Sound Files - SSAR (Sound Sequence Archive)
</FONT></TD></TR></TABLE><BR>
It is a collection of SSEQ sequences (mainly for relative short sound effects)
(longer sequences like music are usually stored in separate SSEQ files instead
of in SSAR archives).<BR>
<BR>
<B>SSAR Header</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4     ID "SSAR"                                  ;\
  004h 2     Byte Order    (FEFFh)                      ;
  006h 2     Version       (0100h)                      ; Main header
  008h 4     Total Filesize                             ;
  00Ch 2     Header Size (usually 10h)                  ;
  00Eh 2     Number of Blocks (usually 1 = DATA)        ;/
  010h 4     ID "DATA"                                  ;\
  014h 4     Total Filesize, minus 10h                  ;
  018h 4     Offset to data (from SSAR+0) (20h+N*0Ch)   ; Sub header
  01Ch 4     Number of records                          ;
  020h N*0Ch Records (12 bytes each)                    ;/
  ..   ..    data... unknown content? alike SSEQ?       ;-
</TD></TR></TABLE>
<BR>
<B>SSAR Records</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4   nOffset    ;relative offset of the archived SEQ file,
                           absolute offset = nOffset + SSAR::nDataOffset
  004h 2   bnk        ;bank
  006h 1   vol        ;volume
  007h 1   cpr        ;channel pressure
  008h 1   ppr        ;polyphonic pressure
  009h 1   ply        ;play
  00Ah 2   reserved (0)
</TD></TR></TABLE>
<BR>
<B>SSAR Data (addressed via relative offset in above 0Ch-byte record)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  data... unknown content? alike SSEQ?
</TD></TR></TABLE>
<BR>
NB. Archived SSEQ files are not stored in sequence (order). So Rec[0].nOffset
may point to 0x100 but Rec[1].nOffset points to 0x40.<BR>
<BR>
NB. Archived SSEQ files cannot be readily extracted from SSAR file because data
in one SSEQ may 'call' data in other SSEQ.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dssoundfilessbnksoundbank"></A>
  DS Sound Files - SBNK (Sound Bank)
</FONT></TD></TR></TABLE><BR>
This seems to assign ADSR patterns to each note of each SWAV instrument...?<BR>
<BR>
"A bank is linked to up to 4 SWAR files which contain the samples. It defines
the instruments which a SSEQ sequence can use. You may imagine SSEQ + SBNK +
SWAR are similar to module music created by trackers." uh?<BR>
<BR>
<B>SBNK Header</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4   ID "SBNK"                                    ;\
  004h 2   Byte Order    (FEFFh)                        ;
  006h 2   Version       (0100h)                        ; Main header
  008h 4   Total Filesize                               ;
  00Ch 2   Header Size (usually 10h)                    ;
  00Eh 2   Number of Blocks (usually 1 = DATA)          ;/
  010h 4   ID "DATA"                                    ;\
  014h 4   Total Filesize, minus 10h                    ;
  018h 20h Reserved (0) (for use at runtime)            ; Sub header
  038h 4   Number of Instruments (SWAV's)               ;
  03Ch N*4 Instrument Records (1+2+1 bytes per instr.)  ;/
  ...  ..  Instrument Data (depending of above records) ;-
</TD></TR></TABLE>
<BR>
<B>Instrument Record</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 1   fRecord     ;can be either 0, 1..4, 16 or 17
  001h 2   nOffset     ;absolute offset of the data in file  ;uh, misaligned?
  003h 1   Reserved (0)
</TD></TR></TABLE>
<BR>
<B>fRecord = 0, it is empty (unknown purpose, dummy? or maybe disable ADSR?)</B><BR>
nOffset will also = 0.<BR>
<BR>
<B>fRecord &lt; 16, the record is a note/wave definition</B><BR>
"I have seen values 1, 2 and 3. But it seems the value does not affect the
wave/note definition that follows. Instrument record size is 10 bytes."<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h 10    SWAV, SWAR, Note, Attack, Decay, Sustain, Release, Pan
</TD></TR></TABLE>
<BR>
<B>fRecord = 16, the record is a range of note/wave definitions</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h      1   Lower note (0..127)          ;eg. 10 ;\notes 10..20
  01h      1   Upper note (0..127)          ;eg. 20 ;/
  02h+N*12 2   Unknown (usually 0001h)
  04h+N*12 10  SWAV, SWAR, Note, Attack, Decay, Sustain, Release, Pan
</TD></TR></TABLE>
<BR>
<B>fRecord = 17, the record is a regional wave/note definition</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h      1   End of 1st region (0..127)   ;eg. 25  = notes 0..25
  01h      1   End of 2nd region (0..127)   ;eg. 35  = notes 26..35
  02h      1   End of 3rd region (0..127)   ;eg. 45  = notes 36..45
  03h      1   End of 4th region (0..127)   ;eg. 55  = notes 46..55
  04h      1   End of 5th region (0..127)   ;eg. 65  = notes 56..65
  05h      1   End of 6th region (0..127)   ;eg. 127 = notes 66..last
  06h      1   End of 7th region (0..127)   ;eg. 0   = none
  07h      1   End of 8th region (0..127)   ;eg. 0   = none
  08h+N*12 2   Unknown (usually 0001h)
  08h+N*12 10  SWAV, SWAR, Note, Attack, Decay, Sustain, Release, Pan
</TD></TR></TABLE>
REMARKS: Unknown bytes before wave/defnition definition = 5, not 1 in
stage_04_bank.sbnk, stage_04.sdat, Rom No.1156, uh?<BR>
<BR>
<B>SWAV, SWAR, Note, Attack, Decay, Sustain, Release, Pan</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h 2  SWAV Number   the swav used
  02h 2  SWAR Mumber   the swar used (see Info Block --&gt; "BANK Info Entry")
  04h 1  Note Number   (0..127)
  05h 1  Attack Rate   (0..127, 127=fast)
  06h 1  Decay Rate    (0..127, 127=fast)
  07h 1  Sustain Level (0..127, 127=stay at max, no decay)
  08h 1  Release Rate  (0..127, 127=fast)
  09h 1  Pan           (0..127, 64=middle) (uh, what=left, what=right?)
</TD></TR></TABLE>
<BR>
<B>Articulation Data</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
             .                   &lt;-- max level (127)
            / \
           /   \
          /     '---------.      &lt;-- sustain level (0..127)
         /                 \
        /                   \
  -----'---------------------'-- &lt;-- min level (0)
      Attack Decay Sustain Release
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  "The SEQ Player treats 0 as the 100% amplitude value and -92544 (723*128)
  as the 0% amplitude value. The starting ampltitude is 0% (-92544)." uh?
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  "During the attack phase, in each cycle, the SSEQ Player calculates the new
  amplitude value: amplitude value = attack rate * amplitude value / 255. The
  attack phase stops when amplitude reaches 0." THAT IS... NON-LINEAR attack?
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  "During the decay phase, in each cycle, the SSEQ Player calculates the new
  amplitude value: amplitude value = amplitude value - decay rate.
  Note the starting amplitude value is 0. The decay phase stops when
  amplitude reaches sustain level." THAT IS... LINEAR decay/release?
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dssoundfilesswarsoundwavearchive"></A>
  DS Sound Files - SWAR (Sound Wave Archive)
</FONT></TD></TR></TABLE><BR>
It is a collection of mono wave (SWAV) samples only (which can be in either
PCM8, PCM16 or ADPCM compression).<BR>
<BR>
<B>SWAR Header</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4     ID "SWAR"                                  ;\
  004h 2     Byte Order    (FEFFh)                      ;
  006h 2     Version       (0100h)                      ; Main header
  008h 4     Total Filesize (including SWAV's)          ;
  00Ch 2     Header Size (usually 10h)                  ;
  00Eh 2     Number of Blocks (usually 1 = DATA)        ;/
  010h 4     ID "DATA"                                  ;\
  014h 4     Total Filesize, minus 10h                  ;
  018h 20h   Reserved (0) (for use at runtime)          ; Sub header
  038h 4     Number of SWAV sample blocks               ;
  03Ch N*4   Offsets to Sample blocks (from SWAR+0)     ;/
  ..   ..    Sample blocks... starting with Type (0=PCM8, 1=PCM16, 2=IMA-ADPCM)
</TD></TR></TABLE>
When extracting single sample block, one can convert them to SWAV files (by
inserting an 18h-byte SWAV header).<BR>
The sample blocks are usually (always?) stored at increasing offsets (so one
can determine the size by computing the distance to next offset; or to filesize
for last entry) (alternately, the size can be computed by looking at the Sound
Length entry of sample block).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dssoundfilesswavsoundwavedata"></A>
  DS Sound Files - SWAV (Sound Wave Data)
</FONT></TD></TR></TABLE><BR>
<B>SWAV Header (present only in standalone SWAV files) (not in SWAR archives)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4     ID "SWAV"                                  ;\
  004h 2     Byte Order    (FEFFh)                      ;
  006h 2     Version       (0100h)                      ; Main header
  008h 4     Total Filesize                             ;
  00Ch 2     Header Size (usually 10h)                  ;
  00Eh 2     Number of Blocks (usually 1 = DATA)        ;/
  010h 4     ID "DATA"                                  ;\Sub header
  014h 4     Total Filesize, minus 10h                  ;/
  018h ..    Sample block (see below)
</TD></TR></TABLE>
Note: System Flaw has a lot of SWAV files (instead of using SWAR archives).<BR>
<BR>
<B>Sample Block Format (present in SWAV files and SWAR archives)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 1    WaveType (0=PCM8, 1=PCM16, 2=IMA-ADPCM)
  001h 1    Loop flag = TRUE|FALSE   ;uh?
  002h 2    Sampling Rate
  004h 2    Time (ARM7_CLOCK / nSampleRate)
                [ARM7_CLOCK: 33.513982MHz/2 = 1.6756991 E +7]
  006h 2    Loop Offset, in 4-byte units
  008h 4    Sound Length, in 4-byte units (exluding ADPCM header, if any)
  00Ch ...  Data... (samples) (with 32bit header in case of ADPCM)
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dssoundfilesstrmsoundwavestream"></A>
  DS Sound Files - STRM (Sound Wave Stream)
</FONT></TD></TR></TABLE><BR>
It is an individual mono/stereo wave file (PCM8, PCM16 or ADPCM) (eg. used in
Ultimate Spiderman rom:\sound\sound_stream.sdat).<BR>
<BR>
<B>STRM Header</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4     ID "STRM"                                          ;\
  004h 2     Byte Order    (FEFFh)                              ;
  006h 2     Version       (0100h)                              ; Main header
  008h 4     Total Filesize                                     ;
  00Ch 2     Header Size (usually 10h)                          ;
  00Eh 2     Number of Blocks (usually 2 = HEAD+DATA)           ;/
  010h 4     ID "HEAD"                                          ;\
  014h 4     Size of HEAD structure (uh, this is... 50h?)       ;
  018h 1     Type       (0=PCM8, 1=PCM16, 2=IMA-ADPCM)          ; Sub header
  019h 1     Loop flag  (?=TRUE|FALSE)  ;uh?                    ;
  01Ah 1     Channels   (?=What)        ;mono/stereo?           ;
  01Bh 1     Unknown    (always 0)                              ;
  01Ch 2     Sampling Rate (perhaps resampled from original)    ;
  01Eh 2     Time (1.0 / rate * ARM7_CLOCK / 32)                ;
               [ARM7_CLOCK: 33.513982MHz/2 = 1.6756991e7]       ;
  020h 4     Loop Offset (samples)                              ;
  024h 4     Number of Samples                                  ;
  028h 4     Wave Data Offset (always 68h)                      ;
  02Ch 4     Number of Blocks       (per what?)                 ;
  030h 4     Block Length           (per Channel)               ;
  034h 4     Samples Per Block      (per Channel)               ;
  038h 4     Last Block Length      (per Channel)               ;
  03Ch 4     Samples Per Last Block (per Channel)               ;
  040h 20h   Reserved (always 0)                                ;/
  060h 4     ID "DATA"                                          ;\Data header
  064h 4     Data Size (8+N ?)                                  ;/
  068h N     Wave Data blocks...                                ;-Sample data
</TD></TR></TABLE>
Mono blocks are ordered: Block1, Block2, Block3, etc.<BR>
Stereo blocks are ordered: LeftBlock1, RightBlock1, LeftBlock2, etc.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dssystemandbuiltinperipherals"></A>
  DS System and Built-in Peripherals
</FONT></TD></TR></TABLE><BR>
<A HREF="#dsdmatransfers">DS DMA Transfers</A><BR>
<A HREF="#dstimers">DS Timers</A><BR>
<A HREF="#dsinterrupts">DS Interrupts</A><BR>
<A HREF="#dsmaths">DS Maths</A><BR>
<A HREF="#dsinterprocesscommunicationipc">DS Inter Process Communication (IPC)</A><BR>
<A HREF="#dskeypad">DS Keypad</A><BR>
<A HREF="#dsabsentlinkport">DS Absent Link Port</A><BR>
<A HREF="#dsrealtimeclockrtc">DS Real-Time Clock (RTC)</A><BR>
<A HREF="#dsserialperipheralinterfacebusspi">DS Serial Peripheral Interface Bus (SPI)</A><BR>
<A HREF="#dstouchscreencontrollertsc">DS Touch Screen Controller (TSC)</A><BR>
<A HREF="#dspowermanagementdevice">DS Power Management Device</A><BR>
<A HREF="#dspowercontrol">DS Power Control</A><BR>
<A HREF="#dsbackwardscompatiblegbamode">DS Backwards-compatible GBA-Mode</A><BR>
<A HREF="#dsdebugregistersemulatordevkits">DS Debug Registers (Emulator/Devkits)</A><BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dsdmatransfers"></A>
  DS DMA Transfers
</FONT></TD></TR></TABLE><BR>
The DS includes four DMA channels for each CPU (ie. eight channels in total),
which are working more or less the same as on GBA:<BR>
<A HREF="#gbadmatransfers">GBA DMA Transfers</A><BR>
All NDS9 and NDS7 DMA Registers are R/W. The gamepak bit (Bit 27) has been
removed (on the NDS9 the bit is used to expand the mode setting to 3bits).<BR>
<BR>
<B>NDS9 DMA</B><BR>
Word count of all channels is expanded to 21bits (max 1..1FFFFFh units, or
0=200000h units), and SAD/DAD registers for all channels support ranges of
0..0FFFFFFEh. The transfer modes (DMACNT Bit27-29) are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0  Start Immediately
  1  Start at V-Blank
  2  Start at H-Blank (paused during V-Blank)
  3  Synchronize to start of display
  4  Main memory display
  5  DS Cartridge Slot
  6  GBA Cartridge Slot
  7  Geometry Command FIFO
</TD></TR></TABLE>
<BR>
<B>NDS7 DMA</B><BR>
Word Count, SAD, and DAD are R/W, aside from that they do have the same
restrictions as on GBA (max 4000h or 10000h units, some addresses limited to
0..07FFFFFEh). DMACNT Bit27 is unused on NDS7. The transfer modes (DMACNT
Bit28-29) are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0  Start Immediately
  1  Start at V-Blank
  2  DS Cartridge Slot
  3  DMA0/DMA2: Wireless interrupt, DMA1/DMA3: GBA Cartridge Slot
</TD></TR></TABLE>
<BR>
<B>40000E0h - NDS9 only - DMA0FILL - DMA 0 Filldata (R/W)</B><BR>
<B>40000E4h - NDS9 only - DMA1FILL - DMA 1 Filldata (R/W)</B><BR>
<B>40000E8h - NDS9 only - DMA2FILL - DMA 2 Filldata (R/W)</B><BR>
<B>40000ECh - NDS9 only - DMA3FILL - DMA 3 Filldata (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0-31 Filldata
</TD></TR></TABLE>
The DMA Filldata registers contain 16 bytes of general purpose WRAM, intended
to be used as fixed source addresses for DMA memfill operations.<BR>
This is useful because DMA cannot read from TCM, and reading from Main RAM
would require to recurse cache &amp; write buffer.<BR>
The DMA Filldata is used with Src=Fixed and SAD=40000Exh (which isn't optimal
because it's doing repeated reads from SAD, and, for that reason, a memfill via
STMIA opcodes can be faster than DMA; the DSi's new NDMA channels are providing
a faster fill method with Src=Fill and SAD=Unused).<BR>
<BR>
<B>NDS7 Sound DMA</B><BR>
The NDS additionally includes 16 Sound DMA channels, plus 2 Sound Capture DMA
channels (see Sound chapter). The priority of these channels is unknown.<BR>
<BR>
<B>NDS9 Cache, Writebuffer, DTCM, and ITCM</B><BR>
Cache and tightly coupled memory are connected directly to the NDS9 CPU,
without using the system bus. So that, DMA cannot access DTCM/ITCM, and access
to cached memory regions must be handled with care: Drain the writebuffer
before DMA-reads, and invalidate the cache after DMA-writes. See,<BR>
<A HREF="#armcp15systemcontrolcoprocessor">ARM CP15 System Control Coprocessor</A><BR>
The CPU can be kept running during DMA, provided that it is accessing only TCM
(or cached memory), otherwise the CPU is halted until DMA finishes.<BR>
Respectively, interrupts executed during DMA will usually halt the CPU (unless
the IRQ handler uses only TCM and cache; the IRQ vector at FFFF00xxh must be
cached, or relocated to ITCM at 000000xxh, and the IRQ handler may not access
IE, IF, or other I/O ports).<BR>
<BR>
<B>NDS Sequential Main Memory DMA</B><BR>
Main RAM has different access time for sequential and non-sequential access.
Normally DMA uses sequential access (except for the first word), however, if
the source and destination addresses are both in Main RAM, then all accesses
become non-sequential. In that case it would be faster to use two DMA
transfers, one from Main RAM to a scratch buffer in WRAM, and one from WRAM to
Main RAM.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dstimers"></A>
  DS Timers
</FONT></TD></TR></TABLE><BR>
Same as GBA, except F = 33.513982 MHz (for both NDS9 and NDS7).<BR>
<A HREF="#gbatimers">GBA Timers</A><BR>
Both NDS9 and NDS7 have four Timers each, eight Timers in total.<BR>
The NDS sound controller is having its own frequency generators (unlike GBA,
which needed to use Timers to drive channel A/B sounds).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dsinterrupts"></A>
  DS Interrupts
</FONT></TD></TR></TABLE><BR>
<B>4000208h - NDS9/NDS7 - IME - Interrupt Master Enable (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Disable all interrupts  (0=Disable All, 1=See IE register)
  1-31  Not used
</TD></TR></TABLE>
<BR>
<B>4000210h - NDS9/NDS7 - IE - 32bit - Interrupt Enable (R/W)</B><BR>
<B>4000214h - NDS9/NDS7 - IF - 32bit - Interrupt Request Flags (R/W)</B><BR>
Bits in the IE register are 0=Disable, 1=Enable.<BR>
Reading IF returns 0=No request, 1=Interrupt Request.<BR>
Writing IF acts as 0=No change, 1=Acknowledge (clears that bit).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     LCD V-Blank
  1     LCD H-Blank
  2     LCD V-Counter Match
  3     Timer 0 Overflow
  4     Timer 1 Overflow
  5     Timer 2 Overflow
  6     Timer 3 Overflow
  7     NDS7 only: SIO/RCNT/RTC (Real Time Clock)
  8     DMA 0
  9     DMA 1
  10    DMA 2
  11    DMA 3
  12    Keypad
  13    GBA-Slot (external IRQ source) / DSi: None such
  14    Not used                       / DSi9: NDS-Slot Card change?
  15    Not used                       / DSi: dito for 2nd NDS-Slot?
  16    IPC Sync
  17    IPC Send FIFO Empty
  18    IPC Recv FIFO Not Empty
  19    NDS-Slot Game Card Data Transfer Completion
  20    NDS-Slot Game Card IREQ_MC
  21    NDS9 only: Geometry Command FIFO
  22    NDS7 only: Screens unfolding
  23    NDS7 only: SPI bus
  24    NDS7 only: Wifi    / DSi9: XpertTeak DSP
  25    Not used           / DSi9: Camera
  26    Not used           / DSi9: Undoc, IF.26 set on FFh-filling 40021Axh
  27    Not used           / DSi:  Maybe IREQ_MC for 2nd gamecard?
  28    Not used           / DSi: NewDMA0
  29    Not used           / DSi: NewDMA1
  30    Not used           / DSi: NewDMA2
  31    Not used           / DSi: NewDMA3
  ?     DSi7: any further new IRQs on ARM7 side... in bit13-15,21,25-26?
</TD></TR></TABLE>
Raw TCM-only IRQs can be processed even during DMA ?<BR>
Trying to set all IE bits gives FFFFFFFFh (DSi7) or FFFFFF7Fh (DSi9).<BR>
<BR>
<B>4000218h - DSi7 - IE2 - DSi7 Extra Interrupt Enable Bits</B><BR>
<B>400021Ch - DSi7 - IF2 - DSi7 Extra Interrupt Flags</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     DSi7: GPIO18[0]   ;\
  1     DSi7: GPIO18[1]   ; maybe 1.8V signals?
  2     DSi7: GPIO18[2]   ;/
  3     DSi7: Unused (0)
  4     DSi7: GPIO33[0] unknown (related to "GPIO330" testpoint on mainboard?)
  5     DSi7: GPIO33[1] Headphone connect (HP#SP) (static state)
  6     DSi7: GPIO33[2] Powerbutton interrupt (short pulse upon key-down)
  7     DSi7: GPIO33[3] sound enable output (ie. not a useful irq-input)
  8     DSi7: SD/MMC Controller   ;-Onboard eMMC and External SD Slot
  9     DSi7: SD Slot Data1 pin   ;-For SDIO hardware in External SD Slot
  10    DSi7: SDIO Controller     ;\Atheros Wifi Unit
  11    DSi7: SDIO Data1 pin      ;/
  12    DSi7: AES interrupt
  13    DSi7: I2C interrupt
  14    DSi7: Microphone Extended interrupt
  15-31 DSi7: Unused (0)
</TD></TR></TABLE>
Trying to set all IE2 bits gives 00007FF7h (DSi7) or 00000000h (DSi9).<BR>
<BR>
<B>DTCM+3FFCh - NDS9 - IRQ Handler (hardcoded DTCM address)</B><BR>
<B>380FFFCh - NDS7 - IRQ Handler (hardcoded RAM address)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit 0-31  Pointer to IRQ Handler
</TD></TR></TABLE>
NDS7 Handler must use ARM code, NDS9 Handler can be ARM/THUMB (Bit0=Thumb).<BR>
<BR>
<B>DTCM+3FF8h - NDS9 - IRQ Check Bits (hardcoded DTCM address)</B><BR>
<B>380FFF8h - NDS7 - IRQ Check Bits (hardcoded RAM address)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit 0-31  IRQ Flags (same format as IE/IF registers)
</TD></TR></TABLE>
When processing &amp; acknowleding interrupts via IF register, the user
interrupt handler should also set the corresponding bits of the IRQ Check value
(required for BIOS IntrWait and VBlankIntrWait SWI functions).<BR>
<BR>
<B>380FFC0h - DSi7 only - Extra IRQ Check Bits for IE2/IF2 (hardcoded RAM addr)</B><BR>
Same as the above 380FFF8h value, but for new IE2/IF2 registers, intended for
use with IntrWait and VBlankIntrWait functions. However, that functions are
BUGGED on DSi and won't actually work in practice (they do support only the new
380FFC0h bits, but do accidently ignore the old 380FFF8h bits).<BR>
<BR>
--- Below for other (non-IRQ) exceptions ---<BR>
<BR>
<B>27FFD9Ch - RAM - NDS9 Debug Stacktop / Debug Vector (0=None)</B><BR>
<B>380FFDCh - RAM - NDS7 Debug Stacktop / Debug Vector (0=None)</B><BR>
These addresses contain a 32bit pointer to the Debug Handler, and, memory below
of the addresses is used as Debug Stack. The debug handler is called on
undefined instruction exceptions, on data/prefetch aborts (caused by the
protection unit), on FIQ (possibly caused by hardware debuggers). It is also
called by accidental software-jumps to the reset vector, and by unused SWI
numbers within range 0..1Fh.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dsmaths"></A>
  DS Maths
</FONT></TD></TR></TABLE><BR>
<B>4000280h - NDS9 - DIVCNT - Division Control (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-1   Division Mode    (0-2=See below) (3=Reserved; same as Mode 1)
  2-13  Not used
  14    Division by zero (0=Okay, 1=Division by zero error; 64bit Denom=0)
  15    Busy             (0=Ready, 1=Busy) (Execution time see below)
  16-31 Not used
</TD></TR></TABLE>
Division Modes and Busy Execution Times<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Mode  Numer / Denom = Result, Remainder ; Cycles
  0     32bit / 32bit = 32bit , 32bit     ; 18 clks
  1     64bit / 32bit = 64bit , 32bit     ; 34 clks
  2     64bit / 64bit = 64bit , 64bit     ; 34 clks
</TD></TR></TABLE>
Division is started when writing to any of the DIVCNT/NUMER/DENOM registers.<BR>
<BR>
<B>4000290h - NDS9 - DIV_NUMER - 64bit Division Numerator (R/W)</B><BR>
<B>4000298h - NDS9 - DIV_DENOM - 64bit Division Denominator (R/W)</B><BR>
Signed 64bit values (or signed 32bit values in 32bit modes, the upper 32bits
are then unused, with one exception: the DIV0 flag in DIVCNT is set only if the
full 64bit DIV_DENOM value is zero, even in 32bit mode).<BR>
<BR>
<B>40002A0h - NDS9 - DIV_RESULT - 64bit Division Quotient (=Numer/Denom) (R)</B><BR>
<B>40002A8h - NDS9 - DIVREM_RESULT - 64bit Remainder (=Numer MOD Denom) (R)</B><BR>
Signed 64bit values (in 32bit modes, the values are sign-expanded to 64bit).<BR>
<BR>
<B>Division Overflows</B><BR>
Overflows occur on "DIV0" and "-MAX/-1" (eg. -80000000h/-1 in 32bit mode):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  DIV0     --&gt;  REMAIN=NUMER, RESULT=+/-1 (with sign opposite of NUMER)
  -MAX/-1  --&gt;  RESULT=-MAX               (instead +MAX)
</TD></TR></TABLE>
On overflows in 32bit/32bit=32bit mode: the upper 32bit of the sign-expanded
32bit result are inverted. This feature produces a correct 64bit (+MAX) result
in case of the incorrect 32bit (-MAX) result. The feature also applies on DIV0
errors (which makes the sign-expanded 64bit result even more messed-up than the
normal 32bit result).<BR>
The DIV0 flag in DIVCNT.14 indicates DENOM=0 errors (it does not indicate
"-MAX/-1" errors). The DENOM=0 check relies on the full 64bit value (so, in
32bit mode, the flag works only if the unused upper 32bit of DENOM are zero).<BR>
<BR>
<B>40002B0h - NDS9 - SQRTCNT - Square Root Control (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Mode (0=32bit input, 1=64bit input)
  1-14  Not used
  15    Busy (0=Ready, 1=Busy) (Execution time is 13 clks, in either Mode)
  16-31 Not used
</TD></TR></TABLE>
Calculation is started when writing to any of the SQRTCNT/PARAM registers.<BR>
<BR>
<B>40002B4h - NDS9 - SQRT_RESULT - 32bit - Square Root Result (R)</B><BR>
<B>40002B8h - NDS9 - SQRT_PARAM - 64bit - Square Root Parameter Input (R/W)</B><BR>
Unsigned 64bit parameter, and unsigned 32bit result.<BR>
<BR>
<B>IRQ Notes</B><BR>
Push all DIV/SQRT values (parameters and control registers) when using DIV/SQRT
registers on interrupt level, and, after restoring them, be sure to wait until
the busy flag goes off, before leaving the IRQ handler.<BR>
<BR>
<B>BIOS Notes</B><BR>
The NDS9 and NDS7 BIOSes additionally contain software based division and
square root functions, which are NOT using above hardware registers (even the
NDS9 functions are raw software).<BR>
<BR>
<B>Timing Notes</B><BR>
The Div/Sqrt timings are counted in 33.51MHz units. Although the calculations
are quite fast, mind that reading/writing the result/parameter registers takes
up additional clock cycles (especially due to the PENALTY cycle glitch for
non-sequential accesses; parts of that problem can be eventually bypassed by
using sequential STMIA/LDMIA opcodes) (nethertheless, in some cases, software
may be actually faster than the hardware registers; eg. for small 8bit numbers;
that of course NOT by using the BIOS software functions which are endless
inefficient).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dsinterprocesscommunicationipc"></A>
  DS Inter Process Communication (IPC)
</FONT></TD></TR></TABLE><BR>
Allows to exchange status information between ARM7 and ARM9 CPUs.<BR>
The register can be accessed simultaneously by both CPUs (without violating
access permissions, and without generating waitstates at either side).<BR>
<BR>
<B>4000180h - NDS9/NDS7 - IPCSYNC - IPC Synchronize Register (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Dir  Expl.
  0-3   R    Data input from IPCSYNC Bit8-11 of remote CPU (00h..0Fh)
  4-7   -    Not used
  8-11  R/W  Data output to IPCSYNC Bit0-3 of remote CPU   (00h..0Fh)
  12    -    Not used
  13    W    Send IRQ to remote CPU      (0=None, 1=Send IRQ)
  14    R/W  Enable IRQ from remote CPU  (0=Disable, 1=Enable)
  15-31 -    Not used
</TD></TR></TABLE>
<BR>
<B>4000184h - NDS9/NDS7 - IPCFIFOCNT - IPC Fifo Control Register (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Dir  Expl.
  0     R    Send Fifo Empty Status      (0=Not Empty, 1=Empty)
  1     R    Send Fifo Full Status       (0=Not Full, 1=Full)
  2     R/W  Send Fifo Empty IRQ         (0=Disable, 1=Enable)
  3     W    Send Fifo Clear             (0=Nothing, 1=Flush Send Fifo)
  4-7   -    Not used
  8     R    Receive Fifo Empty          (0=Not Empty, 1=Empty)
  9     R    Receive Fifo Full           (0=Not Full, 1=Full)
  10    R/W  Receive Fifo Not Empty IRQ  (0=Disable, 1=Enable)
  11-13 -    Not used
  14    R/W  Error, Read Empty/Send Full (0=No Error, 1=Error/Acknowledge)
  15    R/W  Enable Send/Receive Fifo    (0=Disable, 1=Enable)
  16-31 -    Not used
</TD></TR></TABLE>
<BR>
<B>4000188h - NDS9/NDS7 - IPCFIFOSEND - IPC Send Fifo (W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0-31  Send Fifo Data (max 16 words; 64bytes)
</TD></TR></TABLE>
<BR>
<B>4100000h - NDS9/NDS7 - IPCFIFORECV - IPC Receive Fifo (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit0-31  Receive Fifo Data (max 16 words; 64bytes)
</TD></TR></TABLE>
<BR>
<B>IPCFIFO Notes</B><BR>
When IPCFIFOCNT.15 is disabled: Writes to IPCFIFOSEND are ignored (no data is
stored in the FIFO, the error bit doesn't get set though), and reads from
IPCFIFORECV return the oldest FIFO word (as usually) (but without removing the
word from the FIFO).<BR>
When the Receive FIFO is empty: Reading from IPCFIFORECV returns the most
recently received word (if any), or ZERO (if there was no data, or if the FIFO
was cleared via IPCFIFOCNT.3), and, in either case the error bit gets set.<BR>
The Fifo-IRQs are edge triggered, IF.17 gets set when the condition
"(IPCFIFOCNT.2 AND IPCFIFOCNT.0)" changes from 0-to-1, and IF.18 gets set when
"(IPCFIFOCNT.10 AND NOT IPCFIFOCNT.8)" changes from 0-to-1. The IRQ flags can
be acknowledged even while that conditions are true.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dskeypad"></A>
  DS Keypad
</FONT></TD></TR></TABLE><BR>
For the GBA-buttons: Same as GBA, both ARM7 and ARM9 have keyboard input
registers, and each its own keypad IRQ control register.<BR>
<A HREF="#gbakeypadinput">GBA Keypad Input</A><BR>
<BR>
For Touchscreen (and Microphone) inputs, see<BR>
<A HREF="#dstouchscreencontrollertsc">DS Touch Screen Controller (TSC)</A><BR>
<BR>
<B>4000136h - NDS7 - EXTKEYIN - Key X/Y Input (R)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0      Button X     (0=Pressed, 1=Released)
  1      Button Y     (0=Pressed, 1=Released)
  3      DEBUG button (0=Pressed, 1=Released/None such)
  6      Pen down     (0=Pressed, 1=Released/Disabled) (always 0 in DSi mode)
  7      Hinge/folded (0=Open, 1=Closed)
  2,4,5  Unknown / set
  8..15  Unknown / zero
</TD></TR></TABLE>
The Hinge stuff is a magnetic sensor somewhere underneath of the Start/Select
buttons (NDS) or between A/B/X/Y buttons (DSi), it will be triggered by the
magnet field from the right speaker when the console is closed. The hinge
generates an interrupt request (there seems to be no way to disable this,
unlike as for all other IRQ sources), however, the interrupt execution can be
disabled in IE register (as for other IRQ sources).<BR>
The Pen Down is the /PENIRQ signal from the Touch Screen Controller (TSC), if
it is enabled in the TSC control register, then it will notify the program when
the screen pressed, the program should then read data from the TSC (if there's
no /PENIRQ then doing unneccassary TSC reads would just waste CPU power).
However, the user may release the screen before the program performs the TSC
read, so treat the screen as not pressed if you get invalid TSC values (even if
/PENIRQ was LOW).<BR>
Not sure if the TSC /PENIRQ is actually triggering an IRQ in the NDS?<BR>
The Debug Button should be connected to R03 and GND (on original NDS, R03 is
the large soldering point between the SL1 jumper and the VR1 potentiometer)
(there is no R03 signal visible on the NDS-Lite board).<BR>
Interrupts are reportedly not supported for X,Y buttons.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dsabsentlinkport"></A>
  DS Absent Link Port
</FONT></TD></TR></TABLE><BR>
The DS doesn't have a Serial Link Port Socket, however, internally, the NDS7
contains the complete set of Serial I/O Ports, as contained in the GBA:<BR>
<A HREF="#gbacommunicationports">GBA Communication Ports</A><BR>
<BR>
In GBA mode, the ports are working as on real GBA (as when no cable is
connected). In NDS mode, the ports are even containing some additional bits:<BR>
<BR>
<B>NDS7 SIO Bits (according to an early I/O map from Nintendo)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  NDS7 4000128h SIOCNT   Bit15 "CKUP"  New Bit in NORMAL/MULTI/UART mode (R/W)
  NDS7 4000128h SIOCNT   Bit14 "N/A"   Removed IRQ Bit in UART mode (?)
  NDS7 400012Ah SIOCNT_H Bit14 "TFEMP" New Bit (R/W)
  NDS7 400012Ah SIOCNT_H Bit15 "RFFUL" New Bit (always zero?)
  NDS7 400012Ch SIOSEL   Bit0  "SEL"   New Bit (always zero?)
  NDS7 4000140h JOYCNT   Bit7  "MOD"   New Bit (R/W)
</TD></TR></TABLE>
The "CKUP" bit duplicates the internal clock transfer rate (selected in
SIOCNT.1) (tested in normal mode) (probably works also in multi/uart mode?).<BR>
<BR>
<B>NDS7 DS-Lite 4001080h (W) (?)</B><BR>
DS-Lite Firmware writes FFFFh to this address (prior to accessing SIOCNT), so
it's probably SIO or debugging related (might be as well a bug or so). Reading
from the port always returns 0000h on both DS and DS-Lite.<BR>
<BR>
<B>NDS9 SIO Bits (according to an early I/O map from Nintendo)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  NDS9 4000120h SIODATA32 Bit0-31 Data            (always zero?)
  NDS9 4000128h SIOCNT    Bit2    "TRECV" New Bit (always zero?)
  NDS9 4000128h SIOCNT    Bit3    "TSEND" New Bit (always zero?)
  NDS9 400012Ch SIOSEL    Bit0    "SEL"   New Bit (always zero?)
</TD></TR></TABLE>
Not sure if these ports really exist in the release-version, or if it's been
prototype stuff?<BR>
<BR>
<B>RCNT</B><BR>
RCNT (4000134h) should be set to 80xxh (general purpose mode) before accessing
EXTKEYIN (4000136h) or RTC (4000138h). No idea why (except when using
RTC/SI-interrupt).<BR>
<BR>
<B>DS Serial Port</B><BR>
The SI line is labeled "INT" on the NDS mainboard, it is connected to Pin 1 of
the RTC chip (ie. the /INT interrupt pin).<BR>
I have no idea where to find SO, SC, and SD. I've written a test proggy that
pulsed all four RCNT bits - but all I could find was the SI signal. However,
the BIOS contains some code that uses SIO normal mode transfers (for the debug
version), so at least SI, SO, SC should exist...?<BR>
MAYBE that three signals are somehow replaced by EXTKEYIN bit0,1,3?<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dsrealtimeclockrtc"></A>
  DS Real-Time Clock (RTC)
</FONT></TD></TR></TABLE><BR>
<B>NDS</B><BR>
Seiko Instruments Inc. S-35180 (compatible with S-35190A)<BR>
Miniature 8pin RTC with 3-wire serial bus<BR>
<BR>
<B>DSi</B><BR>
Seiko S-35199A01 (12pin BGA, with some extra functions like FOUT and Alarm
Date)<BR>
<BR>
<B>4000138h - NDS7 - Real Time Clock Register</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit  Expl.
  0    Data I/O   (0=Low, 1=High)
  1    Clock Out  (0=Low, 1=High)
  2    Select Out (0=Low, 1=High/Select)
  4    Data  Direction  (0=Read, 1=Write)
  5    Clock Direction  (should be 1=Write)
  6    Select Direction (should be 1=Write)
  3,8-11   Unused I/O Lines
  7,12-15  Direction for Bit3,8-11 (usually 0)
  16-31    Not used
</TD></TR></TABLE>
<BR>
<B>Serial Transfer Flowchart</B><BR>
Chipselect and Command/Parameter Sequence:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Init CS=LOW and /SCK=HIGH, and wait at least 1us
  Switch CS=HIGH, and wait at least 1us
  Send the Command byte (see bit-transfer below)
  Send/receive Parameter byte(s) associated with the command (see below)
  Switch CS to LOW
</TD></TR></TABLE>
Bit transfer (repeat 8 times per cmd/param byte) (bits transferred LSB first):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Output /SCK=LOW and SIO=databit (when writing), then wait at least 5us
  Output /SCK=HIGH, wait at least 5us, then read SIO=databit (when reading)
  In either direction, data is output on (or immediately after) falling edge.
</TD></TR></TABLE>
Ideally, &lt;both&gt; commands and parameters should be transmitted LSB-first
(unlike the original Seiko document, which recommends LSB-first for data, and
MSB-first for commands) (actually, later Seiko datasheets are going so far to
recommend MSB-first for everything, eg. to use bit-reversed Data=C8h for
Year=13h).<BR>
<BR>
<B>Command Register</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Command Register
    Fwd  Rev
    0    7   Fixed Code (must be 0)
    1    6   Fixed Code (must be 1)
    2    5   Fixed Code (must be 1)
    3    4   Fixed Code (must be 0, or, DSi only: 1=Extended Command)
    4-6  3-1 Command
             Fwd Rev Parameter bytes (read/write access)
             0   0   1 byte, status register 1
             4   1   1 byte, status register 2
             2   2   7 bytes, date &amp; time (year,month,day,day_of_week,hh,mm,ss)
             6   3   3 bytes, time (hh,mm,ss)
             1*  4*  1 byte, int1, frequency duty setting
             1*  4*  3 bytes, int1, alarm time 1 (day_of_week, hour, minute)
             5   5   3 bytes, int2, alarm time 2 (day_of_week, hour, minute)
             3   6   1 byte, clock adjustment register
             7   7   1 byte, free register
             Extended command (when above "fourth bit" was set, DSi only)
             Fwd Rev Parameter bytes (read/write access)
             0   0   3 byte, up counter (msw,mid,lsw) (read only)
             4   1   1 byte, FOUT register setting 1
             2   2   1 byte, FOUT register setting 2
             6   3   reserved
             1   4   3 bytes, alarm date 1 (year,month,day)
             5   5   3 bytes, alarm date 2 (year,month,day)
             3   6   reserved
             7   7   reserved
    7    0   Parameter Read/Write Access (0=Write, 1=Read)
</TD></TR></TABLE>
* INT1: Type and number of parameters depend on INT1 setting in stat reg2.<BR>
The "Fwd" bit numbers and command values for LSB-first command transfers (ie.
both commands and parameters use the same bit-order).<BR>
The "Rev" numbers/values are for MSB-first command transfers (ie. commands
using opposite bit-order than parameters, as being suggested by Seiko).<BR>
<BR>
<B>Control and Status Registers</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Status Register 1
    0   W   Reset                (0=Normal, 1=Reset)
    1   R/W 12/24 hour mode      (0=12 hour, 1=24 hour)
    2-3 R/W General purpose bits
    4   R   Interrupt 1 Flag (1=Yes)                      ;auto-cleared on read
    5   R   Interrupt 2 Flag (1=Yes)                      ;auto-cleared on read
    6   R   Power Low Flag (0=Normal, 1=Power is/was low) ;auto-cleared on read
    7   R   Power Off Flag (0=Normal, 1=Power was off)    ;auto-cleared on read
    Power off indicates that the battery was removed or fully discharged,
    all registers are reset to 00h (or 01h), and must be re-initialized.
  Status Register 2
    0-3 R/W INT1 Mode/Enable
            0000b Disable
            0x01b Selected Frequency steady interrupt
            0x10b Per-minute edge interrupt
            0011b Per-minute steady interrupt 1 (duty 30.0 seconds)
            0100b Alarm 1 interrupt
            0111b Per-minute steady interrupt 2 (duty 0.0079 seconds)
            1xxxb 32kHz output
    4-5 R/W General purpose bits
    6   R/W INT2 Enable
            0b    Disable
            1b    Alarm 2 interrupt
    7   R/W Test Mode (0=Normal, 1=Test, don't use) (cleared on Reset)
  Clock Adjustment Register (to compensate oscillator inaccuracy)
    0-7 R/W Adjustment (00h=Normal, no adjustment)
  Free Register
    0-7 R/W General purpose bits
</TD></TR></TABLE>
<BR>
<B>Date Registers</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Year Register
    0-7 R/W Year     (BCD 00h..99h = 2000..2099)
  Month Register
    0-4 R/W Month    (BCD 01h..12h = January..December)
    5-7 -   Not used (always zero)
  Day Register
    0-5 R/W Day      (BCD 01h..28h,29h,30h,31h, range depending on month/year)
    6-7 -   Not used (always zero)
  Day of Week Register (septenary counter)
    0-2 R/W Day of Week (00h..06h, custom assignment, usually 0=Monday?)
    3-7 -   Not used (always zero)
</TD></TR></TABLE>
<BR>
<B>Time Registers</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Hour Register
    0-5 R/W Hour     (BCD 00h..23h in 24h mode, or 00h..11h in 12h mode)
    6   *   AM/PM    (0=AM before noon, 1=PM after noon)
            * 24h mode: AM/PM flag is read only (PM=1 if hour = 12h..23h)
            * 12h mode: AM/PM flag is read/write-able
            * 12h mode: Observe that 12 o'clock is defined as 00h (not 12h)
    7   -   Not used (always zero)
  Minute Register
    0-6 R/W Minute   (BCD 00h..59h)
    7   -   Not used (always zero)
  Second Register
    0-6 R/W Minute   (BCD 00h..59h)
    7   -   Not used (always zero)
</TD></TR></TABLE>
<BR>
<B>Alarm 1 and Alarm 2 Registers</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Alarm1 and Alarm2 Day of Week Registers (INT1 and INT2 each)
    0-2 R/W Day of Week (00h..06h)
    3-6 -   Not used (always zero)
    7   R/W Compare Enable (0=Alarm every day, 1=Alarm only at specified day)
  Alarm1 and Alarm2 Hour Registers (INT1 and INT2 each)
    0-5 R/W Hour     (BCD 00h..23h in 24h mode, or 00h..11h in 12h mode)
    6   R/W AM/PM    (0=AM, 1=PM) (must be correct even in 24h mode?)
    7   R/W Compare Enable (0=Alarm every hour, 1=Alarm only at specified hour)
  Alarm1 and Alarm2 Minute Registers (INT1 and INT2 each)
    0-6 R/W Minute   (BCD 00h..59h)
    7   R/W Compare Enable (0=Alarm every min, 1=Alarm only at specified min)
  Selected Frequency Steady Interrupt Register (INT1 only) (when Stat2/Bit2=0)
    0   R/W Enable 1Hz Frequency  (0=Disable, 1=Enable)
    1   R/W Enable 2Hz Frequency  (0=Disable, 1=Enable)
    2   R/W Enable 4Hz Frequency  (0=Disable, 1=Enable)
    3   R/W Enable 8Hz Frequency  (0=Disable, 1=Enable)
    4   R/W Enable 16Hz Frequency (0=Disable, 1=Enable)
            The signals are ANDed when two or more frequencies are enabled,
            ie. the /INT signal gets LOW when either of the signals is LOW.
    5-7 R/W General purpose bits
</TD></TR></TABLE>
Note: There is only one register shared as "Selected Frequency Steady
Interrupt" (accessed as single byte parameter when Stat2/Bit2=0) and as "Alarm1
Minute" (accessed as 3rd byte of 3-byte parameter when Stat2/Bit2=1), changing
either value will also change the other value.<BR>
<BR>
<B>Up Counter (DSi only)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Up Counter Msw
    0-7 R   Up Counter bit16-23 (non-BCD, 00h..FFh)
  Up Counter Mid
    0-7 R   Up Counter bit8-15  (non-BCD, 00h..FFh)
  Up Counter Lsw
    0-7 R   Up Counter bit0-7   (non-BCD, 00h..FFh)
</TD></TR></TABLE>
The 24bit Up Counter is incremented when seconds=00h (that is, once per minute;
unless the Time is getting changed by write commands, which may cause some
stuttering). The Up Counter starts at 000000h upon power-up, and, if the
battery lasts that long: wraps from FFFFFFh to 000000h after about 30 years.<BR>
<BR>
<B>Alarm 1 and Alarm 2 Date Registers (DSi only)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Alarm 1 and Alarm 2 Year Register
    0-7 R/W Year     (BCD 00h..99h = 2000..2099)
  Alarm 1 and Alarm 2 Month Register
    0-4 R/W Month    (BCD 01h..12h = January..December)
    5   -   Not used (always zero)
    6   R/W Year Compare Enable (0=Ignore, 1=Enable)
    7   R/W Month Compare Enable (0=Ignore, 1=Enable)
  Alarm 1 and Alarm 2 Day Register
    0-5 R/W Day      (BCD 01h..28h,29h,30h,31h, range depending on month/year)
    6   -   Not used (always zero)
    7   R/W Day Compare Enable (0=Ignore, 1=Enable)
</TD></TR></TABLE>
XXX unspecified if above Alarm Date stuff is really R/W (or write only)<BR>
<BR>
<B>FOUT Register (DSi only)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  FOUT Register Setting 1
    0-7 R/W  Enable bits (bit0=256Hz, bit1=512Hz, ..., bit7=32768Hz)
  FOUT Register Setting 2
    0-7 R/W  Enable bits (bit0=1Hz,   bit1=2Hz, ...,   bit7=128Hz)
  The above sixteen FOUT signals are ANDed when two or more frequencies are
  enabled, ie. the FOUT signal gets LOW when either of the signals is LOW.
</TD></TR></TABLE>
Note: The FOUT pin goes to the DSi's wifi daughterboard: FOUT must be set to
32768Hz (FOUT1=80h, FOUT2=00h), that setting is required for exchanging Atheros
WMI commands/events, the firmware does take care of initializing that setting
(eg. needed after battery removal, or after overwriting the FOUT registers by
software).<BR>
<BR>
<B>Interrupt</B><BR>
There's only one /INT signal, shared for both INT1 and INT2.<BR>
In the NDS, it is connected to the SI-input of the SIO unit (and so, also
shared with SIO interrupts). To enable the interrupt, RCNT should be set to
8144h (Bit14-15=General Purpose mode, Bit8=SI Interrupt Enable, Bit6,2=SI
Output/High).<BR>
The Output/High settings seems to be used as pullup (giving faster reactions on
low-to-high transitions) (nethertheless, in most cases it seems to be also
working okay as Input, ie. with RCNT=8100h).<BR>
The RCNT interrupt is generated on high-to-low transitions on the SI line (but
only if the IRQ is enabled in RCNT.8, and only if RCNT is set to general
purpose mode) (note: changing RCNT.8 from off-to-on does NOT generate IRQs,
even when SI is LOW).<BR>
<BR>
<B>Pin-Outs</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1 /INT      8 VDD
  2 XOUT      7 SIO
  3 XIN       6 /SCK
  4 GND       5 CS
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dsserialperipheralinterfacebusspi"></A>
  DS Serial Peripheral Interface Bus (SPI)
</FONT></TD></TR></TABLE><BR>
<B>Serial Peripheral Interface Bus</B><BR>
SPI Bus is a 4-wire (Data In, Data Out, Clock, and Chipselect) serial bus.<BR>
The NDS supports the following SPI devices (each with its own chipselect).<BR>
<A HREF="#dsfirmwareserialflashmemory">DS Firmware Serial Flash Memory</A><BR>
<A HREF="#dstouchscreencontrollertsc">DS Touch Screen Controller (TSC)</A><BR>
<A HREF="#dspowermanagementdevice">DS Power Management Device</A><BR>
<BR>
<B>40001C0h - NDS7 - SPICNT - SPI Bus Control/Status Register</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-1   Baudrate (0=4MHz/Firmware, 1=2MHz/Touchscr, 2=1MHz/Powerman., 3=512KHz)
  2     DSi: Baudrate MSB   (4=8MHz, 5..7=None/0Hz) (when SCFG_EXT7.bit9=1)
  2     NDS: Not used       (Zero)
  3-6   Not used            (Zero)
  7     Busy Flag           (0=Ready, 1=Busy) (presumably Read-only)
  8-9   Device Select       (0=Powerman., 1=Firmware, 2=Touchscr, 3=Reserved)
  10    Transfer Size       (0=8bit/Normal, 1=16bit/Bugged)
  11    Chipselect Hold     (0=Deselect after transfer, 1=Keep selected)
  12-13 Not used            (Zero)
  14    Interrupt Request   (0=Disable, 1=Enable)
  15    SPI Bus Enable      (0=Disable, 1=Enable)
</TD></TR></TABLE>
The "Hold" flag should be cleared BEFORE transferring the LAST data unit, the
chipselect will be then automatically cleared after the transfer, the program
should issue a WaitByLoop(3) manually AFTER the LAST transfer.<BR>
<BR>
<B>40001C2h - NDS7 - SPIDATA - SPI Bus Data/Strobe Register (R/W)</B><BR>
The SPI transfer is started on writing to this register, so one must
&lt;write&gt; a dummy value (should be zero) even when intending to
&lt;read&gt; from SPI bus.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-7   Data
  8-15  Not used (always zero, even in bugged-16bit mode)
</TD></TR></TABLE>
During transfer, the Busy flag in SPICNT is set, and the written SPIDATA value
is transferred to the device (via output line), simultaneously data is received
(via input line). Upon transfer completion, the Busy flag goes off (with
optional IRQ), and the received value can be then read from SPIDATA, if
desired.<BR>
<BR>
<B>Notes/Glitches</B><BR>
SPICNT Bits 12,13 appear to be unused (always zero), although the BIOS
(attempts to) set Bit13=1, and Bit12=Bit11 when accessing the firmware.<BR>
The SPIDATA register is restricted to 8bit, so that only each 2nd byte will
appear in SPIDATA when attempting to use the bugged-16bit mode.<BR>
<BR>
<B>Cartridge Backup Auxiliar SPI Bus</B><BR>
The NDS Cartridge Slot uses a separate SPI bus (with other I/O Ports), see<BR>
<A HREF="#dscartridgebackup">DS Cartridge Backup</A><BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dstouchscreencontrollertsc"></A>
  DS Touch Screen Controller (TSC)
</FONT></TD></TR></TABLE><BR>
<B>Texas Instruments TSC2046 (NDS)</B><BR>
<B>Asahi Kasei Microsystems AK4148AVT (NDS-Lite)</B><BR>
The Touch Screen Controller (for lower LCD screen) is accessed via SPI bus,<BR>
<A HREF="#dsserialperipheralinterfacebusspi">DS Serial Peripheral Interface Bus (SPI)</A><BR>
<BR>
<B>Control Byte (transferred MSB first)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-1  Power Down Mode Select
  2    Reference Select (0=Differential, 1=Single-Ended)
  3    Conversion Mode  (0=12bit, max CLK=2MHz, 1=8bit, max CLK=3MHz)
  4-6  Channel Select   (0-7, see below)
  7    Start Bit (Must be set to access Control Byte)
</TD></TR></TABLE>
<BR>
<B>Channel</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0 Temperature 0 (requires calibration, step 2.1mV per 1'C accuracy)
  1 Touchscreen Y-Position  (somewhat 0B0h..F20h, or FFFh=released)
  2 Battery Voltage         (not used, connected to GND in NDS, always 000h)
  3 Touchscreen Z1-Position (diagonal position for pressure measurement)
  4 Touchscreen Z2-Position (diagonal position for pressure measurement)
  5 Touchscreen X-Position  (somewhat 100h..ED0h, or 000h=released)
  6 AUX Input               (connected to Microphone in the NDS)
  7 Temperature 1 (difference to Temp 0, without calibration, 2'C accuracy)
</TD></TR></TABLE>
All channels can be accessed in Single-Ended mode.<BR>
In differential mode, only channel 1,3,4,5 (X,Z1,Z2,Y) can be accessed.<BR>
On AK4148AVT, channel 6 (AUX) is split into two separate channels, IN1 and IN2,
separated by Bit2 (Reference Select). IN1 is selected when Bit2=1, IN2 is
selected when Bit2=0 (despite of the Bit2 settings, both IN1 and IN2 are using
single ended more). On the NDS-Lite, IN1 connects to the mircrophone (as on
original NDS), and the new IN2 input is simply wired to VDD3.3 (which is equal
to the external VREF voltage, so IN2 is always FFFh).<BR>
<BR>
<B>Power Down Mode</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Mode /PENIRQ   VREF  ADC   Recommended use
  0    Enabled   Auto  Auto  Differential Mode (Touchscreen, Penirq)
  1    Disabled  Off   On    Single-Ended Mode (Temperature, Microphone)
  2    Enabled   On    Off   Don't use
  3    Disabled  On    On    Don't use
</TD></TR></TABLE>
Allows to enable/disable the /PENIRQ output, the internal reference voltage
(VREF), and the Analogue-Digital Converter.<BR>
For AK4148AVT, Power Down modes are slightly different (among others, /PENIRQ
is enabled in Mode 0..2).<BR>
<BR>
<B>Reference Voltage (VREF)</B><BR>
VREF is used as reference voltage in single ended mode, at 12bit resolution one
ADC step equals to VREF/4096. The TSC generates an internal VREF of 2.5V
(+/-0.05V), however, the NDS uses as external VREF of 3.33V (sinks to 3.31V at
low battery charge), the external VREF is always enabled, no matter if internal
VREF is on or off. Power Down Mode 1 disables the internal VREF, which may
reduce power consumption in single ended mode. After conversion, Power Down
Mode 0 should be restored to re-enable the Penirq signal.<BR>
<BR>
<B>Sending the first Command after Chip-Select</B><BR>
Switch chipselect low, then output the command byte (MSB first).<BR>
<BR>
<B>Reply Data</B><BR>
The following reply data is received (via Input line) after the Command byte
has been transferred: One dummy bit (zero), followed by the 8bit or 12bit
conversion result (MSB first), followed by endless padding (zero).<BR>
Note: The returned ADC value may become unreliable if there are longer delays
between sending the command, and receiving the reply byte(s).<BR>
<BR>
<B>Sending further Commands during/after receiving Reply Data</B><BR>
In general, the Output line should be LOW during the reply period, however,
once when Data bit6 has been received (or anytime later), a new Command can be
invoked (started by sending the HIGH-startbit, ie. Command bit7),
simultaneously, the remaining reply-data bits (bit5..0) can be received.<BR>
In other words, the new command can be output after receiving 3 bits in 8bit
mode (the dummy bit, and data bits 7..6), or after receiving 7 bits in 12bit
mode (the dummy bit, and data bits 11..6).<BR>
In practice, the NDS SPI register always transfers 8 bits at once, so that one
would usually receive 8 bits (rather than above 3 or 7 bits), before outputting
a new command.<BR>
<BR>
<B>Touchscreen Position</B><BR>
Read the X and Y positions in 12bit differential mode, then convert the
touchscreen values (adc) to screen/pixel positions (scr), as such:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  scr.x = (adc.x-adc.x1) * (scr.x2-scr.x1) / (adc.x2-adc.x1) + (scr.x1-1)
  scr.y = (adc.y-adc.y1) * (scr.y2-scr.y1) / (adc.y2-adc.y1) + (scr.y1-1)
</TD></TR></TABLE>
The X1,Y1 and X2,Y2 calibration points are found in Firmware User Settings,<BR>
<A HREF="#dsfirmwareusersettings">DS Firmware User Settings</A><BR>
scr.x1,y1,x2,y2 are originated at 1,1 (converted to 0,0 by above formula).<BR>
<BR>
<B>Touchscreen Pressure (not supported on DSi)</B><BR>
To calculate the pressure resistance, in respect to X/Y/Z positions and X/Y
plate resistances, either of below formulas can be used,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Rtouch = (Rx_plate*Xpos*(Z2pos/Z1pos-1))/4096
  Rtouch = (Rx_plate*Xpos*(4096/Z1pos-1)-Ry_plate*(1-Ypos))/4096
</TD></TR></TABLE>
The second formula requires less CPU load (as it doesn't require to measure
Z2), the downside is that one must know both X and Y plate resistance (or at
least their ratio). The first formula doesn't require that ratio, and so
Rx_plate can be set to any value, setting it to 4096 results in<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  touchval = Xpos*(Z2pos/Z1pos-1)
</TD></TR></TABLE>
Of course, in that case, touchval is just a number, not a resistance in Ohms.<BR>
<BR>
<B>Touchscreen Notes</B><BR>
It may be impossible to press locations close to the screen borders.<BR>
When pressing two or more locations the TSC values will be somewhere in the
middle of these locations.<BR>
The TSC values may be garbage if the screen becomes newly pressed or released,
to avoid invalid inputs: read TSC values at least two times, and ignore BOTH
positions if ONE position was invalid.<BR>
<BR>
<B>Microphone / AUX Channel</B><BR>
Observe that the microphone amplifier is switched off after power up, see:<BR>
<A HREF="#dspowermanagementdevice">DS Power Management Device</A><BR>
<A HREF="#dspowercontrol">DS Power Control</A><BR>
<BR>
<B>Temperature Calculation (not supported on DSi)</B><BR>
TP0 decreases by circa 2.1mV per degree Kelvin. The voltage difference between
TP1 minus TP0 increases by circa 0.39mV (1/2573 V) per degree Kelvin. At
VREF=3.33V, one 12bit ADC step equals to circa 0.8mV (VREF/4096).<BR>
Temperature can be calculated at best resolution when using the current TP0
value, and two calibration values (an ADC value, and the corresponding
temperature in degrees kelvin):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  K = (CAL.TP0-ADC.TP0) * 0.4 + CAL.KELVIN
</TD></TR></TABLE>
Alternately, temperature can be calculated at rather bad resolution, but
without calibration, by using the difference between TP1 and TP0:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  K = (ADC.TP1-ADC.TP0) * 8568 / 4096
</TD></TR></TABLE>
To convert Kelvin to other formats,<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Celsius:     C = (K-273.15)
  Fahrenheit:  F = (K-273.15)*9/5+32
  Reaumur:     R = (K-273.15)*4/5
  Rankine:     X = (K)*9/5
</TD></TR></TABLE>
The Temperature Range for the TSC 2046 chip is -40'C..+85'C (for AK4181AVT only
-20'C..+70'C). According to Nintendo, the DS should not be exposed to "extreme"
heat or cold, the optimal battery charging temperature is specified as
+10'C..+40'C.<BR>
The original firmware does not support temperature calibration, calibration is
supported by nocash firmware (if present). See Extended Settings,<BR>
<A HREF="#dsfirmwareextendedsettings">DS Firmware Extended Settings</A><BR>
<BR>
<B>Pin-Outs</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
         ________
  VCC  1|o       |16 DCLK
  X+   2|        |15 /CS
  Y+   3|  TSC   |14 DIN
  X-   4|  2046  |13 BUSY
  Y-   5|        |12 DOUT
  GND  6|        |11 /PENIRQ
  VBAT 7|        |10 IOVDD
  AUX  8|________|9  VREF
</TD></TR></TABLE>
<BR>
For AK4181AVT, same pins as above, except that IOVDD replaced by the new IN2
input, the pin is wired to VDD3.3 (so IN2 is always equal to VREF, which is
wired to VDD3.3, too) (and AUX is renamed to IN1, and is kept used for MIC
input).<BR>
<BR>
<B>DSi Touchscreen Controller (in NDS mode)</B><BR>
DSi in NDS mode does support only X, Y, and MIC (all other channels do return
FFFh in 12bit mode, and FFh in 8bit mode, ie. no pressure, no temperature, and
no GNDed battery sensor). On DSi, MIC does return data in both single-ended and
differential mode (unlike as on real NDS).<BR>
<BR>
<B>DSi Touchscreen Controller (in DSi mode)</B><BR>
The DSi touchscreen controller supports a NDS backwards compatibility mode.
But, in DSi mode, it is working entirely different (it's still accessed via SPI
bus, but with some new MODE/INDEX values).<BR>
<A HREF="#dsitouchscreensoundcontroller">DSi Touchscreen/Sound Controller</A><BR>
The NDS Touchscreen controller did additionally allow to read Temperature and
Touchscreen Pressure - unknown if the DSi is also supporting such stuff (via
whatever DSi-specific registers).<BR>
The touchscreen hardware can be switched to NDS compatibility mode (for older
games), but unknown how to do that.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dspowercontrol"></A>
  DS Power Control
</FONT></TD></TR></TABLE><BR>
The DS contains several Power Managment functions, some accessed via I/O ports
(described below), and some accessed via SPI bus:<BR>
<A HREF="#dspowermanagementdevice">DS Power Management Device</A><BR>
<BR>
<B>4000304h - NDS9 - POWCNT1 - Graphics Power Control Register (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0     Enable Flag for both LCDs (0=Disable) (Prohibited, see notes)
  1     2D Graphics Engine A      (0=Disable) (Ports 008h-05Fh, Pal 5000000h)
  2     3D Rendering Engine       (0=Disable) (Ports 320h-3FFh)
  3     3D Geometry Engine        (0=Disable) (Ports 400h-6FFh)
  4-8   Not used
  9     2D Graphics Engine B      (0=Disable) (Ports 1008h-105Fh, Pal 5000400h)
  10-14 Not used
  15    Display Swap (0=Send Display A to Lower Screen, 1=To Upper Screen)
  16-31 Not used
</TD></TR></TABLE>
Use SwapBuffers command once after enabling Rendering/Geometry Engine.<BR>
Improper use of Bit0 may damage the hardware?<BR>
When disabled, corresponding Ports become Read-only, corresponding (palette-)
memory becomes read-only-zero-filled.<BR>
<BR>
<B>4000304h - NDS7 - POWCNT2 - Sound/Wifi Power Control Register (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0     Sound Speakers (0=Disable, 1=Enable) (Initial setting = 1)
  1     Wifi           (0=Disable, 1=Enable) (Initial setting = 0)
  2-31  Not used
</TD></TR></TABLE>
Note: Bit0 disables the internal Speaker only, headphones are not disabled.<BR>
Bit1 disables Port 4000206h, and Ports 4800000h-480FFFFh.<BR>
<BR>
<B>4000206h - NDS7 - WIFIWAITCNT - Wifi Waitstate Control</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0-1   WS0 nonsequential time (0-3 = 10, 8, 6, 18 cycles) ;\4800000h-4807FFFh
  2     WS0 sequential time    (0-1 = 6, 4 cycles)         ;/   (used for RAM)
  3-4   WS1 nonsequential time (0-3 = 10, 8, 6, 18 cycles) ;\4808000h-480FFFFh
  5     WS1 sequential time    (0-1 = 10, 4 cycles)        ;/   (used for I/O)
  6-15  Not used (zero)
</TD></TR></TABLE>
This register is initialized by firmware on power-up (set to 0030h, other
software shouldn't change that setting). The timings are per 16bit halfword
access.<BR>
Note: WIFIWAITCNT can be accessed only when enabled in POWCNT2.<BR>
<BR>
<B>4000301h - NDS7 - HALTCNT - Low Power Mode Control (R/W)</B><BR>
In Halt mode, the CPU is paused as long as (IE AND IF)=0.<BR>
In Sleep mode, most of the hardware including sound and video are paused, this
very-low-power mode could be used much like a screensaver.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0-5   Not used (zero)
  6-7   Power Down Mode  (0=No function, 1=Enter GBA Mode, 2=Halt, 3=Sleep)
</TD></TR></TABLE>
The HALTCNT register should not be accessed directly. Instead, the BIOS Halt,
Sleep, CustomHalt, IntrWait, or VBlankIntrWait SWI functions should be used.<BR>
<A HREF="#bioshaltfunctions">BIOS Halt Functions</A><BR>
<A HREF="#armcp15systemcontrolcoprocessor">ARM CP15 System Control Coprocessor</A><BR>
The NDS9 does not have a HALTCNT register, instead, the Halt function uses the
co-processor opcode "mcr p15,0,r0,c7,c0,4" - this opcode locks up if interrupts
are disabled via IME=0 (unlike NDS7 HALTCNT method which doesn't check IME).<BR>
<BR>
<B>4000300h - NDS7/NDS9 - POSTFLG - BYTE - Post Boot Flag (R/W)</B><BR>
The NDS7 and NDS9 post boot flags are usually set upon BIOS/Firmware boot
completion, once when set the reset vector is redirected to the debug handler
of Nintendo's hardware debugger. That allows the NDS7 debugger to capture
accidental jumps to address 0, that appears to be a common problem with
HLL-programmers, asm-coders know that (and why) they should not jump to 0.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit   Expl.
  0     Post Boot Flag (0=Boot in progress, 1=Boot completed)
  1     NDS7: Not used (always zero), NDS9: Bit1 is read-writeable
  2-7   Not used (always zero)
</TD></TR></TABLE>
There are some write-restrictions: The NDS7 register can be written to only
from code executed in BIOS (done by NDS boot ROM, or by DSi firmware, whereas
the DSi firmware is using the CpuSet SWI function to issue the POSTFLG write
from within ROM). Bit0 of both NDS7 and NDS9 registers cannot be cleared
(except by Reset) once when it is set. DSi games seem to run regardless of
POSTFLG, whilst NDS games somewhat refuse to run when POSTFLG=0.<BR>
<BR>
<B>Memory Power Down Functions</B><BR>
<A HREF="#dsmainmemorycontrol">DS Main Memory Control</A><BR>
<A HREF="#dsfirmwareserialflashmemory">DS Firmware Serial Flash Memory</A><BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dspowermanagementdevice"></A>
  DS Power Management Device
</FONT></TD></TR></TABLE><BR>
<B>Power Management Device - Mitsumi 3152A (NDS) / Mitsumi 3205B (NDS-LITE)</B><BR>
The Power Management Device is accessed via SPI bus,<BR>
<A HREF="#dsserialperipheralinterfacebusspi">DS Serial Peripheral Interface Bus (SPI)</A><BR>
To access the device, write the Index Register, then read or write the data
register, and release the chipselect line when finished.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
<B>  Index Register</B>
  Bit0-6 Register Select          (0..3) (0..4 for DS-Lite) (0..7Fh for DSi)
  Bit7   Register Direction       (0=Write, 1=Read)
<B>  Register 0 - Powermanagement Control (R/W)</B>
  Bit0   Sound Amplifier Enable   (0=Disable, 1=Enable)
         (Old-DS:  Disabled: Sound is very silent, but still audible)
         (DS-Lite: Disabled: Sound is NOT audible)
         (DSi in NDS Mode: R/W, but effect is unknown yet)
         (DSi in DSi Mode: Not used, Bit0 is always 1)
  Bit1   Sound Amplifier Mute     (0=Normal, 1=Mute) (Old-DS Only, not DS-Lite)
         (Old-DS:  Muted: Sound is NOT audible, that works only if Bit0=1)
         (DS-Lite: Not used, Bit1 is always zero)
         (DSi in NDS Mode: R/W, but effect is unknown yet)
         (DSi in DSi Mode: R/W, but effect is unknown yet)
  Bit2   Lower Backlight          (0=Disable, 1=Enable)
  Bit3   Upper Backlight          (0=Disable, 1=Enable)
  Bit4   Power LED Blink Enable   (0=Always ON, 1=Blinking OFF/ON)
  Bit5   Power LED Blink Speed    (0=Slow, 1=Fast) (only if Blink enabled)
         (DSi: Power LED Blinking isn't supported, neither in NDS nor DSi mode)
  Bit6   DS System Power          (0=Normal, 1=Shut Down)
  Bit7   Not used                 (always 0)
<B>  Register 1 - Battery Status (R)</B>
  Bit0   Battery Power LED Status (0=Power Good/Green, 1=Power Low/Red)
         (DSi: Usually 0, not tested if it changes upon Power=Low)
  Bit1-7 Not used
<B>  Register 2 - Microphone Amplifier Control (R/W)</B>
  Bit0   Amplifier                (0=Disable, 1=Enable)
  Bit1-7 Not used                 (always 0)
  (DSi in NDS Mode: looks same as NDS, ie. only bit0 is R/W)
  (DSi in DSi Mode: Not used, always FFh)
<B>  Register 3 - Microphone Amplifier Gain Control (R/W)</B>
  Bit0-1 Gain                     (0..3=Gain 20, 40, 80, 160)
  Bit2-7 Not used                 (always 0)
  (DSi in NDS Mode: looks same as NDS, ie. only bit0-1 are R/W)
  (DSi in DSi Mode: Not used, always FFh)
<B>  Register 4 - DS-Lite and DSi Only - Backlight Levels/Power Source (R/W)</B>
  Bit0-1 Backlight Brightness (0..3=Low,Med,High,Max)   (R/W)
         (when bit2+3 are both set, then reading bit0-1 always returns 3)
  Bit2   Force Max Brightness when Bit3=1 (0=No, 1=Yes) (R/W)
  Bit3   External Power Present           (0=No, 1=Yes) (Read-Only)
  Bit4-7 Unknown (Always 4) (Read-Only)
  (DSi in NDS Mode: looks same as in DSi mode)
  (DSi in DSi Mode: Bit0-1 are R/W, but ignored, bit2-3 are always 0)
<B>  Register 10h - DSi Only - Backlight Mirrors &amp; Reset (R/W)</B>
  Bit0   Reset (0=No, 1=Reboot DSi) (same/similar as BPTWL reset feature?)
  Bit1   Unknown (R/W) (note: whatever it is, it isn't warmboot flag)
  Bit2-3 Mirror of Register 0, bit2-3 (backlight enable bits) (R/W)
  Bit4-7 Not used (always 0)
  Bit5   Not used (always 0) - but DSi bootrom sets that bit on boot error?
  (This register works in NDS mode and DSi mode, though it's mainly intended
  for NDS mode, eg. DS Download Play uses the Reset bit to return to DSi menu)
  (note: writing bit2 seems to affect BOTH bit1 and bit2 in register 0)
<B>  Register 1Fh and 20h - DSi Only (?)</B>
  DSi bootrom sets register 1Fh and 20h bit0-4 to value 1Fh on boot error,
  unknown purpose, seems to have no effect, maybe prototype backlight level?
</TD></TR></TABLE>
On Old-DS, registers 4..7Fh are mirrors of 0..3. On DS-Lite, registers 5,6,7
are mirrors of 4, register 8..7Fh are mirrors of 0-7.<BR>
On DSi (in DS mode), index 0,1,2,3,4,10h are used (reads as
0Fh,00h,00h,01h,41h,0Fh - regardless of backlight level, and power source),
index 5..0Fh and 11h..7Fh return 00h (ie. unlike DS and DS-Lite, there are no
mirrors; aside from the mirrored bits in register 10h).<BR>
<BR>
<B>Backlight Dimming / Backlight caused Shut-Down(s)</B><BR>
The above bits are essentially used to switch Backlights on or off. However,
there a number of strange effects. Backlight dimming is possible by pulse width
modulation, ie. by using a timer interrupt to issue pulse widths of N% ON, and
100-N% OFF. Too long pulses are certainly resulting in flickering. Too short
pulses are ignored, the backlights will remain OFF, even if the ON and OFF
pulses are having the same length. Much too short pulses cause the power supply
to shut-down; after changing the backlight state, further changes must not
occur within the next (circa) 2500 clock cycles. The mainboard can be operated
without screens &amp; backlights connected, however, if so, the power supply
will shut-down as soon as backlights are enabled.<BR>
Pulse width modulated dimming does also work on the DS-Lite, allowing to use
smoother fade in/out effects as when using the five "hardware" levels
(Off,Low,Med,High,Max).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dsmainmemorycontrol"></A>
  DS Main Memory Control
</FONT></TD></TR></TABLE><BR>
<B>Main Memory</B><BR>
The DS Main Memory is 2Mx16bit (4MByte), 1.8V Pseudo SRAM (PSRAM); all Dynamic
RAM refresh is handled internally, the chip doesn't require any external
refresh signals, and alltogether behaves like Static RAM. Non-sequential access
time is 70ns, sequential (burst) access time is 12ns.<BR>
<BR>
<B>Main Memory Control</B><BR>
The memory chips contain built-in Control functions, which can be accessed via
Port 27FFFFEh and/or by EXMEMCNT Bit 14. Nintendo is using at least two
different types of memory chips in DS consoles, Fujitsu 82DBS02163C-70L, and ST
M69AB048BL70ZA8, both appear to have different control mechanisms, other chips
(with 8MB size) are used in the semi-professional DS hardware debuggers, and
further chips may be used in future, so using the memory control functions may
lead into compatibitly problems.<BR>
<BR>
<B>Power Consumption / Power Control</B><BR>
Power Consumption during operation (read/write access) is somewhat 30mA, in
standby mode (no read/write access) consumption is reduced to 100uA.<BR>
Furthermore, a number of power-down modes are supported: In "Deep" Power Down
mode the refresh is fully disabled, consumption is 10uA (and all data will be
lost), in "Partial" Power Down modes only fragment of memory is refreshed, for
smallest fragments, consumption goes to down to circa 50uA. The chip cannot be
accessed while it is in Deep or Partial Power Down mode.<BR>
<BR>
<B>Fujitsu 82DBS02163C-70L</B><BR>
The Configuration Register (CR) can be written to by the following sequence:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  LDRH R0,[27FFFFEh]      ;read one value
  STRH R0,[27FFFFEh]      ;write should be same value as above
  STRH R0,[27FFFFEh]      ;write should be same value as above
  STRH R0,[27FFFFEh]      ;write any value
  STRH R0,[27FFFFEh]      ;write any value
  LDRH R0,[2400000h+CR*2] ;read, address-bits are defining new CR value
</TD></TR></TABLE>
Do not access any other Main Memory addresses during above sequence (ie.
disable interrupts, and do not execute the sequence by code located in Main
Memory). The CR value is write-only. The CR bits are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Bit    Expl.
  0-6    Reserved         (Must be 7Fh)
  7      Write Control
           0=WE Single Clock Pulse Control without Write Suspend Function
           1=WE Level Control with Write Suspend Function)
          Burst Read/Single Write is not supported at WE Single Clock Mode.
  8      Reserved         (Must be 1)
  9      Valid Clock Edge (0=Falling Edge, 1=Rising Edge)
  10     Single Write     (0=Burst Read/Burst Write, 1=Burst Read/Single Write)
  11     Burst Sequence   (0=Reserved, 1=Sequential)
  12-14  Read Latency     (1=3 clocks, 2=4 clocks, 3=5 clocks, other=Reserved)
  15     Mode
           0=Synchronous:  Burst Read, Burst Write
           1=Asynchronous: Page Read, Normal Write
          In Mode 1 (Async), only the Partial Size bits are used,
          all other bits, CR bits 0..18, must be "1".
  16-18  Burst Length     (2=8 Words, 3=16Words, 7=Continous, other=Reserved)
  19-20  Partial Size     (0=1MB, 1=512KB, 2=Reserved, 3=Deep/0 bytes)
</TD></TR></TABLE>
The Power Down mode is entered by setting CE2=LOW, this can be probably done by
setting EXMEMCNT Bit14 to zero.<BR>
<BR>
<B>ST Microelectronics M69AB048BL70ZA8</B><BR>
The chip name decodes as PSRAM (M96), Asynchronous (A), 1.8V Burst (B), 2Mx16
(048), Two Chip Enables (B), Low Leakage (L), 70ns (70), Package (ZA),
-30..+85'C (8).<BR>
There are three data sheets for different PSRAM chips available at www.st.com
(unfortunately none for M69AB048BL70ZA8), each using different memory control
mechanisms.<BR>
<BR>
<B>NDS9 BIOS</B><BR>
The NDS9 BIOS contains the following Main Memory initialization code, that
method doesn't match up with any ST (nor Fujitsu) data sheets that I've seen.
At its best, it looks like a strange (and presumably non-functional) mix-up of
different ST control methods.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  STRH 2000h,[4000204h]    ;EXMEMCNT, enable RAM, async mode
  LDRH R0,[27FFFFEh]
  STRH R0,[27FFFFEh]
  STRH R0,[27FFFFEh]
  STRH FFDFh,[27FFFFEh]
  STRH E732h,[27FFFFEh]
  LDRH R0,[27E57FEh]
  STRH 6000h,[4000204h]    ;EXMEMCNT, enable RAM, normal mode
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dsbackwardscompatiblegbamode"></A>
  DS Backwards-compatible GBA-Mode
</FONT></TD></TR></TABLE><BR>
When booting a 32pin GBA cartridge, the NDS is automatically switched into GBA
mode, in that mode all NDS related features are disabled, and the console
behaves (almost) like a GBA.<BR>
<BR>
<B>GBA Features that are NOT supported on NDS in GBA Mode.</B><BR>
Unlike real GBA, the NDS does not support 8bit DMG/CGB cartridges.<BR>
The undocumented Internal Memory Control register (Port 800h) isn't supported,
so the NDS doesn't allow to use 'overclocked' RAM.<BR>
The NDS doesn't have a link-port, so GBA games can be played only in single
player mode, link-port accessories cannot be used, and the NDS cannot run GBA
code via multiboot.<BR>
<BR>
<B>GBA Features that are slightly different on NDS in GBA Mode.</B><BR>
The CPU, Timers, and Sound Frequencies are probably clocked at 16.76MHz;
33.51MHz/2; a bit slower than the original GBA's 16.78MHz clock?<BR>
In the BIOS, a single byte in a formerly 00h-filled area has been changed from
00h to 01h, resulting in SWI 0Dh returning a different BIOS checksum.<BR>
The GBA picture can be shown on upper or lower screen (selectable in
boot-menu), the backlight for the selected screen is always on, resulting in
different colors &amp; much better visibility than original GBA. Unlike GBA-SP,
the NDS doesn't have a backlight-button.<BR>
<BR>
<B>Screen Border in GBA mode</B><BR>
The GBA screen is centered in the middle of the NDS screen. The surrounding
pixels are defined by 32K-color bitmap data in VRAM Block A and B. Each frame,
the GBA picture is captured into one block, and is displayed in the next frame
(while capturing new data to the other block).<BR>
To get a flicker-free border, both blocks should be initialized to contain the
same image before entering GBA mode (usually both are zero-filled, resulting in
a plain black border).<BR>
Note: When using two different borders, the flickering will be irregular - so
there appears to be a frame inserted or skipped once every some seconds in GBA
mode?!<BR>
<BR>
<B>Switching from NDS Mode to GBA Mode</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  --- NDS9: ---
  ZEROFILL VRAM A,B     ;init black screen border (or other color/image)
  POWCNT=8003h          ;enable 2D engine A on upper screen (0003h=lower)
  EXMEMCNT=...          ;set Async Main Memory mode (clear bit14)
  IME=0                 ;disable interrupts
  SWI 06h               ;halt with interrupts disabled (lockdown)
  --- NDS7: ---
  POWERMAN.REG0=09h     ;enable sound amplifier &amp; upper backlight (05h=lower)
  IME=0                 ;disable interrupts
  wait for VCOUNT=200   ;wait until VBlank
  SWI 1Fh with R2=40h   ;enter GBA mode, by CustomHalt(40h)
</TD></TR></TABLE>
After that, the GBA BIOS will be booted, the GBA Intro will be displayed, and
the GBA cartridge (if any) will be started.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dsdebugregistersemulatordevkits"></A>
  DS Debug Registers (Emulator/Devkits)
</FONT></TD></TR></TABLE><BR>
<B>No$gba Emulator Pseudo I/O Ports (no$gba) (GBA,NDS9,NDS7)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4FFFA00h..A0Fh R Emulation ID (16 bytes, eg. "no$gba v2.7", padded with 20h)
  4FFFA10h       W String Out (raw)
  4FFFA14h       W String Out (with %param's)
  4FFFA18h       W String Out (with %param's, plus linefeed)
  4FFFA1Ch       W Char Out (nocash)
  4FFFA20h..A27h R Clock Cycles (64bit)
  4FFFA28h..A3Fh - N/A
</TD></TR></TABLE>
Note: Above ports can be disabled via the "Debug I/O" option in no$gba setup.<BR>
<BR>
<B>Ensata Emulator Pseudo I/O Ports (NDS9)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4000640h (32bit) ;aka CLIPMTX_RESULT (mis-used to invoke detection)
  4000006h (16bit) ;aka VCOUNT (mis-used to get detection result)
  4FFF010h (32bit) ;use to initialize/unlock/reset something
  4FFF000h (8bit)  ;debug message character output (used when Ensata detected)
</TD></TR></TABLE>
The Ensata detection works by mis-using CLIPMTX_RESULT and VCOUNT registers:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  [4000640h]=2468ACE0h      ;CLIPMTX_RESULT (on real hardware it's read-only)
  if ([4000006h] AND 1FFh)=10Eh ;VCOUNT (on real hardware it's 000h..106h)
    [4FFF010h]=13579BDFh        ;\initialize/reset something
    [4FFF010h]=FDB97531h        ;/
    Ensata=true
  else
    Ensata=false
  endif
</TD></TR></TABLE>
Once when a commercial game has detected Ensata, it stops communicating with
the ARM7, and instead it does seem to want to communicate with the Ensata
executable (which has little to do with real NDS hardware). Ie. aside from
"unlocking" port 4FFF000h, it does also "lock" access to the ARM7 hardware
(like sound, touchscreen, RTC, etc).<BR>
<BR>
<B>ISD (Intelligent Systems Debugger or so) I/O Ports</B><BR>
The ISD ports seem to be real (non-emulated) debugging ports, mapped to the GBA
Slot region at 8000000h-9FFFFFFh, and used to output text messages, and
possible also other debugging stuff.<BR>
There are appear to be two variants: nitroemu and cgbemu (the latter appears to
be dating back to old 8bit CGB hardware; which was apparently still used for
the NDS two hardware generations later).<BR>
<BR>
<B>NDS Devkit</B><BR>
In Nintendo's devkit, debug messages are handled in file "os_printf.c", this
file detects the available hardware/software based debug I/O ports, and
redirects the [OS_PutString] vector to the corresponding string_out function
(eg. to OS_PutStringAris for writing a 00h-terminated string to port 4FFF000h).
With some minimal efforts, this could be redirected to the corresponding no$gba
debug I/O ports.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dscartridgesencryptionfirmware"></A>
  DS Cartridges, Encryption, Firmware
</FONT></TD></TR></TABLE><BR>
<B>Cartridges</B><BR>
<A HREF="#dscartridgeheader">DS Cartridge Header</A><BR>
<A HREF="#dscartridgesecurearea">DS Cartridge Secure Area</A><BR>
<A HREF="#dscartridgeicontitle">DS Cartridge Icon/Title</A><BR>
<A HREF="#dscartridgeprotocol">DS Cartridge Protocol</A><BR>
<A HREF="#dscartridgebackup">DS Cartridge Backup</A><BR>
<A HREF="#dscartridgenand">DS Cartridge NAND</A><BR>
<A HREF="#dscartridgeioports">DS Cartridge I/O Ports</A><BR>
<A HREF="#dscartridgenitroromandnitroarcfilesystems">DS Cartridge NitroROM and NitroARC File Systems</A><BR>
<A HREF="#dscartridgeunknowncommands">DS Cartridge Unknown Commands</A><BR>
<A HREF="#dscartridgepassmepassthrough">DS Cartridge PassMe/PassThrough</A><BR>
<A HREF="#dscartridgegbaslot">DS Cartridge GBA Slot</A><BR>
<BR>
<B>Cartridge File Formats</B><BR>
<A HREF="#dsfileformats">DS File Formats</A><BR>
<BR>
<B>Add-Ons</B><BR>
<A HREF="#dscartrumblepak">DS Cart Rumble Pak</A><BR>
<A HREF="#dscartsliderwithrumble">DS Cart Slider with Rumble</A><BR>
<A HREF="#dscartexpansionram">DS Cart Expansion RAM</A><BR>
<A HREF="#dscartinfraredpedometers">DS Cart Infrared/Pedometers</A><BR>
<A HREF="#dscartunknownextras">DS Cart Unknown Extras</A><BR>
<BR>
<B>Special Cartridges</B><BR>
<A HREF="#dscartcheatactionreplayds">DS Cart Cheat Action Replay DS</A><BR>
<A HREF="#dscartcheatcodebreakerds">DS Cart Cheat Codebreaker DS</A><BR>
<A HREF="#dscartdldidriver">DS Cart DLDI Driver</A><BR>
<BR>
<B>Encryption</B><BR>
<A HREF="#dsencryptionbygamecodeidcodekey1">DS Encryption by Gamecode/Idcode (KEY1)</A><BR>
<A HREF="#dsencryptionbyrandomseedkey2">DS Encryption by Random Seed (KEY2)</A><BR>
<BR>
<B>Firmware / Wifi Flash</B><BR>
<A HREF="#dsfirmwareserialflashmemory">DS Firmware Serial Flash Memory</A><BR>
<A HREF="#dsfirmwareheader">DS Firmware Header</A><BR>
<A HREF="#dsfirmwarewificalibrationdata">DS Firmware Wifi Calibration Data</A><BR>
<A HREF="#dsfirmwarewifiinternetaccesspoints">DS Firmware Wifi Internet Access Points</A><BR>
<A HREF="#dsfirmwareusersettings">DS Firmware User Settings</A><BR>
<A HREF="#dsfirmwareextendedsettings">DS Firmware Extended Settings</A><BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dscartridgeheader"></A>
  DS Cartridge Header
</FONT></TD></TR></TABLE><BR>
<B>Header Overview (loaded from ROM Addr 0 to Main RAM 27FFE00h on Power-up)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Address Bytes Expl.
  000h    12    Game Title  (Uppercase ASCII, padded with 00h)
  00Ch    4     Gamecode    (Uppercase ASCII, NTR-&lt;code&gt;)        (0=homebrew)
  010h    2     Makercode   (Uppercase ASCII, eg. "01"=Nintendo) (0=homebrew)
  012h    1     Unitcode    (00h=NDS, 02h=NDS+DSi, 03h=DSi) (bit1=DSi)
  013h    1     Encryption Seed Select (00..07h, usually 00h)
  014h    1     Devicecapacity         (Chipsize = 128KB SHL nn) (eg. 7 = 16MB)
  015h    7     Reserved    (zero filled)
  01Ch    1     Reserved    (zero)                      (except, used on DSi)
  01Dh    1     NDS Region  (00h=Normal, 80h=China, 40h=Korea) (other on DSi)
  01Eh    1     ROM Version (usually 00h)
  01Fh    1     Autostart (Bit2: Skip "Press Button" after Health and Safety)
                (Also skips bootmenu, even in Manual mode &amp; even Start pressed)
  020h    4     ARM9 rom_offset    (4000h and up, align 1000h)
  024h    4     ARM9 entry_address (2000000h..23BFE00h)
  028h    4     ARM9 ram_address   (2000000h..23BFE00h)
  02Ch    4     ARM9 size          (max 3BFE00h) (3839.5KB)
  030h    4     ARM7 rom_offset    (8000h and up)
  034h    4     ARM7 entry_address (2000000h..23BFE00h, or 37F8000h..3807E00h)
  038h    4     ARM7 ram_address   (2000000h..23BFE00h, or 37F8000h..3807E00h)
  03Ch    4     ARM7 size          (max 3BFE00h, or FE00h) (3839.5KB, 63.5KB)
  040h    4     File Name Table (FNT) offset
  044h    4     File Name Table (FNT) size
  048h    4     File Allocation Table (FAT) offset
  04Ch    4     File Allocation Table (FAT) size
  050h    4     File ARM9 overlay_offset
  054h    4     File ARM9 overlay_size
  058h    4     File ARM7 overlay_offset
  05Ch    4     File ARM7 overlay_size
  060h    4     Port 40001A4h setting for normal commands (usually 00586000h)
  064h    4     Port 40001A4h setting for KEY1 commands   (usually 001808F8h)
  068h    4     Icon/Title offset (0=None) (8000h and up)
  06Ch    2     Secure Area Checksum, CRC-16 of [[020h]..00007FFFh]
  06Eh    2     Secure Area Delay (in 131kHz units) (051Eh=10ms or 0D7Eh=26ms)
  070h    4     ARM9 Auto Load List Hook RAM Address (?) ;\endaddr of auto-load
  074h    4     ARM7 Auto Load List Hook RAM Address (?) ;/functions
  078h    8     Secure Area Disable (by encrypted "NmMdOnly") (usually zero)
  080h    4     Total Used ROM size (remaining/unused bytes usually FFh-padded)
  084h    4     ROM Header Size (4000h)
  088h    4     Unknown, some rom_offset, or zero? (DSi: slightly different)
  08Ch    8     Reserved (zero filled; except, [88h..93h] used on DSi)
  094h    2     NAND end of ROM area  ;\in 20000h-byte units (DSi: 80000h-byte)
  096h    2     NAND start of RW area ;/usually both same address (0=None)
  098h    18h   Reserved (zero filled)
  0B0h    10h   Reserved (zero filled; or "DoNotZeroFillMem"=unlaunch fastboot)
  0C0h    9Ch   Nintendo Logo (compressed bitmap, same as in GBA Headers)
  15Ch    2     Nintendo Logo Checksum, CRC-16 of [0C0h-15Bh], fixed CF56h
  15Eh    2     Header Checksum, CRC-16 of [000h-15Dh]
  160h    4     Debug rom_offset   (0=none) (8000h and up)       ;only if debug
  164h    4     Debug size         (0=none) (max 3BFE00h)        ;version with
  168h    4     Debug ram_address  (0=none) (2400000h..27BFE00h) ;SIO and 8MB
  16Ch    4     Reserved (zero filled) (transferred, and stored, but not used)
  170h    90h   Reserved (zero filled) (transferred, but not stored in RAM)
  200h    E00h  Reserved (zero filled) (usually not transferred)
</TD></TR></TABLE>
DSi Cartridges are using an extended cartridge header,<BR>
<A HREF="#dsicartridgeheader">DSi Cartridge Header</A><BR>
Some of that new/changed DSi header entries are important even in NDS mode:<BR>
- On DSi, ARM9/ARM7 areas are restricted to 2.75MB (instead 3.8MB on real NDS)<BR>
- New NDS titles must have RSA signatures (and old titles must be in whitelist)<BR>
<BR>
For more info about CRC-16, see description of GetCRC16 BIOS function,<BR>
<A HREF="#biosmiscfunctions">BIOS Misc Functions</A><BR>
For the Logo checksum, the BIOS verifies only [15Ch]=CF56h, it does NOT verify
the actual data at [0C0h-15Bh] (nor it's checksum), however, the data is
verified by the firmware.<BR>
<BR>
<B>Secure Area Delay</B><BR>
The Secure Area Delay at header[06Eh] is counted in 130.912kHz units (which can
be clocked via one of the hardware timers with prescaler=F/256 and
reload=(10000h-((X AND 3FFFh)+2)); for some weird reason, in case of Header
checksum it's ANDed with 1FFFh instead of 3FFFh). Commonly used values are
X=051Eh (10ms), and X=0D7Eh (26ms).<BR>
The delay is used for all Blowfish encrypted commands, the actual usage/purpose
differs depending on bit31 of the ROM Chip ID:<BR>
When ChipID.Bit31=0 (commands are sent ONCE): The delay is issued BEFORE
sending the command:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Delay,Cmd
</TD></TR></TABLE>
Older/newer games are using delays of 10ms/26ms (although all known existing
cartridges with Bit31=0 would actually work WITHOUT delays).<BR>
When ChipID.Bit31=1 (commands are repeated MULTIPLE times): The delay is issued
AFTER sending the command for the FIRST time:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Cmd,Delay,Cmd                                ;for 2x repeat
  Cmd,Delay,Cmd,Cmd,Cmd,Cmd,Cmd,Cmd,Cmd,Cmd    ;for 9x repeat
</TD></TR></TABLE>
Known games are using delays of 26ms (although all known existing cartridges
(=Cooking Coach) with Bit31=1 would actually work with shorter delays of ca.
7ms (but, better use 8ms for safety)).<BR>
<BR>
<B>NDS Gamecodes</B><BR>
This is the same code as the NTR-UTTD (NDS) or TWL-UTTD (DSi) code which is
printed on the package and sticker on (commercial) cartridges (excluding the
leading "NTR-" or "TWL-" part).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  U  Unique Code          (usually "A", "B", "C", or special meaning)
  TT Short Title          (eg. "PM" for Pac Man)
  D  Destination/Language (usually "J" or "E" or "P" or specific language)
</TD></TR></TABLE>
The first character (U) is usually "A" or "B", in detail:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  A NDS common games
  B NDS common games
  C NDS common games
  D DSi-exclusive games
  H DSiWare (system utilities and browser) (eg. HNGP=browser)
  I NDS and DSi-enhanced games with built-in Infrared port
  K DSiWare (dsiware games and flipnote) (eg. KGUV=flipnote)
  N NDS nintendo channel demo's japan (NTR-NTRJ-JPN)
  T NDS many games
  U NDS and DSi uncommon extra hardware (eg. NAND, ram, microSD, TV, azimuth)
  V DSi-enhanced games
  Y NDS many games
</TD></TR></TABLE>
The second/third characters (TT) are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Usually an abbreviation of the game title (eg. "PM" for "Pac Man") (unless
  that gamecode was already used for another game, then TT is just random)
</TD></TR></TABLE>
The fourth character (D) indicates Destination/Language:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  A Asian    E English/USA  I Italian   M Swedish  Q Danish   U Australian
  B N/A      F French       J Japanese  N Nor      R Russian  V EUR+AUS
  C Chinese  G N/A          K Korean    O Int      S Spanish  W..Z Europe #3..5
  D German   H Dutch        L USA #2    P Europe   T USA+AUS
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dscartridgesecurearea"></A>
  DS Cartridge Secure Area
</FONT></TD></TR></TABLE><BR>
The Secure Area is located in ROM at 4000h..7FFFh, it can contain normal
program code and data, however, it can be used only for ARM9 boot code, it
cannot be used for ARM7 boot code, icon/title, filesystem, or other data.<BR>
<BR>
<B>Secure Area Size</B><BR>
The Secure Area exists if the ARM9 boot code ROM source address (src) is
located within 4000h..7FFFh, if so, it will be loaded (by BIOS via KEY1
encrypted commands) in 4K portions, starting at src, aligned by 1000h, up to
address 7FFFh. The secure area size if thus 8000h-src, regardless of the ARM9
boot code size entry in header.<BR>
Note: The BIOS silently skips any NDS9 bootcode at src&lt;4000h.<BR>
Cartridges with src&gt;=8000h do not have a secure area.<BR>
<BR>
<B>Secure Area ID</B><BR>
The first 8 bytes of the secure area are containing the Secure Area ID, the ID
is required (verified by BIOS boot code), the ID value changes during boot
process:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Value                Expl.
  "encryObj"           raw ID before encryption (raw ROM-image)
  (encrypted)          encrypted ID after encryption (encrypted ROM-image)
  "encryObj"           raw ID after decryption (verified by BIOS boot code)
  E7FFDEFFh,E7FFDEFFh  destroyed ID (overwritten by BIOS after verify)
</TD></TR></TABLE>
If the decrypted ID does match, then the BIOS overwrites the first 8 bytes by
E7FFDEFFh-values (ie. only the ID is destroyed). If the ID doesn't match, then
the first 800h bytes (2K) are overwritten by E7FFDEFFh-values.<BR>
<BR>
<B>Secure Area First 2K Encryption/Content</B><BR>
The first 2K of the Secure Area (if it exists) are KEY1 encrypted. In official
games, this 2K region contains data like so (in decrypted form):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h..007h  Secure Area ID (see above)
  008h..00Dh  Fixed (FFh,DEh,FFh,E7h,FFh,DEh)
  00Eh..00Fh  CRC16 across following 7E0h bytes, ie. [010h..7FFh]
  010h..7FDh  Unknown/random values, mixed with some THUMB SWI calls
  7FEh..7FFh  Fixed (00h,00h)
</TD></TR></TABLE>
Of which, only the ID in the first 8 bytes is verified. Neither BIOS nor
(current) firmare versions are verifying the data at 008h..7FFh, so the 7F8h
bytes may be also used for normal program code/data.<BR>
<BR>
<B>Avoiding Secure Area Encryption</B><BR>
WLAN files are reportedly same format as cartridges, but without Secure Area,
so games with Secure Area cannot be booted via WLAN. No$gba can encrypt and
decrypt Secure Areas only if the NDS BIOS-images are present. And, Nintendo's
devkit doesn't seem to support Secure Area encryption of unreleased games.<BR>
So, unencrypted cartridges are more flexible in use. Ways to avoid encryption
(which still work on real hardware) are:<BR>
1) Set NDS9 ROM offset to 4000h, and leave the first 800h bytes of the Secure
Area 00h-filled, which can be (and will be) safely destroyed during loading;
due to the missing "encryObj" ID; that method is used by Nintendo's devkit.<BR>
2) Set NDS9 ROM offset to 8000h or higher (cartridge has no Secure Area at
all).<BR>
3) Set NDS9 ROM offset, RAM address, and size to zero, set NDS7 ROM offset to
200h, and point both NDS9 and NDS7 entrypoints to the loaded NDS7 region. That
method avoids waste of unused memory at 200h..3FFFh, and it should be
compatible with the NDS console, however, it is not comaptible with commercial
cartridges - which do silently redirect address below 4000h to
"addr=8000h+(addr AND 1FFh)". Still, it should work with inofficial flashcards,
which do not do that redirection. No$gba emulates the redirection for regular
official cartridges, but it disables redirection for homebrew carts if NDS7 rom
offset&lt;8000h, and NDS7 size&gt;0.<BR>
[One possible problem: Newer "anti-passme" firmware versions reportedly check
that the entrypoint isn't set to 80000C0h, that firmwares might also reject
NDS9 entrypoints within the NDS7 bootcode region?]<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dscartridgeicontitle"></A>
  DS Cartridge Icon/Title
</FONT></TD></TR></TABLE><BR>
The ROM offset of the Icon/Title is defined in CartHdr[68h]. The size was
originally implied by the size of the original Icon/Title structure rounded to
200h-byte sector boundary (ie. A00h bytes for Version 1 or 2), however, later
DSi carts are having a size entry at CartHdr[208h] (usually 23C0h).<BR>
If it is present (ie. if CartHdr[68h]=nonzero), then Icon/Title are displayed
in the bootmenu.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0000h 2     Version (0001h, 0002h, 0003h, or 0103h)
  0002h 2     CRC16 across entries 0020h..083Fh (all versions)
  0004h 2     CRC16 across entries 0020h..093Fh (Version 0002h and up)
  0006h 2     CRC16 across entries 0020h..0A3Fh (Version 0003h and up)
  0008h 2     CRC16 across entries 1240h..23BFh (Version 0103h and up)
  000Ah 16h   Reserved (zero-filled)
  0020h 200h  Icon Bitmap  (32x32 pix) (4x4 tiles, 4bit depth) (4x8 bytes/tile)
  0220h 20h   Icon Palette (16 colors, 16bit, range 0000h-7FFFh)
              (Color 0 is transparent, so the 1st palette entry is ignored)
  0240h 100h  Title 0 Japanese  (128 characters, 16bit Unicode)
  0340h 100h  Title 1 English   ("")
  0440h 100h  Title 2 French    ("")
  0540h 100h  Title 3 German    ("")
  0640h 100h  Title 4 Italian   ("")
  0740h 100h  Title 5 Spanish   ("")
  0840h 100h  Title 6 Chinese   ("")                 (Version 0002h and up)
  0940h 100h  Title 7 Korean    ("")                 (Version 0003h and up)
  0A40h 800h  Zerofilled (probably reserved for Title 8..15)
</TD></TR></TABLE>
Below for animated DSi icons only (Version 0103h and up):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1240h 1000h Icon Animation Bitmap 0..7 (200h bytes each, format as above)
  2240h 100h  Icon Animation Palette 0..7 (20h bytes each, format as above)
  2340h 80h   Icon Animation Sequence (16bit tokens)
</TD></TR></TABLE>
Unused/padding bytes:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0840h 1C0h  Unused/padding (FFh-filled) in Version 0001h
  0940h C0h   Unused/padding (FFh-filled) in Version 0002h
  23C0h 40h   Unused/padding (FFh-filled) in Version 0103h
</TD></TR></TABLE>
<BR>
<B>Versions</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0001h = Original
  0002h = With Chinese Title
  0003h = With Chinese+Korean Titles
  0103h = With Chinese+Korean Titles and animated DSi icon
</TD></TR></TABLE>
<BR>
<B>Title Strings</B><BR>
Usually, for non-multilanguage games, the same (english) title is stored in all
title entries. The title may consist of ASCII characters 0020h-007Fh, character
000Ah (linefeed), and should be terminated/padded by 0000h.<BR>
The whole text should not exceed the dimensions of the DS cart field in the
bootmenu (the maximum number of characters differs due to proportional font).<BR>
The title is usually split into a primary title, optional sub-title, and
manufacturer, each separated by 000Ah character(s). For example: "America",
000Ah, "The Axis of War", 000Ah, "Cynicware", 0000h.<BR>
<BR>
<B>Icon Animation Sequence (DSi)</B><BR>
The sequence is represented by 16bit tokens, in the following format:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  15    Flip Vertically   (0=No, 1=Yes)
  14    Flip Horizontally (0=No, 1=Yes)
  13-11 Palette Index     (0..7)
  10-8  Bitmap Index      (0..7)
  7-0   Frame Duration    (01h..FFh) (in 60Hz units)
</TD></TR></TABLE>
Value 0000h indicates the end of the sequence. If the first token is 0000h,
then the non-animated default image is shown.<BR>
Uh, actually, a non-animated icon uses values 01h,00h,00h,01h, followed by 7Ch
zerofilled bytes (ie. 0001h, 0100h, 3Eh x 0000h)?<BR>
<BR>
<B>FAT16:\title\000300tt\4ggggggg\data\banner.sav ;if carthdr[1BFh].bit2=1</B><BR>
Some DSi games are having a separate "banner.sav" file stored in the eMMC
filesystem, enabled via carthdr[1BFh].bit2 (allowing to indicate the game
progress by overriding the default icon). The banner files are 4000h bytes in
size, the animation data is same as above, but without title strings and
without non-animated icon.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0000h 2     Version (0103h)
  0002h 6     Reserved (zero-filled)
  0008h 2     CRC16 across entries 0020h..119Fh (with initial value FFFFh)
  000Ah 16h   Reserved (zero-filled)
  0020h 1000h Icon Animation Bitmap 0..7 (200h bytes each)  ;\same format as
  1020h 100h  Icon Animation Palette 0..7 (20h bytes each)  ; in Icon/Title
  1120h 80h   Icon Animation Sequence (16bit tokens)        ;/
  11A0h 2E60h Garbage (random values, maybe due to eMMC decryption)
</TD></TR></TABLE>
The feature is used by some Brain Age Express games (for example, Brain Age
Express Sudoku: 'title\00030004\4b4e3945\data\banner.sav').<BR>
The feature does probably work only for DSiware titles (unless there are any
DSi carts with SD/MMC access enabled; or unless there is a feature for storing
similar data in cartridge memory).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dscartridgeprotocol"></A>
  DS Cartridge Protocol
</FONT></TD></TR></TABLE><BR>
Communication with Cartridge ROM relies on sending 8 byte commands to the
cartridge, after the sending the command, a data stream can be received from
the cartridge (the length of the data stream isn't fixed, below descriptions
show the default length in brackets, but one may receive more, or less bytes,
if desired).<BR>
<BR>
<B>Cartridge Memory Map</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0000000h-0000FFFh Header (unencrypted)
  0001000h-0003FFFh Not read-able (zero filled in ROM-images)
  0004000h-0007FFFh Secure Area, 16KBytes (first 2Kbytes with extra encryption)
  0008000h-...      Main Data Area
</TD></TR></TABLE>
DSi cartridges are split into a NDS area (as above), and a new DSi area:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  XX00000h XX02FFFh DSi Not read-able (XX00000h=first megabyte after NDS area)
  XX03000h-XX06FFFh DSi ARM9i Secure Area (usually with modcrypt encryption)
  XX07000h-...      DSi Main Data Area
</TD></TR></TABLE>
Cartridge memory must be copied to RAM (the CPU cannot execute code in ROM).<BR>
<BR>
<B>Command Summary, Cmd/Reply-Encryption Type, Default Length</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Command/Params    Expl.                             Cmd  Reply Len
  -- Unencrypted Load --
  9F00000000000000h Dummy (read HIGH-Z bytes)         RAW  RAW   2000h
  0000000000000000h Get Cartridge Header              RAW  RAW   200h DSi:1000h
  00aaaaaaaa000000h Get Cartridge Header (1T-ROM,NAND)RAW  RAW   200h
  9000000000000000h 1st Get ROM Chip ID               RAW  RAW   4
  A000000000000000h Get 3DS encryption type (3DS)     RAW  RAW   4
  00aaaaaaaa000000h Unencrypted Data (debug ver only) RAW  RAW   200h
  3Ciiijjjxkkkkkxxh Activate KEY1 Encryption (NDS)    RAW  RAW   0
  3Diiijjjxkkkkkxxh Activate KEY1 Encryption (DSi)    RAW  RAW   0
  3E00000000000000h Activate 16-byte commands (3DS)   RAW  RAW   0
  -- Secure Area Load --
  4llllmmmnnnkkkkkh Activate KEY2 Encryption Mode     KEY1 FIX   910h+0
  1lllliiijjjkkkkkh 2nd Get ROM Chip ID               KEY1 KEY2  910h+4
  xxxxxxxxxxxxxxxxh Invalid - Get KEY2 Stream XOR 00h KEY1 KEY2  910h+...
  2bbbbiiijjjkkkkkh Get Secure Area Block (4Kbytes)   KEY1 KEY2  910h+10A8h
  6lllliiijjjkkkkkh Optional KEY2 Disable             KEY1 KEY2  910h+?
  Alllliiijjjkkkkkh Enter Main Data Mode              KEY1 KEY2  910h+0
  -- Main Data Load --
  B7aaaaaaaa000000h Encrypted Data Read               KEY2 KEY2  200h
  B800000000000000h 3rd Get ROM Chip ID               KEY2 KEY2  4
  xxxxxxxxxxxxxxxxh Invalid - Get KEY2 Stream XOR 00h KEY2 KEY2  ...
  B500000000000000h Whatever NAND related? (DSi?)     KEY2 KEY2  0
  D600000000000000h Whatever NAND related? (DSi?)     KEY2 KEY2  4
</TD></TR></TABLE>
The parameter digits contained in above commands are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  aaaaaaaa     32bit ROM address (command B7 can access only 8000h and up)
  bbbb         Secure Area Block number (0004h..0007h for addr 4000h..7000h)
  x,xx         Random, not used in further commands (DSi: always zero)
  iii,jjj,llll Random, must be SAME value in further commands
  kkkkk        Random, must be INCREMENTED after FURTHER commands
  mmm,nnn      Random, used as KEY2-encryption seed
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 ____________ Unencrypted Commands (First Part of Boot Procedure) _____________
</TD></TR></TABLE>
<BR>
<B>Cartridge Reset</B><BR>
The /RES Pin switches the cartridge into unencrypted mode. After reset, the
first two commands (9Fh and 00h) are transferred at 4MB/s CLK rate.<BR>
<BR>
<B>9F00000000000000h (2000h) - Dummy</B><BR>
Dummy command send after reset, returns endless stream of HIGH-Z bytes (ie.
usually receiving FFh, immediately after sending the command, the first 1-2
received bytes may be equal to the last command byte).<BR>
<BR>
<B>0000000000000000h (200h) (DSi:1000h) - Get Header (from address 00000000h)</B><BR>
<B>00aaaaaaaa000000h (200h) - DSi Get Header Snippet (from address aaaaaaaah)</B><BR>
Returns RAW unencrypted cartridge header, usually repeated every 1000h bytes.
Some carts allow to read the header with a single 200h-byte or 1000h-byte read,
others require eight separate 200h-byte reads.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  NDS/MROM   --&gt; Read 200h bytes from address 000h
  NDS/1T-ROM --&gt; Read 200h bytes from address 000h
  NDS/NAND   --&gt; Read 200h bytes from address 000h
  DSi/MROM   --&gt; Read 1000h bytes from address 000h
  DSi/1T-ROM --&gt; Read 8x200h bytes from address 000h,200h,400h,..,E00h
  DSi/NAND   --&gt; Read 8x200h bytes from address 000h,200h,400h,..,E00h
</TD></TR></TABLE>
Note: DSi/1T-ROM usually allows to read 1000h bytes or 8x200h, but DSi/NAND
works only when reading 8x200h bytes.<BR>
The Gamecode header entry is used later on to initialize the encryption. Also,
the ROM Control entries define the length of the KEY1 dummy periods (typically
910h clocks), and the CLK transfer rate for further commands (typically faster
than the initial 4MB/s after power up).<BR>
<BR>
<B>9000000000000000h (4) - 1st Get ROM Chip ID</B><BR>
Returns RAW unencrypted Chip ID (eg. C2h,0Fh,00h,00h), repeated every 4 bytes.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1st byte - Manufacturer (eg. C2h=Macronix) (roughly based on JEDEC IDs)
  2nd byte - Chip size (00h..7Fh: (N+1)Mbytes, F0h..FFh: (100h-N)*256Mbytes?)
  3rd byte - Flags (see below)
  4th byte - Flags (see below)
</TD></TR></TABLE>
The Flag Bits in 3th byte can be<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0   Uses Infrared (but via SPI, unrelated to ROM) (also Jam with the Band)
  1   Unknown (set in some 3DS carts)
  2-6 Zero
  7   Unknown (set in Kingdom Hearts - Re-Coded)
</TD></TR></TABLE>
The Flag Bits in 4th byte can be<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-2 Zero
  3   NAND flag (0=ROM, 1=NAND)
  4   3DS Flag  (0=NDS/DSi, 1=3DS)
  5   Unknown   (0=Normal, 1=Support cmd B5h/D6h)
  6   DSi flag  (0=NDS/3DS, 1=DSi) (but also set in NDS Walk with Me)
  7   Cart Protocol Variant (0=old/smaller MROM, 1=new/bigger 1T-ROM or NAND)
</TD></TR></TABLE>
Existing/known ROM IDs are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  C2h,07h,00h,00h NDS Macronix 8MB ROM  (eg. DS Vision, with microSD slot)
  AEh,0Fh,00h,00h NDS Noname   16MB ROM (eg. Meine Tierarztpraxis)
  C2h,0Fh,00h,00h NDS Macronix 16MB ROM (eg. Metroid Demo)
  C2h,1Fh,00h,00h NDS Macronix 32MB ROM (eg. Over the Hedge)
  C2h,1Fh,00h,40h DSi Macronix 32MB ROM (eg. Art Academy, TWL-VAAV, SystemFlaw)
  80h,3Fh,01h,E0h NDS SanDisk  64MB ROM+Infrared (eg. Walk with Me, NTR-IMWP)
  AEh,3Fh,00h,E0h DSi Noname   64MB ROM (eg. de Blob 2, TWL-VD2V)
  C2h,3Fh,00h,00h NDS Macronix 64MB ROM (eg. Ultimate Spiderman)
  C2h,3Fh,00h,40h DSi Macronix 64MB ROM (eg. Crime Lab, NTR-VAOP)
  80h,7Fh,00h,80h NDS SanDisk  128MB ROM (DS Zelda, NTR-AZEP-0)
  80h,7Fh,01h,E0h ?   SanDisk? 128MB ROM+Infrared (P-letter SoulSilver, IPGE)
  C2h,7Fh,00h,80h NDS Macronix 128MB ROM (eg. Spirit Tracks, NTR-BKIP)
  C2h,7Fh,00h,C0h DSi Macronix 128MB ROM (eg. Cooking Coach, TWL-VCKE)
  ECh,7Fh,00h,88h NDS Samsung  128MB NAND (eg. Warioware D.I.Y., NTR-UORE)
  ECh,7Fh,01h,88h NDS Samsung  128MB NAND (eg. Jam with the Band, NTR-UXBP)
  ECh,7Fh,00h,E8h DSi Samsung  128MB NAND (eg. Face Training, TWL-USKV)
  80h,FFh,80h,E0h NDS SanDisk? 256MB ROM (Kingdom Hearts - Re-Coded, NTR-BK9P)
  C2h,FFh,01h,C0h DSi Macronix 256MB ROM+Infrared (eg. P-Letter White)
  C2h,FFh,00h,80h NDS Macronix 256MB ROM (eg. Band Hero, NTR-BGHP)
  C2h,FEh,01h,C0h DSi Macronix 512MB ROM+Infrared (eg. P-Letter White 2)
  C2h,FEh,00h,90h 3DS Macronix probably 512MB? ROM (eg. Sims 3)
  45h,FAh,00h,90h 3DS SanDisk? maybe... 1GB?   ROM (eg. Starfox)
  C2h,F8h,00h,90h 3DS Macronix maybe... 2GB?   ROM (eg. Kid Icarus)
  C2h,7Fh,00h,90h 3DS Macronix 128MB ROM CTR-P-AENJ MMinna no Ennichi
  C2h,FFh,00h,90h 3DS Macronix 256MB ROM CTR-P-AFSJ Pro Yakyuu Famista 2011
  C2h,FEh,00h,90h 3DS Macronix 512MB ROM CTR-P-AFAJ Real 3D Bass FishingFishOn
  C2h,FAh,00h,90h 3DS Macronix 1GB ROM CTR-P-ASUJ Hana to Ikimono Rittai Zukan
  C2h,FAh,02h,90h 3DS Macronix 1GB ROM CTR-P-AGGW Luigis Mansion 2 ASiA CHT
  C2h,F8h,00h,90h 3DS Macronix 2GB ROM CTR-P-ACFJ Castlevania - Lords of Shadow
  C2h,F8h,02h,90h 3DS Macronix 2GB ROM CTR-P-AH4J Monster Hunter 4
  AEh,FAh,00h,90h 3DS Noname?  1GB ROM CTR-P-AGKJ Gyakuten Saiban 5
  AEh,FAh,00h,98h 3DS Noname?  1GB NAND CTR-P-EGDJ Tobidase Doubutsu no Mori
  45h,FAh,00h,90h 3DS SanDisk? 1GB ROM CTR-P-AFLJ Fantasy Life
  45h,F8h,00h,90h 3DS SanDisk? 2GB ROM CTR-P-AVHJ Senran Kagura Burst - Guren
  C2h,F0h,00h,90h 3DS Macronix 4GB ROM CTR-P-ABRJ Biohazard Revelations
  ?,?,?,?         NDS ?        ? (eg. Japanese TV Tuner, NTR-UNSJ)
  00h,00h,00h,00h Cart Reset Busy (Face Training needs 20ms delay after reset)
  FFh,FFh,FFh,FFh None (no cartridge inserted)
</TD></TR></TABLE>
The official JEDEC ID for Samsung would be "CEh", but for some reason,
Samsung's NDS chip does spit out "ECh" as Maker ID. SanDisk has two IDs (80h on
NDS/DSi, and 45h on 3DS).<BR>
<BR>
<B>3Ciiijjjxkkkkkxxh (0) - Activate KEY1 Encryption Mode</B><BR>
The 3Ch command returns endless stream of HIGH-Z bytes, all following commands,
and their return values, are encrypted. The random parameters iii,jjj,kkkkk
must be re-used in further commands; the 20bit kkkkk value is to be incremented
by one after each &lt;further&gt; command (it is &lt;not&gt; incremented after
the 3Ch command).<BR>
<BR>
<B>3Diiijjjxkkkkkxxh (0) - Activate KEY1 Encryption Mode and Unlock DSi Mode</B><BR>
Same as command 3Ch (but with different initial 1048h-byte encryption values),
and works only on DSi carts. Command 3Dh is unlocking two features on DSi
carts:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1) Command 2bbbbiiijjjkkkkkh loads ARM9i secure area (instead of ARM9 area)
  2) Command B7aaaaaaaa000000h allows to read the 'whole' cartridge space
</TD></TR></TABLE>
Without command 3Dh, DSi carts will allow to read only the first some megabytes
(for example, the first 11 Mbyte of the System Flaw cartridge), and the
remaining memory returns mirrors of "addr=8000h+(addr AND 1FFh)").<BR>
Note: After reset, the cartridge protocol allows to send only either one of the
3Ch/3Dh commands (DSi consoles can control the cartridge reset pin, so they can
first send 3Ch and read the normal secure area, then issue a reset and 3Dh and
read the DSi secure area) (on a NDS one could do the same by ejecting/inserting
the cartridge instead of toggling the reset pin).<BR>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 ____________ KEY1 Encrypted Commands (2nd Part of Boot procedure) ____________
</TD></TR></TABLE>
<BR>
<B>4llllmmmnnnkkkkkh (910h) - Activate KEY2 Encryption Mode</B><BR>
KEY1 encrypted command, parameter mmmnnn is used to initialize the KEY2
encryption stream. Returns 910h dummy bytes (which are still subject to old
KEY2 settings; at pre-initialization time, this is fixed: HIGH-Z, C5h, 3Ah,
81h, etc.). The new KEY2 seeds are then applied, and the first KEY2 byte is
then precomputed. The 910h dummy stream is followed by that precomputed byte
value endless repeated (this is the same value as that "underneath" of the
first HIGH-Z dummy-byte of the next command).<BR>
Secure1000h: Returns repeated FFh bytes (instead of the leading C5h, 3Ah, 81h,
etc. stuff).<BR>
Secure1000h: Returns repeated FFh bytes (instead of the repeated precomputed
value).<BR>
<BR>
<B>1lllliiijjjkkkkkh (914h) - 2nd Get ROM Chip ID / Get KEY2 Stream</B><BR>
KEY1 encrypted command. Returns 910h dummy bytes, followed by KEY2 encrypted
Chip ID repeated every 4 bytes, which must be identical as for the 1st Get ID
command. The BIOS randomly executes this command once or twice. Changing the
first command byte to any other value returns an endless KEY2 encrypted stream
of 00h bytes, that is the easiest way to retrieve encryption values and to
bypass the copyprotection.<BR>
<BR>
<B>2bbbbiiijjjkkkkkh (19B8h) - Get Secure Area Block</B><BR>
KEY1 encrypted command. Used to read a secure area block (bbbb in range
0004h..0007h for addr 4000h..7000h) (or, after sending command 3Dh on a DSi:
bbbb in range 0004h..0007h for addr XX03000h..XX06000h).<BR>
Each block is 4K, so it requires four Get Secure Area commands to receive the
whole Secure Area (ROM locations 4000h-7FFFh), the BIOS is reading these blocks
in random order.<BR>
Normally (if the upper bit of the Chip ID is set): Returns 910h dummy bytes,
followed by 200h KEY2 encrypted Secure Area bytes, followed by 18h KEY2
encrypted 00h bytes, then the next 200h KEY2 encrypted Secure Area bytes, again
followed by 18h KEY2 encrypted 00h bytes, and so on. That stream is repeated
every 10C0h bytes (8x200h data bytes, plus 8x18h zero bytes).<BR>
Alternately (if the upper bit of the Chip ID is zero): Returns 910h dummy
bytes, followed by 1000h KEY2 encrypted Secure Area bytes, presumably followed
by 18h bytes, too.<BR>
Aside from above KEY2 encryption (which is done by hardware), the first 2K of
the NDS Secure Area is additionally KEY1 encrypted; which must be resolved
after transfer by software (and the DSi Secure Area is usually modcrypted, as
specified in the cartridge header).<BR>
<BR>
<B>6lllliiijjjkkkkkh (0) - Optional KEY2 Disable</B><BR>
KEY1 encrypted command. Returns 910h dummy bytes (which are still KEY2
affected), followed by endless stream of RAW 00h bytes. KEY2 encryption is
disabled for all following commands.<BR>
This command is send only if firmware[18h] matches encrypted string "enPngOFF",
and ONLY if firmware get_crypt_keys had completed BEFORE completion of secure
area loading, this timing issue may cause unstable results.<BR>
<BR>
<B>Alllliiijjjkkkkkh (910h) - Enter Main Data Mode</B><BR>
KEY1 encrypted command. Returns 910h dummy bytes, followed by endless KEY2
encrypted stream of 00h bytes. All following commands are KEY2 encrypted.<BR>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 ________________ KEY2 Encrypted Commands (Main Data Transfer) ________________
</TD></TR></TABLE>
<BR>
<B>B7aaaaaaaa000000h (200h) - Get Data</B><BR>
KEY2 encrypted command. The desired ROM address is specifed, MSB first, in
parameter bytes (a). Returned data is KEY2 encrypted.<BR>
There is no alignment restriction for the address. However, the datastream
wraps to the begin of the current 4K block when address+length crosses a 4K
boundary (1000h bytes). Special case: SanDisk ROMs are forcefully 200h-byte
aligned, and can merely read max 200h bytes (padded with unencrypted FFh bytes
when trying to read more data).<BR>
The command can be used only for addresses 8000h and up. Addresses 0..7FFFh are
silently redirected to address "8000h+(addr AND 1FFh)". DSi cartridges will
also reject XX00000h..XX06FFFh in the same fashion (and also XX07000h and up if
the DSi cartridge isn't unlocked via command 3Dh).<BR>
Addresses that do exceed the ROM size do mirror to the valid address range
(that includes mirroring non-loadable regions like 0..7FFFh to "8000h+(addr AND
1FFh)"; some newer games are using this behaviour for some kind of anti-piracy
checks).<BR>
<BR>
<B>B800000000000000h (4) - 3rd Get ROM Chip ID</B><BR>
KEY2 encrypted command. Returns KEY2 encrypted Chip ID repeated every 4 bytes.<BR>
<BR>
<B>xxxxxxxxxxxxxxxxh - Invalid Command</B><BR>
Any other command (anything else than above B7h and B8h) in KEY2 command mode
causes communcation failures. The invalid command returns an endless KEY2
encrypted stream of 00h bytes. After the invalid command, the KEY2 stream is
NOT advanced for further command bytes, further commands seems to return KEY2
encrypted 00h bytes, of which, the first returned byte appears to be HIGH-Z.<BR>
Ie. the cartridge seems to have switched back to a state similar to the
KEY1-phase, although it doesn't seem to be possible to send KEY1 commands.<BR>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 ___________________________________ Notes ___________________________________
</TD></TR></TABLE>
<BR>
<B>KEY1 Command Encryption / 910h Dummy Bytes</B><BR>
All KEY1 encrypted commands are followed by 910h dummy byte transfers, these
910h clock cycles are probably used to decrypt the command at the cartridge
side; communication will fail when transferring less than 910h bytes.<BR>
The return values for the dummy transfer are: A single HIGH-Z byte, followed by
90Fh KEY2-encrypted 00h bytes. The KEY2 encryption stream is advanced for all
910h bytes, including for the HIGH-Z byte.<BR>
Note: Current cartridges are using 910h bytes, however, other carts might use
other amounts of dummy bytes, the 910h value can be calculated based on ROM
Control entries in cartridge header. For the KEY1 formulas, see:<BR>
<A HREF="#dsencryptionbygamecodeidcodekey1">DS Encryption by Gamecode/Idcode (KEY1)</A><BR>
<BR>
<B>KEY2 Command/Data Encryption</B><BR>
<A HREF="#dsencryptionbyrandomseedkey2">DS Encryption by Random Seed (KEY2)</A><BR>
<BR>
<B>Cart Protocol Variants (Chip ID.Bit31)</B><BR>
There are two protocol variants for NDS carts, indicated by Bit31 of the ROM
Chip ID (aka bit7 of the 4th ID byte):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1) Chip ID.Bit31=0  Used by older/smaller carts with up to 64MB ROM
  2) Chip ID.Bit31=1  Used by newer/bigger carts with 64MB or more ROM
</TD></TR></TABLE>
The first variant (for older carts) is described above. The second second
variant includes some differences for KEY1 encrypted commands:<BR>
GAPS: The commands have the same 910h-cycle gaps, but without outputting CLK
pulses during those gaps (ie. used with ROMCTRL.Bit28=0) (the absence of the
CLKs implies that there is no dummy data transferred during gaps, and
accordingly, that the KEY2 stream isn't advanced during the 910h gap cycles).<BR>
REPEATED COMMANDS and SECURE AREA DELAY: All KEY1 encrypted commands must be
sent TWICE (or even NINE times). First, send the command with 0-byte Data
transfer length. Second, issue the Secure Area Delay (required; use the delay
specified in cart header[06Eh]).<BR>
Third, send the command once again with 0-byte or 4-byte data transfer length
(usually 0 bytes, or 4-bytes for Chip ID command), or sent it eight times with
200h-byte data transfer length (for the 1000h-byte secure area load command).<BR>
For those repeats, always resend exactly the same command (namely, kkkkk is NOT
incremented during repeats, and there is no extra index needed to select
200h-byte portions within 1000h-byte blocks; the cartridge is automatically
outputting the eight portions one after another).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dscartridgebackup"></A>
  DS Cartridge Backup
</FONT></TD></TR></TABLE><BR>
<B>SPI Bus Backup Memory</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Type   Total Size  Page Size  Chip/Example      Game/Example
  EEPROM 0.5K bytes   16 bytes  ST M95040-W       (eg. Metroid Demo)
  EEPROM   8K bytes   32 bytes  ST M95640-W       (eg. Super Mario DS)
  EEPROM  64K bytes  128 bytes  ST M95512-W       (eg. Downhill Jam)
  EEPROM 128K bytes    ? bytes  ?                 (eg. Explorers of Sky)
  FLASH  256K bytes  256 bytes  ST M45PE20        (eg. Skateland)
  FLASH  256K bytes             Sanyo LE25FW203T  (eg. Mariokart)
  FLASH  512K bytes  256 bytes  ST M25PE40?       (eg. which/any games?)
  FLASH  512K bytes             ST 45PE40V6       (eg. DS Zelda, NTR-AZEP-0)
  FLASH 1024K bytes             ST 45PE80V6       (eg. Spirit Tracks, NTR-BKIP)
  FLASH 8192K bytes             MX25L6445EZNI-10G (Art Academy only, TWL-VAAV)
  FRAM     8K bytes   No limit  ?                 (eg. which/any games?)
  FRAM    32K bytes   No limit  Ramtron FM25L256? (eg. which/any games?)
</TD></TR></TABLE>
<BR>
<B>Lifetime Stats (might vary per manufacturer)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Type      Max Writes per Page    Data Retention
  EEPROM    100,000                40 years
  FLASH     100,000                20 years
  FRAM      No limit               10 years
</TD></TR></TABLE>
<BR>
SPI Bus Backup Memory is accessed via Ports 40001A0h and 40001A2h, see<BR>
<A HREF="#dscartridgeioports">DS Cartridge I/O Ports</A><BR>
<BR>
<B>Commands</B><BR>
For all EEPROM and FRAM types:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  06h WREN  Write Enable                Cmd, no parameters
  04h WRDI  Write Disable               Cmd, no parameters
  05h RDSR  Read Status Register        Cmd, read repeated status value(s)
  01h WRSR  Write Status Register       Cmd, write one-byte value
  9Fh RDID  Read JEDEC ID (not supported on EEPROM/FLASH, returns FFh-bytes)
</TD></TR></TABLE>
For 0.5K EEPROM (8+1bit Address):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  03h RDLO  Read from Memory 000h-0FFh  Cmd, addr lsb, read byte(s)
  0Bh RDHI  Read from Memory 100h-1FFh  Cmd, addr lsb, read byte(s)
  02h WRLO  Write to Memory 000h-0FFh   Cmd, addr lsb, write 1..MAX byte(s)
  0Ah WRHI  Write to Memory 100h-1FFh   Cmd, addr lsb, write 1..MAX byte(s)
</TD></TR></TABLE>
For 8K..64K EEPROM and for FRAM (16bit Address):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  03h RD    Read from Memory            Cmd, addr msb,lsb, read byte(s)
  02h WR    Write to Memory             Cmd, addr msb,lsb, write 1..MAX byte(s)
</TD></TR></TABLE>
For 128K EEPROM (24bit Address):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  As above, but with 24bit addr msb,mid,lsb ?
</TD></TR></TABLE>
Note: MAX = Page Size (see above chip list) (no limit for FRAM).<BR>
<BR>
For FLASH backup, commands should be same as for Firmware FLASH memory:<BR>
<A HREF="#dsfirmwareserialflashmemory">DS Firmware Serial Flash Memory</A><BR>
A few NDS/DSi carts are sharing the SPI bus for FLASH and Infrared, this
requires a 00h-prefix byte for FLASH access, with slower 1MHz SPI clock and
delays, see:<BR>
<A HREF="#dscartinfraredpedometers">DS Cart Infrared/Pedometers</A><BR>
<BR>
<B>Status Register</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0   WIP  Write in Progress (1=Busy) (Read only) (always 0 for FRAM chips)
  1   WEL  Write Enable Latch (1=Enable) (Read only, except by WREN,WRDI)
  2-3 WP   Write Protect (0=None, 1=Upper quarter, 2=Upper Half, 3=All memory)
</TD></TR></TABLE>
For 0.5K EEPROM:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4-7 ONEs Not used (all four bits are always set to "1" each)
</TD></TR></TABLE>
For 8K..64K EEPROM and for FRAM:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4-6 ZERO Not used (all three bits are always set to "0" each)
  7   SRWD Status Register Write Disable (0=Normal, 1=Lock) (Only if /W=LOW)
</TD></TR></TABLE>
WEL gets reset on Power-up, WRDI, WRSR, WRITE/LO/HI, and on /W=LOW.<BR>
The WRSR command allows to change ONLY the two WP bits, and the SRWD bit (if
any), these bits are non-volatile (remain intact during power-down),
respectively, the WIP bit must be checked to sense WRSR completion.<BR>
<BR>
<B>Detection (by examining hardware responses)</B><BR>
The overall memory type and bus-width can be detected by RDSR/RDID commands:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  RDSR  RDID          Type         (bus-width)
  FFh,  FFh,FFh,FFh   None         (none)
  F0h,  FFh,FFh,FFh   EEPROM       (with 8+1bit address bus)
  00h,  FFh,FFh,FFh   EEPROM/FRAM  (with 16bit address bus)
  ?     ?,?,?         EEPROM       (with 24bit address bus)
  00h,  xxh,xxh,xxh   FLASH        (usually with 24bit address bus)
</TD></TR></TABLE>
And, the RD commands can be used to detect the memory size/mirrors (though that
won't work if the memory is empty).<BR>
<BR>
<B>Detection (in emulators)</B><BR>
Nintendo is using different functions for sending cmd+addr and data. The
bus-width can be detected by counting the bytes transferred with same program
counter after chip selection. One could also try to examine code/data in the
ROM-image (but that may envolve self-decompressing code and other obstacles).<BR>
Special cases:<BR>
Over the Hedge does initially try to access 8Kbyte EEPROM, but does actually
use 0.5Kbyte EEPROM (as workaround: re-detect the bus-width on each transfer).<BR>
Rune Factory - A Fantasy Harvest Moon seems to be also difficult to detect (as
workaround: force 64Kbyte EEPROM on gamecode ARFx).<BR>
FLASH has same 24bit bus-width as 128Kbyte EEPROM, but isn't compatible on
writing. EEPROM does use 02h=Write+Erase. FLASH does use 0Ah=Write+Erase (or
D8h/DBh=Erase and 02h=Write separatly).<BR>
<BR>
<B>Pin-Outs for EEPROM and FRAM chips</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Pin Name Expl.
  1  /S    Chip Select
  2  Q     Data Out
  3  /W    Write-Protect (not used in NDS, wired to VCC)
  4  VSS   Ground
  5  D     Data In
  6  C     Clock
  7  /HOLD Transfer-pause (not used in NDS, wired to VCC)
  8  VCC   Supply 2.5 to 5.5V for M95xx0-W
</TD></TR></TABLE>
<BR>
FRAM (Ferroelectric Nonvolatile RAM) is fully backwards compatible with normal
EEPROMs, but comes up with faster write/erase time (no delays), and with lower
power consumption, and unlimited number of write/erase cycles. Unlike as for
normal RAM, as far as I understand, the data remains intact without needing any
battery.<BR>
<BR>
<B>Other special save memory</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  DS Vision (NDS cart with microSD slot... and maybe ALSO with EEPROM?)
  NAND carts can store data in a read/write-able portion of the "ROM" chip
  Typing Adventure does have SPI FLASH (but not directly wired to SPI bus)
</TD></TR></TABLE>
<BR>
<B>DSi Internal eMMC and External SD Card</B><BR>
DSi cartridges are usually (maybe always) having SD/MMC access disabled, so
they must stick using EEPROM/FLASH chips inside of the cartridges (which is
required for NDS compatibility anyways).<BR>
However, DSiware games (downloaded from DSi Shop) are allowed to save data on
eMMC, using "private.sav" or "public.sav" files in their data folder. The size
of that files is preset in cartridge header.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dscartridgenand"></A>
  DS Cartridge NAND
</FONT></TD></TR></TABLE><BR>
SLC-NAND is used in at least three NDS/DSi games. The ROM Chip ID has bit3 in
4th byte set.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  ECh,7Fh,00h,88h NDS Samsung  128MB NAND (eg. Warioware D.I.Y., NTR-UORE)
  ECh,7Fh,01h,88h NDS Samsung  128MB NAND (eg. Jam with the Band, NTR-UXBP)
  ECh,7Fh,00h,E8h DSi Samsung  128MB NAND (eg. Face Training, TWL-USKV)
</TD></TR></TABLE>
In the cart header, the 1st byte of the Gamecode is "U" (that "U" is also used
for a few other carts with "uncommon" hardware), and header entries [094h,096h]
indicate the end of the ROM region and start of RW region (in 128Kbyte units
for NDS, or 512Kbyte units for DSi; exception: the oldest NAND title (japanese
version of Jam with the Band) did have [094h,096h] set to all zeroes). The
chips are all 128MByte (122MByte usable), with memory map as so:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00000000h  ROM region (one large region)                                  (R)
  0xxx0000h  RW region (split into several 128KByte blocks)               (R/W)
  07A00000h  Reserved region                                                (R)
</TD></TR></TABLE>
The RW space is 8MB for Jam with the Band, 16MB for WarioWare DIY, and 82MB in
Face Training. Unknown if some of the cart memory is reserved for broken sector
handling.<BR>
<BR>
<B>DS Cartridges with NAND memory</B><BR>
NAND memory contains both the game and save memory (normal NDS games contain
separate ROM and SPI FLASH/EEPROM chips for that purposes). The advantage is
that NAND allows more storage than the usual FLASH chips. Nintendo also claims
SLC-NAND to be very fast, but that's only half true (it's much slower than
MROM, but might be slightly faster than SPI FLASH).<BR>
<BR>
<B>Command Summary</B><BR>
For whatever reason, random access is slightly restricted: One must use command
8Bh/B2h to select ROM region or a 128KByte RW window before reading/writing the
selected area. Writing is done in 2Kbyte units (4x200h bytes).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 In ROM access mode:
  9400000000000000h Len=200h  NAND Read ID
  B2aaaaaaaa000000h Len=0     NAND Select 128Kbyte RW access mode
  B300000000000000h Len=04h   Unknown (returns 00000000h)
  BB00000000000000h Len=200h  Unknown (returns 1X 04 09 20 04, plus zeroes)
 In RW access mode (on DSi carts, this works ONLY in DSi mode):
  81aaaaaaaa000000h Len=200h  NAND Write to Write Buffer (must be issued 4x)
  8200000000000000h Len=0     NAND Forward Write Buffer to NAND
  8400000000000000h Len=0     NAND Discard Write Buffer
  8500000000000000h Len=0     NAND Write Enable
  8600000000000000h Len=0     Unknown
  8700000000000000h Len=0     NAND Write Disable
  8B00000000000000h Len=0     NAND Select ROM access mode
 In either mode:
  0B00000000000000h Len=200h  Returns cart header[000h..1FFh]
  0C00000000000000h Len=200h  Returns corrupted cart header[1F8h..3F7h] ??
  58h..5Fh          Len=0     Unknown (looks same/similar as in 1T-ROM carts)
  60h..68h          Len=800h  Unknown (looks same/similar as in 1T-ROM carts)
  B000000000000000h Len=04h   Unknown (returns 01010101h)
  B500000000000000h Len=0     Unknown (looks same/similar as in SanDisk carts)
  B7aaaaaaaa000000h Len=200h  NAND Read from ROM or RW area
  B800000000000000h Len=04h   Read Chip ID
  D600000000000000h Len=04h   NAND Read Status
 Further command(s) spotted in Face Training disassembly:
  8800000000000000h Len=0     Unknown (is in disassembly, but fails on HW?)
</TD></TR></TABLE>
<BR>
<B>81aaaaaaaa000000h - NAND Write to Write Buffer + Data[200h]</B><BR>
The command must be issued 4 times with the same address (seems to use the
address from the first command), a full write is 800h bytes (4x200h), the chip
won't respond to other commands until all 4 commands are sent. Unknown what
happens when trying to send more than 4 commands.<BR>
This command doesn't directly write to NAND, instead it stores the incoming
data in a 800h-byte write buffer (latter committed using command 82h).<BR>
The provided address needs to be within the access window specified by command
B2h.<BR>
<BR>
<B>8200000000000000h - NAND Forward Write Buffer to NAND</B><BR>
The data in the 800h-byte write buffer is written to the actual NAND, and the
write-enable bit in the status register is cleared.<BR>
<BR>
<B>8400000000000000h - NAND Discard Write Buffer</B><BR>
The data in the write buffer is discarded (a subsequent command 82h would have
no effect).<BR>
Games seem to always use this after command 82h, so maybe it's required even
after a write.<BR>
<BR>
<B>8500000000000000h - NAND Write Enable</B><BR>
The write-enable bit in the status register is set.<BR>
Only works in RW access mode.<BR>
<BR>
<B>8B00000000000000h - NAND Select ROM access mode</B><BR>
Switch to ROM access mode.<BR>
<BR>
<B>B2aaaaaaaa000000h - NAND Select 128Kbyte RW access mode</B><BR>
The provided address defines an accessible 128K window in RW address space,
reads and writes may only take place within that window, the lower 17 bits of
the address are ignored.<BR>
Addresses below start of RW area are ignored (the cart stays in ROM mode, and
the cart does then reportedly get stuck permanently busy).<BR>
Addresses that go past the end of the RW address space will just read all FF's.<BR>
<BR>
<B>B7aaaaaaaa000000h - NAND Read from ROM or RW area + Data[200h]</B><BR>
This command is used for reading data under both ROM and RW modes.<BR>
In ROM mode: returns data from the ROM space, pretty much like the 'regular' B7
command, trying to read from RW space in this mode will return all FF's.<BR>
In RW mode: returns data from the RW space, the provided address needs to be
within the access window specified by command B2h.<BR>
<BR>
<B>D600000000000000h - NAND Read Status + Data[4]</B><BR>
Status register bits:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-1   Unknown (usually zero)
  2-3   Unknown (usually zero, but tested by DSi Launcher, not NAND related?)
  4     NAND write enable
  5     NAND status (0=busy, 1=ready)
  6     Unknown (usually zero, but set by DeSmuME)
  7     Unknown (possible error flag?)
  8-15  Same as bit0-7
  16-23 Same as bit0-7
  24-31 Same as bit0-7
</TD></TR></TABLE>
Value on startup is 20h (aka 20202020h when reading 4 bytes).<BR>
<BR>
<B>BB00000000000000h Len=200h  Unknown (returns 1X 04 09 20 04, plus zeroes)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Values in Jam with the Band (nocash dump): 17 04 09 20 04, plus 1FBh zeroes
  Values in Face Training (nocash dump):     10 04 09 20 04, plus 1FBh zeroes
</TD></TR></TABLE>
<BR>
<B>9400000000000000h - NAND Read ID + Data[200h]</B><BR>
Returns NAND ID data of sorts.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 Values in Jam with the Band (arisotura dump):
  000h  EC F1 00 95 40 00 00 00 00 00 00 00 00 00 00 00  ....@...........
  010h  00 00 00 00 00 00 00 00 EC 00 9E A1 51 65 34 35  ............Qe45
  020h  30 35 30 31 19 19 02 0A 00 00 00 00 00 00 00 00  0501............
  030h  FF FF FF .. (1D0h bytes) (why not 00h's ???)     ................
 Values in Jam with the Band (nocash dump):
  000h  EC F1 00 95 40 00 00 00 00 00 00 00 00 00 00 00  ....@...........
  010h  00 00 00 00 00 00 00 00 EC 00 3B 5A 32 9B 32 30  ..........;Z2.20
  020h  35 35 30 30 19 19 02 0A 00 00 00 00 00 00 00 00  5500............
  030h  00 00 00 .. (1D0h bytes)                         ................
 Values in Face Training (nocash dump):
  000h  EC F1 00 95 40 00 00 00 00 00 00 00 00 00 00 00  ....@...........
  010h  00 00 00 00 00 00 00 00 EC 00 5A 36 5C 14 35 35  ..........Z6\.55
  020h  32 36 30 36 04 04 08 0A 00 00 00 00 00 00 00 00  2606............
  030h  00 00 00 .. (1D0h bytes)                         ................
</TD></TR></TABLE>
For Jam with Band, the 16 bytes at 018h are also found in the last 800h bytes
of the RW space (see below). The bytes with value ECh might be related to the
Maker ID in Chip ID.<BR>
<BR>
<B>Last 128Kbyte in RW region (at 079E0000h..079FFFFFh)</B><BR>
The last 128Kbyte of RW area is normal write-able memory in Face Training
without special content. However, in Jam with the Band, the last 128KByte are
readonly, they can be read like normal RW blocks (select via command B2h, then
read via B7h), but writing isn't supported (although NAND Status bit5 gets
cleared for a moment upon write attempts to this 128Kbyte area; unlike as for
when trying to write 7A00000h and up).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 Values in Jam with the Band (arisotura dump):
  079E0000h  FF FF FF .. (1F800h bytes)                      ................
  079FF800h  EC 00 9E A1 51 65 34 35 30 35 30 31 19 19 02 0A ....Qe450501....
  079FF810h  00 00 00 00 6D D6 DA 9B B0 24 22 88 79 3B BF EA ....m....$".y;..
  079FF820h  E6 AC 5E FA 69 12 0D 52 5D 5B F5 80 FF FF FF FF ..^.i..R][......
  079FF830h  FF FF FF .. (7D0h bytes)                        ................
 Values in Jam with the Band (nocash dump):
  079E0000h  FF FF FF .. (1F800h bytes)                      ................
  079FF800h  EC 00 3B 5A 32 9B 32 30 35 35 30 30 19 19 02 0A ..;Z2.205500....
  079FF810h  00 00 00 00 DD 58 84 07 F9 72 19 04 96 8C FF 67 .....X...r.....g
  079FF820h  7F 66 B9 E5 FD F7 3F 1A AE 60 60 00 FF FF FF FF .f....?..``.....
  079FF830h  FF FF FF .. (7D0h bytes)                        ................
</TD></TR></TABLE>
Jam with the Band checks the bytes at 079FF800h (unknown what it does with
them, or what it does when they are missing).<BR>
<BR>
<B>Reserved Area (at 07A00000h and up) (including 08000000h and up)</B><BR>
This memory isn't intended to be used, in Jam with the Band it just returns
FFh's. However, in Face Training it does return some interesting internal data
(in RW mode):<BR>
The DSi Blowfish key (with the gamecode pre-applied), some NDS ARM code (for
the secure area or so), and most interestingly some more ARM+THUMB code
(apparently containing the firmware running on an ARM CPU inside of the game
cartridge itself).<BR>
Unfortunately, that internal memory is returned as "raw" data with faulty bits,
and it seems to be required to apply error correction to convert it to actual
intact data (the "raw" stuff consists of 1E8h-byte data snippets, usually
followed by 8-byte ECC info, or sometimes 16-byte or 20-byte ECC, or no ECC at
all). There are several "backup" copies of the blowfish/firmware blocks.<BR>
<BR>
<B>Write Example</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  B2aaaaaaaa000000h - Select 128Kbyte RW access mode (unlesss already)
  8500000000000000h - NAND Write Enable
  81aaaaaaaa000000h - NAND Write to Write Buffer        + Data[200h]
  81aaaaaaaa000000h - NAND Write to Write Buffer        + Data[200h]
  81aaaaaaaa000000h - NAND Write to Write Buffer        + Data[200h]
  81aaaaaaaa000000h - NAND Write to Write Buffer        + Data[200h]
  8200000000000000h - NAND Forward Write Buffer to NAND
  D600000000000000h - NAND Read Status                  + Data[4]
  (...repeat reading status until bit5=1=ready...)
  8400000000000000h - NAND Discard SRAM write
  8B00000000000000h - NAND Select ROM access mode (if desired)
</TD></TR></TABLE>
<BR>
<B>Chipsets</B><BR>
Warioware D.I.Y., NTR-UORE:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  PCB "DI X-7 C17-01"
  Chip "SAMSUNG 004, KLC2811ANB-P204, NTR-UORE-0"
</TD></TR></TABLE>
Jam with the Band, NTR-UXBP:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  PCB (Unknown)
  Chip "SAMSUNG 013, KLC2811UOC-P30A, NTR-UXBP-0, WKA069J2"
</TD></TR></TABLE>
Face Training, TWL-USKV:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  PCB "DI X-8 C17-01"
  U1 "SAMSUNG 031, KLC2811UOC-P309, TWL-USKV-0, WKE114(80?)"
  (this chip must be slightly different, for DSi mode support)
</TD></TR></TABLE>
There are also a bunch of 3DS games with similar chips (with the RW area being
called "CARD2" area on 3DS, and, the 3DS is using 16-byte commands, so the
protocol is different).<BR>
<BR>
<B>Notes</B><BR>
Unlike ROM carts, the NAND cart does crash upon invalid commands (and stops to
respond to further commands). That is, upon invalid command numbers, upon ROM
mode commands in RW mode (or vice-versa), upon any data lengths other listed
above.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dscartridgeioports"></A>
  DS Cartridge I/O Ports
</FONT></TD></TR></TABLE><BR>
The Gamecard bus registers can be mapped to NDS7 or NDS9 via EXMEMCNT, see<BR>
<A HREF="#dsmemorycontrol">DS Memory Control</A><BR>
<BR>
<B>40001A0h - NDS7/NDS9 - AUXSPICNT - Gamecard ROM and SPI Control (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-1   SPI Baudrate        (0=4MHz/Default, 1=2MHz, 2=1MHz, 3=512KHz)
  2-5   Not used            (always zero)
  6     SPI Hold Chipselect (0=Deselect after transfer, 1=Keep selected)
  7     SPI Busy            (0=Ready, 1=Busy) (presumably Read-only)
  8-12  Not used            (always zero)
  13    NDS Slot Mode       (0=Parallel/ROM, 1=Serial/SPI-Backup)
  14    Transfer Ready IRQ  (0=Disable, 1=Enable) (for ROM, not for AUXSPI)
  15    NDS Slot Enable     (0=Disable, 1=Enable) (for both ROM and AUXSPI)
</TD></TR></TABLE>
The "Hold" flag should be cleared BEFORE transferring the LAST data unit, the
chipselect will be then automatically cleared after the transfer, the program
should issue a WaitByLoop(12) on NDS7 (or longer on NDS9) manually AFTER the
LAST transfer.<BR>
<BR>
<B>40001A2h - NDS7/NDS9 - AUXSPIDATA - Gamecard SPI Bus Data/Strobe (R/W)</B><BR>
The SPI transfer is started on writing to this register, so one must
&lt;write&gt; a dummy value (should be zero) even when intending to
&lt;read&gt; from SPI bus.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-7  Data
  8-15 Not used (always zero)
</TD></TR></TABLE>
During transfer, the Busy flag in AUXSPICNT is set, and the written DATA value
is transferred to the device (via output line), simultaneously data is received
(via input line). Upon transfer completion, the Busy flag goes off, and the
received value can be then read from AUXSPIDATA, if desired.<BR>
<BR>
<B>40001A4h - NDS7/NDS9 - ROMCTRL - Gamecard Bus ROMCTRL (R/W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-12  KEY1 gap1 length  (0-1FFFh) (forced min 08F8h by BIOS) (leading gap)
  13    KEY2 encrypt data (0=Disable, 1=Enable KEY2 Encryption for Data)
  14     "SE" Unknown? (usually same as Bit13) (does NOT affect timing?)
  15    KEY2 Apply Seed   (0=No change, 1=Apply Encryption Seed) (Write only)
  16-21 KEY1 gap2 length  (0-3Fh)   (forced min 18h by BIOS) (200h-byte gap)
  22    KEY2 encrypt cmd  (0=Disable, 1=Enable KEY2 Encryption for Commands)
  23    Data-Word Status  (0=Busy, 1=Ready/DRQ) (Read-only)
  24-26 Data Block size   (0=None, 1..6=100h SHL (1..6) bytes, 7=4 bytes)
  27    Transfer CLK rate (0=6.7MHz=33.51MHz/5, 1=4.2MHz=33.51MHz/8)
  28    KEY1 Gap CLKs (0=Hold CLK High during gaps, 1=Output Dummy CLK Pulses)
  29    RESB Release Reset  (0=Reset, 1=Release) (cannot be cleared once set)
  30    Data Direction "WR" (0=Normal/read, 1=Write, for FLASH/NAND carts)
  31    Block Start/Status  (0=Ready, 1=Start/Busy) (IRQ See 40001A0h/Bit14)
</TD></TR></TABLE>
The cartridge header is booted at 4.2MHz CLK rate, and following transfers are
then using ROMCTRL settings specified in cartridge header entries [060h] and
[064h], which are usually using 6.7MHz CLK rate for the main data transfer
phase (whereof, older MROM carts can actually transfer 6.7Mbyte/s, but newer
1T-ROM carts default to reading 200h-byte blocks with gap1=657h, thus reaching
only 1.6Mbyte/s).<BR>
Transfer length of null, four, and 200h..4000h bytes are supported by the
console, however, retail cartridges cannot cross 1000h-byte boundaries (and,
SanDisk ROM chips and Samsung NAND chips cannot transfer more than 200h bytes).<BR>
<B>Default cart header entries</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  hdr[60h]   hdr[64h]   hdr[6Eh]
  00586000h  001808F8h  051Eh     ;older/faster MROM
  00416657h  081808F8h  0D7Eh     ;newer/slower 1T-ROM
  00416657h  081808F8h  0D7Eh     ;newer/slower NAND
</TD></TR></TABLE>
<B>Older/Faster MROM</B><BR>
The romctrl values in cartheader[60h,64h] are okay, but the secure delay in
[6Eh] is nonsense (should be zero).<BR>
<B>Misdeclared MROM</B><BR>
Some carts like SystemFlaw and BiggestLoser are actually containing MROM chips
despite of having 1T-ROM values in cart header (gap1=657h is making loading
insane slow, gap2=01h causes errors on 1000h-byte blocks, and secure.clk=4.2MHz
is slowing down secure area loading, combined with even slower secure area
delay despite of not needing any delay for MROM).<BR>
As the cart header entries are wrong, some other detection is needed: This can
be probably done by checking ChipID.bit31 (or otherwise by testing if
1000h-block reading works with gap1=01h, if so, then it's 1T-ROM).<BR>
<B>Newer/Slower 1T-ROM</B><BR>
Actual 1T-ROM carts can be very slow, especially when using the insane cart
header values and default firmware blocksize of 200h bytes which drops loading
speed from 6.7Mbytes/s to 1.6Mbyte/s (as workaround, use gap1=180h,
blocksize=1000h, also secure area delay should be 400h, not D7Eh)
(tested/working for CookingCoach, unknown if that timings work for all other
carts).<BR>
<B>Superslow Writeable NAND</B><BR>
This is having the same official insane delays as 1T-ROM, but with less
tolerance for faster timings (fastest working values are gap1=380h,
blocksize=200h, secure delay 400h, plus 20ms delay after releasing reset).<BR>
<B>Cart Reset</B><BR>
Reset flag in bit29 can be set once only (to release reset), the only way to
clear the bit is power-off. However, there are some ways to issue resets:<BR>
1) On NDS: Manually eject/insert the cart (that won't affect bit29, but the
cart will reset itself anyways upon power loss) (eject on DSi will power-off
the cart slot).<BR>
2) If one of the two ROMCTRL registers (on ARM7 and ARM9) is still zero:
Temporarily toggle ARM7/ARM9 cart access via EXMEMCNT on ARM9 side.<BR>
3) On DSi: If the 2nd cart slot ROMCTRL register (40021A4h) is still zero:
Temporarily swap 1ns/2nd cart slot via SCFG_MC.bit15 on ARM7 side.<BR>
4) On DSi: Use SCFG_MC to toggle cart power off/on; this will actually reset
bit29, the DSi firmware is actually using that method, but it's very slow
(takes about 300ms, for the power-off wait, plus (unneccassary) hardcoded
power-on delays).<BR>
<BR>
<B>40001A8h - NDS7/NDS9 - Gamecard bus 8-byte Command Out</B><BR>
The separate commands are described in the Cartridge Protocol chapter, however,
once when the BIOS boot procedure has completed, one would usually only need
command "B7aaaaaaaa000000h", for reading data (usually 200h bytes) from address
aaaaaaaah (which should be usually aligned by 200h).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-7   1st Command Byte (at 40001A8h) (eg. B7h) (MSB)
  8-15  2nd Command Byte (at 40001A9h) (eg. addr bit 24-31)
  16-23 3rd Command Byte (at 40001AAh) (eg. addr bit 16-23)
  24-31 4th Command Byte (at 40001ABh) (eg. addr bit 8-15) (when aligned=even)
  32-39 5th Command Byte (at 40001ACh) (eg. addr bit 0-7)  (when aligned=00h)
  40-47 6th Command Byte (at 40001ADh) (eg. 00h)
  48-57 7th Command Byte (at 40001AEh) (eg. 00h)
  56-63 8th Command Byte (at 40001AFh) (eg. 00h) (LSB)
</TD></TR></TABLE>
Observe that the command/parameter MSB is located at the smallest memory
location (40001A8h), ie. compared with the CPU, the byte-order is reversed.<BR>
<BR>
<B>4100010h - NDS7/NDS9 - Gamecard bus 4-byte Data In (R) (or W)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0-7   1st received Data Byte (at 4100010h)
  8-15  2nd received Data Byte (at 4100011h)
  16-23 3rd received Data Byte (at 4100012h)
  24-31 4th received Data Byte (at 4100013h)
</TD></TR></TABLE>
After sending a command, data can be read from this register manually (when the
DRQ bit is set), or by DMA (with DMASAD=4100010h, Fixed Source Address,
Length=1, Size=32bit, Repeat=On, Mode=DS Gamecard).<BR>
<BR>
<B>40001B0h - 32bit - NDS7/NDS9 - Encryption Seed 0 Lower 32bit (W)</B><BR>
<B>40001B4h - 32bit - NDS7/NDS9 - Encryption Seed 1 Lower 32bit (W)</B><BR>
<B>40001B8h - 16bit - NDS7/NDS9 - Encryption Seed 0 Upper 7bit (bit7-15 unused)</B><BR>
<B>40001BAh - 16bit - NDS7/NDS9 - Encryption Seed 1 Upper 7bit (bit7-15 unused)</B><BR>
These registers are used by the NDS7 BIOS to initialize KEY2 encryption (and
there's normally no need to change that initial settings). Writes to the Seed
registers do not have direct effect on the internal encryption registers, until
the Seed gets applied by writing "1" to ROMCTRL.Bit15.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 For more info:
</TD></TR></TABLE>
<A HREF="#dsencryptionbyrandomseedkey2">DS Encryption by Random Seed (KEY2)</A><BR>
Note: There are &lt;separate&gt; Seed registers for both NDS7 and NDS9, which
can be applied by ROMCTRL on NDS7 and NDS9 respectively (however, once when
applied to the internal registers, the new internal setting is used for
&lt;both&gt; CPUs).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dscartridgenitroromandnitroarcfilesystems"></A>
  DS Cartridge NitroROM and NitroARC File Systems
</FONT></TD></TR></TABLE><BR>
The DS hardware, BIOS, and Firmware do NOT contain any built-in filesystem
functions. The ARM9/ARM7 boot code (together max 3903KB), and Icon/Title
information are automatically loaded on power-up.<BR>
Programs that require to load additional data from cartridge ROM may do that
either by implementing whatever functions to translate filenames to ROM
addresses, or by reading from ROM directly.<BR>
<BR>
<B>NitroROM</B><BR>
The NitroROM Filesystem is used by many NDS games (at least those that have
been developed with Nintendo's tools). It's used for ROM Cartridges, and, on
the DSi, it's also used for DSiWare games (in the latter case, NitroROM acts as
a 2nd virtual filesystem inside of the DSi's FAT16 filesystem).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  FNT = cart_hdr[040h]     ;\origin as defined in ROM cartridge header
  FAT = cart_hdr[048h]     ;/
  IMG = 00000000h          ;-origin at begin of ROM
</TD></TR></TABLE>
Aside from using filenames, NitroROM files can be alternately accessed via
Overlay IDs (see later on below).<BR>
<BR>
<B>NitroARC (Nitro Archive)</B><BR>
NARC Files are often found inside of NitroROM Filesystems (ie. NARC is a second
virtual filesystem, nested inside of the actual filesystem). The NARC Format is
very similar to the NitroROM Format, but with additional Chunk Headers (instead
of the Cartridge ROM Header).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  ...  ...  Optional Header (eg. compression header, or RSA signature)
  000h 4    Chunk Name "NARC" (Nitro Archive)                   ;\
  004h 2    Byte Order (FFFEh) (unlike usually, not FEFFh)      ;
  006h 2    Version (0100h)                                     ; NARC
  008h 4    File Size (from "NARC" ID to end of file)           ; Header
  00Ch 2    Chunk Size (0010h)                                  ;
  00Eh 2    Number of following chunks (0003h)                  ;/
  010h 4    Chunk Name "BTAF" (File Allocation Table Block)     ;\
  014h 4    Chunk Size (including above chunk name)             ; File
  018h 2    Number of Files                                     ; Allocation
  01Ah 2    Reserved (0000h)                                    ; Table
  01Ch ...  FAT (see below)                                     ;/
  ...  4    Chunk Name "BTNF" (File Name Table Block)           ;\
  ...  4    Chunk Size (including above chunk name)             ; File Name
  ...  ...  FNT (see below)                                     ; Table
  ...  ..   Padding for 4-byte alignment (FFh-filled, if any)   ;/
  ...  4    Chunk Name "GMIF" (File Image Block)                ;\
  ...  4    Chunk Size (including above chunk name)             ; File Data
  ...  ...  IMG (File Data)                                     ;/
</TD></TR></TABLE>
<BR>
<B>NARCless variant</B><BR>
There are a few NARC archives with crippled header, without "NARC" string (eg.
rom:\dwc\utility.bin in Over the Hedge, Downhill Jam, and Tony Hawk's
Skateland).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 4   FNT Filename Table Offset (always at 10h)
  004h 4   FNT Filename Table Size
  008h 4   FAT Allocaton Table Offset (at above Offset+Size+Padding)
  00Ch 4   FAT Allocaton Table Size
  010h ..  FNT Filename Table Data
  ...  ..  FAT Allocaton Table Data
  ...  ..  IMG File Data
</TD></TR></TABLE>
The offsets in FAT are relative to IMG=0 (as if IMG would start at begin of
file).<BR>
<BR>
<B>File Allocation Table (FAT) (base/size defined in cart header)</B><BR>
Contains ROM addresses for up to 61440 files (File IDs 0000h and up).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Addr Size Expl.
  00h  4    Start address (originated at IMG base) (0=Unused Entry)
  04h  4    End address   (Start+Len)              (0=Unused Entry)
</TD></TR></TABLE>
For NitroROM, addresses must be after Secure Area (at 8000h and up).<BR>
For NitroARC, addresses can be anywhere in the IMG area (at 0 and up).<BR>
Directories are fully defined in FNT area, and do not require FAT entries.<BR>
<BR>
<B>File Name Table (FNT) (base/size defined in cart header)</B><BR>
Consists of the FNT Directory Table, followed by one or more FNT Sub-Tables.<BR>
To interprete the directory tree: Start at the 1st Main-Table entry, which is
referencing to a Sub-Table, any directories in the Sub-Table are referencing to
Main-Table entries, which are referencing to further Sub-Tables, and so on.<BR>
<BR>
<B>FNT Directory Main-Table (base=FNT+0, size=[FNT+06h]*8)</B><BR>
Consists of a list of up to 4096 directories (Directory IDs F000h and up).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Addr Size Expl.
  00h  4    Offset to Sub-table             (originated at FNT base)
  04h  2    ID of first file in Sub-table   (0000h..EFFFh)
</TD></TR></TABLE>
For first entry (ID F000h, root directory):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  06h  2    Total Number of directories     (1..4096)
</TD></TR></TABLE>
Further entries (ID F001h..FFFFh, sub-directories):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  06h  2    ID of parent directory (F000h..FFFEh)
</TD></TR></TABLE>
<BR>
<B>FNT Sub-tables (base=FNT+offset, ends at Type/Length=00h)</B><BR>
Contains ASCII names for all files and sub-directories within a directory.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Addr Size Expl.
  00h  1    Type/Length
              01h..7Fh File Entry          (Length=1..127, without ID field)
              81h..FFh Sub-Directory Entry (Length=1..127, plus ID field)
              00h      End of Sub-Table
              80h      Reserved
  01h  LEN  File or Sub-Directory Name, case-sensitive, without any ending
              zero, ASCII 20h..7Eh, except for characters \/?"&lt;&gt;*:;|
</TD></TR></TABLE>
Below for Sub-Directory Entries only:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  LEN+1 2    Sub-Directory ID (F001h..FFFFh) ;see FNT+(ID AND FFFh)*8
</TD></TR></TABLE>
File Entries do not have above ID field. Instead, File IDs are assigned in
incrementing order (starting at the "First ID" value specified in the Directory
Table).<BR>
<BR>
<B>ARM9 and ARM7 Overlay Tables (OVT) (base/size defined in cart header)</B><BR>
Somehow related to Nintendo's compiler, allows to assign compiler Overlay IDs
to filesystem File IDs, and to define additional information such like load
addresses.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Addr Size Expl.
  00h  4    Overlay ID
  04h  4    RAM Address ;Point at which to load
  08h  4    RAM Size    ;Amount to load
  0Ch  4    BSS Size    ;Size of BSS data region
  10h  4    Static initialiser start address
  14h  4    Static initialiser end address
  18h  4    File ID  (0000h..EFFFh)
  1Ch  4    Reserved (zero)
</TD></TR></TABLE>
<BR>
<B>Cartridge Header</B><BR>
The base/size of FAT, FNT, OVT areas is defined in cartridge header,<BR>
<A HREF="#dscartridgeheader">DS Cartridge Header</A><BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dscartridgeunknowncommands"></A>
  DS Cartridge Unknown Commands
</FONT></TD></TR></TABLE><BR>
The Main Data transfer mode is normally using only two commands (B7h/B8h),
however most cartridges do support one or more undocumented commands (as
opposed to invalid commands, which will cause the cart to stop responding).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Title                    Chip ID   Commands...
  Metroid First Hunt       00000FC2  B7 B8 D8
  Meine Tierarztpraxis     00000FAE  B7 B8 D8
  Meine Tierpension        00000FC2  B7 B8 D8
  Nanostray                00000FC2  B7 B8 D8
  Over the Hedge           00001FC2  B7 B8 D8
  Tony Hawk's Skateland    00003FC2  B7 B8
  Tony Hawk's Downhill Jam 00003FC2  B7 B8
  Ultimate Spiderman       00003FC2  B7 B8
  System Flaw (DSi)        40001FC2  B7 B8 F1
  Biggest Loser (DSi)      40001FC2  B7 B8 F1
  Cooking Coach (DSi)      C0007FC2  58..5F 60..68 B7 B8
  Walk with Me             E0013F80  69..6C B5 B7 B8 D6
  Face Training (DSI NAND) E8007FEC  0x 5x 6x 8x 94 Bx D6 (see NAND chapter)
</TD></TR></TABLE>
The presence of those commands was tested on DSi (where one can reset the cart
by software to recover from invalid commands), with all parameter bits set to
zero.<BR>
That testing is more difficult on NAND carts because the commands do only work
when transferring the correct number of data bytes (0, 4, 200h, or 800h bytes),
and only when being in the correct mode (ROM or RW mode; whereof, on DSi carts,
the RW mode works ONLY in DSi mode).<BR>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 ______________________________ Command 58h..68h ______________________________
</TD></TR></TABLE>
<BR>
<B>5800000000000000h-5F00000000000000h (..) - Get HighZ</B><BR>
Unknown purpose, returns HighZ.<BR>
<BR>
<B>6000000000000000h-6800000000000000h (..) - Get Zeroes</B><BR>
Unknown purpose, returns at least 4000h encrypted 00h bytes.<BR>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 ______________________________ Command 69h..6Ch ______________________________
</TD></TR></TABLE>
<BR>
<B>6900000000000000h-6C00000000000000h (..) - Get Zeroes</B><BR>
Unknown purpose, returns at least 4000h encrypted 00h bytes.<BR>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 ______________________________ Command B5h/D6h _______________________________
</TD></TR></TABLE>
<BR>
<B>B500000000000000h (0) - Start/Stop/Reset/Ack something?</B><BR>
Unknown. Returns only HighZ.<BR>
<BR>
<B>D600000000000000h (4) - Get Status Byte (also used on NAND carts)</B><BR>
Returns a status byte (repeated in first four bytes, then followed by HighZ
bytes).<BR>
<BR>
Command B5h/D6h are supported in carts that have bit5 set in 4th byte of Chip
ID (eg. in Walk with Me). Command D6h (and maybe also B5h) works both on power
up (before secure area), and in main data phase (after secure area). The DSi
Launcher contains following code to deal with such carts:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 if chip_id AND 20000000h
   get_nand_status(cmd_D6h)
   if (nand_status AND 0Ch)&lt;&gt;0                    ;whatever bits
     whatever(cmd_B5h)                            ;whatever command
    loop:
     get_nand_status(cmd_D6h)
     if (nand_status AND 20h)=0 then goto loop    ;wait for ready flag
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 ________________________________ Command D8h _________________________________
</TD></TR></TABLE>
<BR>
<B>D800000000000000h (..) - Get Zeroes</B><BR>
Unknown purpose, returns at least 4000h encrypted 00h bytes.<BR>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 ________________________________ Command F1h _________________________________
</TD></TR></TABLE>
<BR>
<B>F100000000000000h (1000h) - Get Serial/Manufacturer Info or so</B><BR>
Returns 1000h bytes of data (repeated each 1000h bytes), the data is mostly
FFh-filled, with some kind of Serial Number or Manufacturer Info at offset
E00h. Unknown what those values are good for, and if they contain unique IDs.<BR>
This command works in main data phase only (returns only FFh/HighZ on power up
before secure area loading).<BR>
System Flaw cmd F1 response:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0000..0DFF  FF-filled
  0E00        1E 40 05 5A FF FF 0D 01  32 68 38 7A 23 3F FF FF
  0E10        03 0B 00 00 03 09 FF FF  FF FF FF FF FF FF FF FF
  0E20        1E 40 05 03 0B 00 00 03  09 00 00 FF FF FF FF FF
  0E30        FF FF FF FF FF FF FF FF  FF FF FF FF FF FF FF FF
  0E40        FF FF FF FF FF FF FF FF  FF FF FF FF FF FF FF FF
  0E50        FF FF FF FF FF 5A FF 5E  FF FF FF FF FF FF 5A FF
  0E60        FF FF FF FF FF FF FF FF  FF FF FF FF FF FF FF FF
  0E70        FF FF FF FF FF FF FF FF  FF FF FF FF FF FF FF FF
  0E80..0FFF  FF-filled
  1000..3FFF  mirrors of 0000-0FFF
</TD></TR></TABLE>
Biggest Loser cmd F1 response:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0000..0DFF  FF-filled
  0E00        11 16 08 5A FF FF 0D 0B  39 7C 40 8E 2A 53 FF FF
  0E10        03 0A 07 05 05 04 00 00  07 00 7F FF 00 FF FF FF
  0E20        FF FF FF FF FF FF FF FF  FF FF FF FF FF FF FF FF
  0E30        FF FF FF FF FF FF FF FF  FF FF FF FF FF FF FF FF
  0E40        FF FF FF FF FF FF FF FF  FF FF FF FF FF FF FF FF
  0E50        FF FF FF FF FF 5A FF 5E  FF FF FF FF FF FF 5A FF
  0E60        FF FF FF FF FF FF FF FF  FF FF FF FF FF FF FF FF
  0E70        FF FF FF FF FF FF FF FF  FF FF FF FF FF FF FF FF
  0E80..0FFF  FF-filled
  1000..3FFF  mirrors of 0000-0FFF
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dscartridgepassmepassthrough"></A>
  DS Cartridge PassMe/PassThrough
</FONT></TD></TR></TABLE><BR>
PassMe is an adapter connected between the DS and an original NDS cartridge,
used to boot unencrypted code from a flash cartridge in the GBA slot, it
replaces the following entries in the original NDS cartridge header:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Addr  Siz Patch
  004h  4   E59FF018h  ;opcode LDR PC,[027FFE24h] at 27FFE04h
  01Fh  1   04h        ;set autostart bit
  022h  1   01h        ;set ARM9 rom offset to nn01nnnnh (above secure area)
  024h  4   027FFE04h  ;patch ARM9 entry address to endless loop
  034h  4   080000C0h  ;patch ARM7 entry address in GBA slot
  15Eh  2   nnnnh      ;adjust header crc16
</TD></TR></TABLE>
After having verified the encrypted chip IDs (from the original cartridge), the
console thinks that it has successfully loaded a NDS cartridge, and then jumps
to the (patched) entrypoints.<BR>
<BR>
<B>GBA Flashcard Format</B><BR>
Although the original PassMe requires only the entrypoint, PassMe programs
should additionally contain one (or both) of the ID values below, allowing
firmware patches to identify &amp; start PassMe games without real PassMe
hardware.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0A0h  GBA-style Title    ("DSBooter")
  0ACh  GBA-style Gamecode ("PASS")
  0C0h  ARM7 Entrypoint    (32bit ARM code)
</TD></TR></TABLE>
Of course, that applies only to early homebrew programs, newer games should use
normal NDS cartridge headers.<BR>
<BR>
<B>ARM9 Entrypoint</B><BR>
The GBA-slot access rights in the EXMEMCNT register are initially assigned to
the ARM7 CPU, so the ARM9 cannot boot from the flashcard, instead it is
switched into an endless loop in Main RAM (which contains a copy of the
cartridge header at 27FFE00h and up). The ARM7 must thus copy ARM9 code to Main
RAM, and then set the ARM9 entry address by writing to [027FFE24h].<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dscartridgegbaslot"></A>
  DS Cartridge GBA Slot
</FONT></TD></TR></TABLE><BR>
Aside from the 17-pin NDS slot, the DS also includes a 32-pin GBA slot. This
slot is used for GBA backwards compatibility mode. Additionally, in DS mode, it
can be as expansion port, or for importing data from GBA games.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  NDS:     Normal 32pin slot
  DS Lite: Short 32pin slot (GBA cards stick out)
  DSi:     N/A (dropped support for GBA carts, and for DS-expansions)
</TD></TR></TABLE>
In DS mode, ROM, SRAM, FLASH backup, and whatever peripherals contained in
older GBA cartridges can be accessed (almost) identically as in GBA mode,<BR>
<A HREF="#gbacartridges">GBA Cartridges</A><BR>
<BR>
<B>Addressing</B><BR>
In DS mode, only one ROM-region is present at 8000000h-9FFFFFFh (ie. without
the GBA's mirrored WS1 and WS2 regions at A000000h-DFFFFFFh). The expansion
region (for SRAM/FLASH/etc) has been moved from E000000h-E00FFFFh (GBA-mode) to
A000000h-A00FFFFh (DS-mode).<BR>
<BR>
<B>Timings</B><BR>
GBA timings are specified as "waitstates" (excluding 1 access cycle), NDS
timings are specified as (total) "access time". And, the NDS bus-clock is twice
as fast as for GBA. So, for "N" GBA waitstates, the NDS access time should be
"(N+1)*2". Timings are controlled via NDS EXMEMCNT instead GBA WAITCNT,<BR>
<A HREF="#dsmemorycontrolcartridgesandmainram">DS Memory Control - Cartridges and Main RAM</A><BR>
<BR>
<B>GBA EEPROM</B><BR>
EEPROMs in GBA carts cannot be accessed in DS mode. The EEPROMs should be
accessed with 8 waits on GBA, ie. 18 cycles on NDS on both 1st/2nd access. But,
2nd access is restricted to max 6 cycles in NDS mode, which is ways too fast.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dscartrumblepak"></A>
  DS Cart Rumble Pak
</FONT></TD></TR></TABLE><BR>
<B>DS Rumble Option Pak</B><BR>
The Rumble Pak comes bundled with Metroid Prime Pinball. It contains a small
actuator made by ALPS to make it rumble. The original device (NTR-008) is sized
like a normal GBA cartridge, and there's also shorter variant for the DS-Lite
(USG-006).<BR>
The rumble pak is pretty simple internally, it only wires up to a few pins on
the GBA Cartridge Port:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  VCC, GND, /WR, AD1, and IRQ (grounded)
</TD></TR></TABLE>
AD1 runs into a little 8 pin chip, which is probably just a latch on the rising
edge of /WR. A line runs from this chip to a transistor that is directly
connected to the actuator. The only other chip on the board is a 5 pin jobber,
probably a power component.<BR>
For detection, AD1 seems to be pulled low when reading from it, the other AD
lines are open bus (containing the halfword address), so one can do:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  for i=0 to 0FFFh
    if halfword[8000000h+i*2]&lt;&gt;(i and FFFDh) then &lt;not_a_ds_rumble_pak&gt;
  next i
</TD></TR></TABLE>
The actuator doesn't have an on/off setting like a motor, it rumbles when you
switch it between the two settings. Switch frequently for a fast rumble, and
fairly slowly for more of a 'tick' effect. That should be done via timer irq:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  rumble_state = rumble_state xor 0002h
  halfword[8000000h]=rumble_state
</TD></TR></TABLE>
Unknown if one of the two states has higher power-consumption than the other,
ie. if it's a "pull/release" mechanism, if so, then disabling rumble should be
done by using the "release" state, which would be AD1=0, or AD1=1...?<BR>
Note: The v3 firmware can detect the Rumble Pak as an option pak, but it does
not provide an enable/disable rumble option in the alarm menu.<BR>
<BR>
<B>Other DS Rumble device</B><BR>
There's also another DS add-on with rumble. That device uses AD8 (instead AD1)
to control rumble, and, it's using a classic motor (ie. it's rumbling while and
as long as the latched AD8 value is "1").<BR>
<A HREF="#dscartsliderwithrumble">DS Cart Slider with Rumble</A><BR>
<BR>
<B>GBA Rumble Carts</B><BR>
There are also a few GBA games that contain built-in Rumble, and which could be
used by NDS games as well. To be user friendly, best support both types.<BR>
<A HREF="#gbacartrumble">GBA Cart Rumble</A><BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dscartsliderwithrumble"></A>
  DS Cart Slider with Rumble
</FONT></TD></TR></TABLE><BR>
Add-on device for the japanese title Magukiddo. The optical sensor is attached
underneath of the console (connected to the GBA slot).<BR>
The sensor is an Agilent ADNS-2030 Low Power Optical Mouse Sensor (16pin DIP
chip with built-in optical sensor, and external LED light source) with two-wire
serial bus (CLK and DTA).<BR>
<BR>
<B>ADNS-2030 Registers (write 1 byte index, then read/write 1 byte data)</B><BR>
Index (Bit7=Direction; 0=Read, 1=Write):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h Product_ID (R) (03h)
  01h Revision_ID (R) (10h=Rev. 1.0) (20h=Used in DS-option-pak)
  02h Motion/Status Flags (R)
  03h Delta_X (R) (signed 8bit) (automatically reset to 00h after reading)
  04h Delta_Y (R) (signed 8bit) (automatically reset to 00h after reading)
  05h SQUAL (R) (surface quality) (unsigned 8bit)
  06h Average_Pixel (R) (unsigned 6bit, upper 2bit unused)
  07h Maximum_Pixel (R) (unsigned 6bit, upper 2bit unused)
  08h Reserved
  09h Reserved
  0Ah Configuration_bits (R/W)
  0Bh Reserved
  0Ch Data_Out_Lower (R)
  0Dh Data_Out_Upper (R)
  0Eh Shutter_Lower (R)
  0Fh Shutter_Upper (R)
  10h Frame_Period_Lower (R/W)
  11h Frame_Period_Upper (R/W)
</TD></TR></TABLE>
Motion/Status Flags:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7 Motion since last report or PD (0=None, 1=Motion occurred)
  6 Reserved
  5 LED Fault detected (0=No fault,  1=Fault detected)
  4 Delta Y Overflow (0=No overflow, 1=Overflow occured)
  3 Delta X Overflow (0=No overflow, 1=Overflow occured)
  2 Reserved
  1 Reserved
  0 Resolution in counts per inch (0=400, 1=800)
</TD></TR></TABLE>
Configuration_bits:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7 Reset Power up defaults (W) (0=No, 1=Reset)
  6 LED Shutter Mode (0=LED always on, 1=LED only on when shutter is open)
  5 Self Test (W) (0=No, 1=Perform all self tests)
  4 Resolution in counts per inch (0=400, 1=800)
  3 Dump 16x16 Pixel bitmap (0=No, 1=Dump via Data_Out ports)
  2 Reserved
  1 Reserved
  0 Sleep Mode (0=Normal/Sleep after 1 second, 1=Always awake)
                          _______
                         |74273  |
  /WR -----------------&gt; |CLK    |                       _____
  AD1/SIO CLK ---------&gt; |D1   Q1|--------------&gt; CLK   |74125|
  AD2 power control ---&gt; |D2   Q2|---&gt;     ____         |     |
  AD3/SIO DIR ---------&gt; |D3   Q3|------o-|7400\________|/EN  |
  AD8 rumble on/off ---&gt; |D?   Q?|---&gt;  '-|____/        |     |
  AD0/SIO DTA ----o----&gt; |D5   Q5|----------------------|A   Y|--o--DTA
                  |      |_______|                      |- - -|  |
          ____    '-------------------------------------|Y   A|--'
  /RD ---|7400\______ ____                              |     |
  /RD ---|____/      |7400\_____________________________|/EN  |
  A19 _______________|____/                             |_____|
</TD></TR></TABLE>
<BR>
7400 Quad NAND Gate, 74273 8bit Latch<BR>
<BR>
AD0 Optical Sensor Serial Data      (0=Low, 1=High)<BR>
AD1 Optical Sensor Serial Clock     (0=Low, 1=High)<BR>
AD2 Optical Sensor Power            (0=Off, 1=On)<BR>
AD3 Optical Sensor Serial Direction (0=Read, 1=Write)<BR>
AD8 Rumble Motor                    (0=Off, 1=On)<BR>
<BR>
Thanks: Daniel Palmer<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dscartexpansionram"></A>
  DS Cart Expansion RAM
</FONT></TD></TR></TABLE><BR>
<B>DS Memory Expansions</B><BR>
There are several RAM expansions for the NDS. The RAM cartridge connects to the
GBA slot; can can be then accessed from cartridges in the DS slot.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Opera         (8MB RAM) (official RAM expansion for Opera browser)
  EZ3/4/3-in-1  (8-16MB RAM, plus FLASH, plus rumble)
  Supercard     (32MB)
  M3            (32MB)
  G6            (32MB)
</TD></TR></TABLE>
The recommended access time (waitstates) for all memory types is unknown.
Unknown which programs do use these expansions for which purposes (aside from
the Opera browser).<BR>
Thanks to Rick "Lick" Wong for info on detection and unlocking.<BR>
<BR>
<B>Opera / DS Memory Expansion Pak (NTR-011 or USG-007)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  base=9000000h, size=800000h (8MB)
  unlock=1, lock=0
  STRH [8240000h],lock/unlock
</TD></TR></TABLE>
<BR>
<B>EZ</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  base=8400000h, size=VAR (8MB..16MB)
  locking/unlocking/detection see below
</TD></TR></TABLE>
<BR>
<B>Supercard</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  base=8000000h, size=1FFFFFEh (32MB minus last two bytes?)
  unlock=5 (RAM_RW), lock=3 (MEDIA)
  STRH [9FFFFFEh],A55Ah
  STRH [9FFFFFEh],A55Ah
  STRH [9FFFFFEh],lock/unlock
  STRH [9FFFFFEh],lock/unlock
</TD></TR></TABLE>
<BR>
<B>M3</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  base=8000000h, size=2000000h (32MB)
  unlock=00400006h, lock=00400003h
  LDRH Rd,[8E00002h]
  LDRH Rd,[800000Eh]
  LDRH Rd,[8801FFCh]
  LDRH Rd,[800104Ah]
  LDRH Rd,[8800612h]
  LDRH Rd,[8000000h]
  LDRH Rd,[8801B66h]
  LDRH Rd,[8000000h+(lock/unlock)*2]
  LDRH Rd,[800080Eh]
  LDRH Rd,[8000000h]
  LDRH Rd,[80001E4h]
  LDRH Rd,[80001E4h]
  LDRH Rd,[8000188h]
  LDRH Rd,[8000188h]
</TD></TR></TABLE>
<BR>
<B>G6</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  base=8000000h, size=2000000h (32MB)
  unlock=6, lock=3
  LDRH Rd,[9000000h]
  LDRH Rd,[9FFFFE0h]
  LDRH Rd,[9FFFFECh]
  LDRH Rd,[9FFFFECh]
  LDRH Rd,[9FFFFECh]
  LDRH Rd,[9FFFFFCh]
  LDRH Rd,[9FFFFFCh]
  LDRH Rd,[9FFFFFCh]
  LDRH Rd,[9FFFF4Ah]
  LDRH Rd,[9FFFF4Ah]
  LDRH Rd,[9FFFF4Ah]
  LDRH Rd,[9200000h+(lock/unlock)*2]
  LDRH Rd,[9FFFFF0h]
  LDRH Rd,[9FFFFE8h]
</TD></TR></TABLE>
<BR>
<B>Detection</B><BR>
For EZ, detection works as so:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 ez_ram_test:   ;Based on DSLinux Amadeus' detection
  ez_subfunc(9880000h,8000h) ;-SetRompage (OS mode)
  ez_subfunc(9C40000h,1500h) ;-OpenNorWrite
  [08400000h]=1234h          ;\
  if [08400000h]=1234h       ; test writability at 8400000h
    [8000000h]=4321h         ; and non-writability at 8000000h
    if [8000000h]&lt;&gt;4321h     ;
      return true            ;/
  ez_subfunc(9C40000h,D200h) ;CloseNorWrite
  ez_subfunc(9880000h,0160h) ;SetRompage (0160h)
  ez_subfunc(9C40000h,1500h) ;OpenNorWrite
  [8400000h]=1234h           ;\
  if [8400000h]=1234h        ; test writability at 8400000h
    return true              ;/
  return false               ;-failed
 ez_subfunc(addr,data):
  STRH [9FE0000h],D200h
  STRH [8000000h],1500h
  STRH [8020000h],D200h
  STRH [8040000h],1500h
  STRH [addr],data
  STRH [9FC0000h],1500h
</TD></TR></TABLE>
For all other types (everything except EZ), simply verify that you can write
(when unlocked), and that you can't (when locked).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dscartinfraredpedometers"></A>
  DS Cart Infrared/Pedometers
</FONT></TD></TR></TABLE><BR>
<B>NDS/DSi Cartridges with IR port</B><BR>
<A HREF="#dscartinfraredcartridgespicommands">DS Cart Infrared Cartridge SPI Commands</A><BR>
<A HREF="#dscartinfraredcartridgememorymap">DS Cart Infrared Cartridge Memory Map</A><BR>
<BR>
<B>Activity Meter</B><BR>
Pedometer with two-color LED and button. The step counter results can be
transferred to NDS via IrDA.<BR>
<A HREF="#dscartinfraredactivitymeterircommands">DS Cart Infrared Activity Meter IR Commands</A><BR>
<A HREF="#dscartinfraredactivitymetermemorymap">DS Cart Infrared Activity Meter Memory Map</A><BR>
<BR>
<B>P-Walker</B><BR>
Pedometer with LCD, speaker, and three buttons. There is no intended way to run
custom program code (though it can be tweaked to do so via CPU Memory Write
command).<BR>
<A HREF="#dscartinfraredpwalkerircommands">DS Cart Infrared P-Walker IR Commands</A><BR>
<A HREF="#dscartinfraredpwalkermemorymap">DS Cart Infrared P-Walker Memory Map</A><BR>
<A HREF="#dscartinfraredpwalkerportslcdcontroller">DS Cart Infrared P-Walker Ports LCD Controller</A><BR>
<A HREF="#dscartinfraredpwalkerportsaccelerometerbma150">DS Cart Infrared P-Walker Ports Accelerometer BMA150</A><BR>
The purpose is more or less unknown: Apart from communicating with the NDS, the
IrDA can be also used communicate with other P-Walkers (maybe for
trading/fighting?). The GUI supports Teams, Routes, Events, Items (maybe for
some built-in interactice game engine?).<BR>
<BR>
<B>Component Lists</B><BR>
<A HREF="#dscartinfraredcomponentlists">DS Cart Infrared Component Lists</A><BR>
<BR>
<B>H8/38602 CPU series with H8/300H instruction set</B><BR>
The NDS cartridges and Activity Meter and P-Walker contain Renesas H8/3860X
CPUs with H8/300H instruction set and on-chip firmware. In the cartridge it's
merely used for forwading IR messages via SPI bus, in the pedometer it's
handling step sensors, step counting, EEPROM logging, buttons, LED/LCD,
RTC/time, IR messages, etc.<BR>
<A HREF="#h8386sfrs">H8/386 SFRs</A><BR>
<A HREF="#h8386exceptionvectors">H8/386 Exception Vectors</A><BR>
<A HREF="#h8300hoperands">H8/300H Operands</A><BR>
<A HREF="#h8300hopcodes">H8/300H Opcodes</A><BR>
<BR>
<B>References</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  H8/300H Series Programming Manual (Hitachi, 257 pages)  ;-Opcodes
  H8/38602R Group Hardware Manual (Renesas, 554 pages)    ;-SFR's
  The addition of H8/38606 Group (Renesas, 6 pages)       ;-FLASH/ROM/RAM
</TD></TR></TABLE>
For P-Walker:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  BMA150 Triaxial digital acceleration sensor Data sheet (Bosch, 56 pages)
  SSD1850 Advance Information (Solomon System, 56 pages)  ;-LCD driver
  <A HREF="http://dmitry.gr/?r=05.Projects&proj=28.%20pokewalker"><FONT COLOR=#808080>http://dmitry.gr/?r=05.Projects&proj=28.%20pokewalker</FONT></A>   ;-Disassembly/Story
  <A HREF="http://forums.nesdev.com/viewtopic.php?f=23&t=21140#p265388"><FONT COLOR=#808080>http://forums.nesdev.com/viewtopic.php?f=23&t=21140#p265388</FONT></A>  ;-Forum
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dscartinfraredcartridgespicommands"></A>
  DS Cart Infrared Cartridge SPI Commands
</FONT></TD></TR></TABLE><BR>
There are two NDS cart firmware versions with minor differences:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  OLD was used in Walk with Me (maybe also Active Health?)
  NEW was used in the P-Letter game series
</TD></TR></TABLE>
The IR-port is accessed via SPI bus commands; that bus is also shared for
accessing FLASH/EEPROM memory (via 00h-prefix).<BR>
<BR>
<B>Infrared NDS cartridge SPI command summary</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  04h,04h                  Initial dummy in walk with me (bugged read or wrdi?)
  00h,cmd,params[...]      Savedata access
  01h,00h,00h              Infrared RX (none, len=0, plus dummy data=0)
  01h,len,data[len]        Infrared RX (OLD: max 84h bytes, NEW: max B8h bytes)
  02h,data[...]            Infrared TX (OLD: max 84h bytes, NEW: max B8h bytes)
  02h,F2h,data[...]        OLD: ignored (refuses to TX data starting with F2h)
  03h,msb,lsb,data         Memory Write 8bit   ;\MOV.B
  04h,msb,lsb,data         Memory Read 8bit    ;/
  05h,msb,lsb,data,data    Memory Write 16bit  ;\MOV.W (fails on 8bit SFRs?)
  06h,msb,lsb,data,data    Memory Read 16bit   ;/
  07h,00h,num,num,num,...  Blah, returns num params from previous spi command
  08h..FFh                 OLD: Ignored (keeps awaiting a SPI command byte)
  08h,ver                  NEW: Returns version (ver=AAh)
  09h..FFh                 OLD: Ignored (returns zeropadding)
</TD></TR></TABLE>
<BR>
<B>SPI Transfers</B><BR>
The SPI transfers are working at max 1MHz transfer clock, and they do require a
delay after each byte:<BR>
Waiting 800h clks at 33MHz seems to work okay (eg. MOV r0,200h // SWI 03h on
ARM7). The NEW ROM version disables IR polling when doing the SPI transfers for
RX/TX data blocks (so it may work with shorter delays between the data[...]
bytes).<BR>
The savedata access is directly passed to the FLASH/EEPROM chip and does work
at 4MHz without delays (except, the leading 00h prefix must be transferred at
1MHz plus delay, and another delay is needed when releasing chipselect after
last byte).<BR>
Note: The NDS cart slot IRQ pin is GNDed in Walk with Me (ie. there is no IRQ
for SPI/IR status).<BR>
SPI access does require cart power on and reset (via DSi SCFG registers), but
doesn't require any ROM commands like secure area loading. Confusingly, the ROM
Chip ID seems to have an IR flag in bit0 of 3rd byte (although the ROM chip
isn't wired to IR hardware at all).<BR>
<BR>
<B>IR Transfers</B><BR>
The IR transfers are using a fixed baudrate: 115200 baud, 8n1, one-directional
(RX gets disabled during TX). The RX/TX commands are transferring "packets"
(with each "packet" being terminated by a "pause" in the IR transmission; that
"packet+pause" mechanism is making it impossible to use streaming for
transferring larger blocks that exceed the buffer size of max 84h or B8h
bytes).<BR>
The RX command will return empty data with len=00h until a WHOLE packet has
been received via IR.<BR>
The TX command won't start the IR transfer until the WHOLE packet has been
written via SPI, with packet end indicated by releasing chip select.<BR>
There is no way to detect TX transfer end (other than computing the expected
tranfer time and using an ARM timer).<BR>
However, Nintendo is sending a Reply for most TX commands, so one can simply
wait for RX packets to determine TX completion (if neither Reply nor Checksum
Error are received then one will still need timeout handling).<BR>
<BR>
<B>Memory Read/Write</B><BR>
These commands are normally not used. The memory commands do forcefully abort
IR transfers, so they can't be used for polling IR transfer status.<BR>
However, they can be used for dumping the firmware ROM, and they could be used
to upload/execute custom code in RAM, which may allow to overcome some of the
above IR transfer restrictions (other baudrates, fewer delays, better
streaming, not ignoring byte F2h, etc).<BR>
<BR>
<B>IR Cart Detection</B><BR>
NDS/DSi Carts with IR support are having special game code with "I" in first
letter (NTR-Ixxx or TWL-Ixxx). There are reportedly pirate/bootleg versions of
the P-Letter games without IR hardware, unknown if they do nethertheless have
the "I" in the gamecode.<BR>
Emulators can detect the leading 00h prefix for Savedata access, although that
detection may go wrong if preceeded by IR access. Emulators can additionally
detect the slow 1MHz SPI clock used for IR access (and for 00h prefix).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dscartinfraredcartridgememorymap"></A>
  DS Cart Infrared Cartridge Memory Map
</FONT></TD></TR></TABLE><BR>
<B>IR Cartridge SFR Usage</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  [0FFD6h].0  Port 3 Data bit0 OUT  IrDA PWDOWN (1=disable IrDA RX)
  [0FFD6h].1  Port 3 Data bit1 IN   IrDA RXD  ;\via serial IrDA registers
  [0FFD6h].2  Port 3 Data bit2 OUT  IrDA TXD  ;/
  [0FFDBh].3  Port 8 Data bit3 OUT  Savedata chipselect (0=select) (cmd 00h)
  [0FFDBh].2  Port 8 Data bit2 OUT  LED color    ;\used in UNUSED functions,
  [0FFDBh].3  Port 8 Data bit3 OUT  LED color    ; in OLD ROM only, and
  [0FFDEh].0  Port B Data bit0 IN   Button input ;/conflicting with Savedata
  IrDA  IR Transfers
  SPI   NDS Console (and cmd 00h forwarding to Savedata)
</TD></TR></TABLE>
<BR>
<B>IR Cartridge (OLD Version)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  FB80h 200h  undocumented and unused RAM, is R/W in my 38600R (!)
  FD80h 2     unused           ;-unused
  FD82h 2     ir_callback      ;\main callbacks for ir/spi polling
  FD84h 2     spi_callback     ;/
  FD86h 2     ir_timestamp     ;-last ir access (for timeout)?
  FD88h 2     spi_timestamp    ;-last spi access (for debug or so)?
  FD8Ah 1     initial_blah     ;-initial state of Port 8.bit3 (not really used)
  FD8Bh 1     ir_rxbuf_wrptr   ;-ir_rxbuf_wrptr (for incoming IR data)?
  FD8Ch 1     ir_rxbuf_rdptr   ;-ir_rxbuf_rdptr (for forwarding to spi)?
  FD8Dh 84h   spi_rx_buf       ;-spi_rx_buf  ;(also ir TX buf)
  FE11h 84h   infrared_rx_buf  ;-infrared_rx_buf
  FE95h 1     spi_index        ;-spi_index
  FE96h 1     ir_tx_index      ;-ir_tx_index   (from spi buf to TX infrared)
  FE97h 1     ir_timeout_flag  ;-ir_timeout_flag   (or packet end or so?)
  FE98h 2     button_num_changes   ;\
  FE9Ah 2     button_num_pushes    ; used only in
  FE9Ch 1     button_new_state     ; UNUSED functions
  FE9Dh 1     button_old_state     ;
  FE9Eh 1     button_newly_pushed  ;
  FE9Fh 1     button_offhold       ;/
  FEA0h E0h   stack_area (stacktop at FF80h)
</TD></TR></TABLE>
<BR>
<B>IR Cartridge (NEW Version)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  FB80h 200h  undocumented and unused RAM, is R/W in my 38600R (!)
  FD80h 2     unused           ;-unused
  FD82h 2     ir_callback      ;\main callbacks for ir/spi polling
  FD84h 2     spi_callback     ;/
  FD86h 2     ir_timestamp     ;-last ir access (for timeout)?
  FD88h 1     ir_rxbuf_wrptr   ;-ir_rxbuf_wrptr (for incoming IR data)?
  FD89h 1     ir_rxbuf_rdptr   ;-blah, always set to 0, never used
  FD8Ah 1     spi_index        ;-spi_index
  FD8Bh 1     ir_tx_index      ;-ir_tx_index   (from spi buf to TX infrared)
  FD8Ch B8h   spi_rx_buf       ;-spi_rx_buf  ;(also ir TX buf)
  FE44h B8h+1 infrared_rx_buf  ;-infrared_rx_buf (plus space for appending 00h)
  FEFDh 1     ir_timeout_flag  ;-ir_timeout_flag   (or packet end or so?)
  FEFEh 82h   stack_area (stacktop at FF80h)
</TD></TR></TABLE>
<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dscartinfraredactivitymeterircommands"></A>
  DS Cart Infrared Activity Meter IR Commands
</FONT></TD></TR></TABLE><BR>
<B>Packet Encryption/Checksumming</B><BR>
Nintendo wants all IR packet bytes to be "encrypted" (XORed by AAh), that
encryption/decryption must be done on ARM side. The checksums are calculated as
so (on decrypted packets):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  sum=0, packet[2,3]=00h,00h                    ;-initial chksum
  for i=0 to size-1
    if (i and 1)=0 then sum=sum+packet[i]*100h  ;\add in big-endian fashion
    if (i and 1)=1 then sum=sum+packet[i]       ;/
  sum=(sum/10000h)+(sum AND FFFFh)              ;\final adjust
  sum=(sum/10000h)+(sum)                        ;/
  packet[2,3]=sum,sum/100h                      ;-store in little-endian
</TD></TR></TABLE>
The packets are transferred at 115200 baud, 8n1. End of Packet is indicated by
a pause in the IR transmission (that does also indicate the packet size).<BR>
Before sending a command packet, one should always wait for incoming data from
the Activity Meter (ie. for the FCh byte, or for Reply/ChecksumError responses
for previous command).<BR>
<BR>
<B>Activity Meter IR commands (from NDS):</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  08,xx,cc,cc,msb,lsb,data[..]  CPU Memory Write    (len=3Eh max)  ;Reply=08
  0A,xx,cc,cc,msb,lsb,len       CPU Memory Read     (len=40h max)  ;Reply=0A
  0A,xx,cc,cc,FB,9C,len         CPU Memory Read FB9Ch with ClrFlag ;Reply=0A
  20,xx,cc,cc,msb,lsb,data[..]  Serial EEPROM Write (len=3Eh max)  ;Reply=20
  22,xx,cc,cc,msb,lsb,len       Serial EEPROM Read  (len=40h max)  ;Reply=22
  24,00,cc,cc,ss,ss,ss,ss       Update Ringbuf_mm    ;\            ;Reply=24
  24,01,cc,cc,ss,ss,ss,ss       Update Ringbuf_hh    ; and set     ;Reply=24
  24,02,cc,cc,ss,ss,ss,ss       Update Ringbuf_dd    ; 32bit       ;Reply=24
  24,03,cc,cc,ss,mm,hh          Set RTC hh:mm:ss     ; seconds     ;Reply=24
  24,04,cc,cc,ss,ss,ss,ss       Raw Set ssssssss ?   ;/            ;Reply=24
  24,xx,cc,cc,ss,ss,ss,ss       Invalid (same as 24,04)            ;Reply=24
  26,xx,cc,cc                   Deadlock   ;\both same (maybe      ;Reply=26
  28,xx,cc,cc                   Deadlock   ;/Watchdog/reboot?)     ;Reply=26
  2A,xx,cc,cc,00,nn             Stepback Ringbuf_hh  ;\go back nn  ;Reply=2A
  2A,xx,cc,cc,01,nn             Stepback Ringbuf_mm  ; entries,    ;Reply=2A
  2A,xx,cc,cc,02,nn             Stepback Ringbuf_dd  ;/see [FCDAh] ;Reply=2A
  2A,xx,cc,cc,xx,..             Invalid                            ;Reply=2A
  2C,cs,cc,cc                   Toggle one LED on/off              ;Reply=2C
  F4,xx,cc,cc                   Disconnect                         ;Reply=None
  F6,xx,cc,cc                   Force "Bad Chksum" reply           ;Reply=FC
  FA,xx,cc,cc                   Connect                            ;Reply=F8
  FE,...                        Noise      ;\ignored, noise        ;Reply=None
  FF,...                        Noise      ;/                      ;Reply=None
  xx,xx,cc,cc                   Invalid    ;-ignored, invalid cmd  ;Reply=None
  xx,xx,xx,xx                   Bad Chksum                         ;Reply=FC
</TD></TR></TABLE>
<BR>
<B>Activity Meter IR replies (to NDS):</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  08,sq,cc,cc           Reply to Cmd 08 (CPU Memory Write reply)
  0A,sq,cc,cc,data[..]  Reply to Cmd 0A (CPU Memory Read reply)
  20,sq,cc,cc           Reply to Cmd 20 (Serial EEPROM Write reply)
  22,sq,cc,cc,data[..]  Reply to Cmd 22 (Serial EEPROM Read reply)
  26,xx,cc,cc           Reply to Cmd 26 and 28 (Deadlock reply)
  24,xx,cc,cc           Reply to Cmd 24 (Update, or Set RTC time)
  2A,xx,cc,cc           Reply to Cmd 2A (Stepback, with result at [FCDAh])
  2C,cs,cc,cc           Reply to Cmd 2C (LED reply)
  80,FF,cc,cc           Factory Reset and Hardware Test completed (or failed)
  F8,00,cc,cc           Reply to Cmd FA (Connect reply)
  FC,xx,cc,cc           Reply to Cmd's with Bad Chksum (and Cmd F6)
  FC                    Advertising Msg (after pressing button) (single byte)
</TD></TR></TABLE>
<BR>
<B>Notes</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  cc,cc        Checksum (LITTLE-ENDIAN)
  msb,lsb      Memory Address (big-endian)
  ss,ss,ss,ss  Seconds since 2001 (big-endian)
  ss,mm,hh     RTC time HH:MM:SS (BCD) (caution: smashes seconds since 2001)
  sq           Increasing sequence number in Memory Access replies
  cs           LED color/state (c=color red/green, s=state on/off)
  xx           Whatever (don't care?)
</TD></TR></TABLE>
There aren't any specific commands for reading things like step counters, one
must instead use the Memory Read/Write commands with hardcoded RAM or EEPROM
address, see:<BR>
<A HREF="#dscartinfraredactivitymetermemorymap">DS Cart Infrared Activity Meter Memory Map</A><BR>
The command/reply are intended to be transferred from/to NDS accordingly, but
things could go wrong if there are multiple consoles or activity meters (all
trying to process the same message, or even mistreating replies as commands).<BR>
The infrared range (distance/angle) is unknown. Dumping the whole 64K CPU
memory space worked without checksum errors at about 5-10cm distance (and that
worked without even using the Connect command).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dscartinfraredactivitymetermemorymap"></A>
  DS Cart Infrared Activity Meter Memory Map
</FONT></TD></TR></TABLE><BR>
The most important RAM locations are FCE8h=Total steps, and FB9Ch=Unique ID
(when using multiple Activity Meters), FCF0h=Daily Goal (to change LED color
after N steps). Nintendo is reading/writing a few more RAM locations. And,
there are ring buffers with steps per minute/hour/day in EEPROM.<BR>
<BR>
<B>Activity Meter SFR Usage</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  [0FFD4h].0  Port 1 Data bit0 IN   Factory Test (0=Test, 1=Normal)
  [0FFD4h].2  Port 1 Data bit2 OUT  Set for sum of eight A/D conversions
  [0FFD6h].0  Port 3 Data bit0 OUT  IrDA PWDOWN (1=disable IrDA RX)
  [0FFD6h].1  Port 3 Data bit1 IN   IrDA RXD  ;\via serial IrDA registers
  [0FFD6h].2  Port 3 Data bit2 OUT  IrDA TXD  ;/
  [0FFDBh].2  Port 8 Data bit2 OUT  LED color?
  [0FFDBh].3  Port 8 Data bit3 OUT  LED color?
  [0FFDCh].0  Port 9 Data bit0 OUT  SPI EEPROM chipselect (0=select)
  [0FFDEh].0  Port B Data bit0 IN   Button input
  IrDA  IR Transfers
  SPI   SPI 8Kbyte EEPROM
  A/D   Used to read two single-axis sensors (for step counting)?
  A/D   Also used to read sum of eight A/D conversions (for wakeup from sleep)?
</TD></TR></TABLE>
The SPI EEPROM uses same commands as NDS cart savedata:<BR>
<A HREF="#dscartridgebackup">DS Cartridge Backup</A><BR>
<BR>
<B>Activity Meter RAM (1Kbyte, FB80h-FF7Fh)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  FB80h 1   Button flags (bit7=curr.state, bit6=newly.pressed, bit5=old.state)
  FB81h 1   ... cleared if memread src was unique_id (and other cases)
  FB82h 1   ... sys/power mode ?
  FB83h 1   ... adc_mode, or power_saving?
  FB84h 1   ... clock change request
  FB85h 1   ... led_extra_mask (never CLEARED, except on boot, or maybe via IR)
  FB86h 1   adc_array_index (index in ADC array X/Y, wraps in range 00h..3Fh)
  FB87h 1   ... entrysize of current data in ringbuf (per newest TAG) or so?
  FB88h 1   SPI overrun error (probably nonsense, SPI clk can't outrun itself)
  FB89h 1   Unused
  FB8Ah 1   num_steps_curr_minute (00h..FCh) (no conflict with tag FDh,FEh,FFh)
  FB8Bh 1   rtc_event_flags (bit0=minute, bit1=hour, bit2=day, bit3=also.hour)
  FB8Ch 1   ... timing offhold for various stuff
  FB8Dh 1   some_shift_amount         ;READ via IR
  FB8Eh 1   Daily goal reached flag (aka LED color) (bit0=reached, bit1=???)
  FB8Fh 1   ... timing for LED step pulses?
  FB90h 1   ... timing for LED step pulses?
  FB91h 1   ... flag for LED step pulse state?
  FB92h 1   Hour when new day starts (BCD, usually/always 03h)   ;READ via IR
  FB93h 1   ... some flag for inactivity low-power mode ?
  FB94h 1   LED animation number (1..5, or 0=none) (factory test result)
  FB95h 1   Unused
  FB96h 1   New day flag
  FB97h 1   Fixed LED mask (this is a "fixed" setting from EEPROM)
  FB98h 1   Compare_ctrl_0  ;\for "Compare Control" HW registers (89h,89h)
  FB99h 1   Compare_ctrl_1  ;/
  FB9Ah 1   New Goal flag (apply [FCF4h] as new goal, starting on next day?)
  FB9Bh 1   Unused
  FB9Ch 28h Unique ID ;READ via IR (initally set by NDS via RAM+EEPROM writes?)
  FBC4h 2   adc_current_x
  FBC6h 2   adc_current_y
  FBC8h 80h adc_array_x (40h x 16bit)
  FC48h 80h adc_array_y (40h x 16bit)
  FCC8h 2   adc_scale_factor_x  ;\scale factors
  FCCAh 2   adc_scale_factor_y  ;/
  FCCCh 2   adc_scale_unused_z  ;\semi-unused (written, but never read)
  FCCEh 2   adc_scale_unused_t  ;/
  FCD0h 2   ringbuf_mm_index (0020h..16A0h)   ;READ via IR
  FCD2h 2   ringbuf_hh_index (16A1h..1C42h)   ;READ via IR
  FBD4h 2   Unused
  FCD6h 2   ringbuf_dd_index (1C43h..1CDEh)   ;READ via IR
  FCD8h 2   num_steps_curr_hour    (16bit step counter for current hour)
  FCDAh 2   ringbuf_stepback_index (result from cmd_2Ah, to be read by cmd_0Ah)
  FCDCh 2   adc_inactivity_timer   (time since last pedometer step)
  FCDEh 2   SPI overrun error counter (related to flag at FB88h)
  FCE0h 2   Unused
  FCE2h 2   adc_current_sum (sum of eight A/D conversions)
  FCE4h 4   seconds_counter (seconds since 1st Jan 2001?, initially 0D2B0B80h)
  FCE8h 4   num_steps_lifelong (lifelong TOTAL steps)
  FCECh 4   num_steps_today    (step counter, for current day)
  FCF0h 4   Daily_goal         (WRITTEN via IR, NDS cart default=3000 decimal)
  FCF4h 4   new_goal_steps     (somewhat reload value for daily goal?)
  FCF8h 18h Unused
  FD10h 2   main_callback (main_adc_button_callback, or ir_callback)
  FD12h 40h ir_tx_data    (buffer for Memory &amp; EEPROM reads)
  FD52h 2   clk_callback  (clk_whatever_callback, or 0=none)
  FD54h 2   ir_callback   (ir_active_callback, or ir_dummy_callback)
  FD56h 2   ir_timestamp_last_byte (for sensing SHORT GAPs, aka end-of-packet)
  FD58h 2   RX chksum from hdr[2..3]
  FD5Ah 2   RX chksum from calculation
  FD5Ch 2   ir_timestamp_last_xfer (for sensing LONG GAPs, aka sleep mode)
  FD5Eh 1   Unused
  FD5Fh 1   ir_rx_len
  FD60h 1   ... semi-unused (set to 00h?) (but never read)
  FD61h 44h ir_rxtx_buf, hdr[4]+data[40h]
  FDA5h 1   ir_tx_hdr_len    ;\memorized TX len+hdr[4]
  FDA6h 4   ir_tx_hdr_copy   ;/(never actually used)
  FDAAh 1   bad_chksum_count, give up sending bad_chksum replies after 3 errors
  FDABh 1   bad_chksum_flag, request reply_FCh (bad_chksum)
  FDACh 80h ... array (40h x 16bit)          ;\
  FE2Ch 80h ... array (40h x 16bit)          ; analog sine/cosine
  FEACh 4   ... dword                        ; stuff for converting
  FEB0h 4   ... dword                        ; adc to step counter?
  FEB4h 1   ... byte                         ;
  FEB5h 1   ... byte                         ;/
  FEB6h 2   Incremented in main_adc_button_callback (but not used elsewhere)
  FEB8h 1   Unused                   ;\maybe meant to be 4-byte tx hdr,
  FEB9h 1   TX sequence number       ; but only hdr[1] used (as increasing
  FEBAh 2   Unused                   ;/seq.no for memory read/write replies)
  FEBCh 4   ... array (2 x 16bit)
  FEC0h 4   ... array (2 x 16bit)
  FEC4h 4   ... array (2 x 16bit)
  FEC8h 4   ... array (2 x 16bit)
  FECEh B2h CPU Stack area, initial SP=FF80h
</TD></TR></TABLE>
<BR>
<B>Activity Meter EEPROM (8Kbytes, serial SPI bus)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  EEPROM:0000h 9     ID "nintendo",00h (9 bytes)
  EEPROM:0009h 17h   Unused (FFh-filled)
  EEPROM:0020h 1681h Ringbuf_mm ;steps per MINUTE for 4 days ;(24*60*4-1)*8bit
  EEPROM:16A1h 5A2h  Ringbuf_hh ;steps per HOUR for 30 days  ;(24*30+1)*16bit
  EEPROM:1C43h 9Ch   Ringbuf_dd ;steps per DAY for 52 days   ;(52)*24bit
  EEPROM:1CDFh 1     Unused (FFh) (padding ringbuf's to 20h-byte-boundary)
  EEPROM:1CE0h 200h  Unused (FFh-filled)
  EEPROM:1EE0h 8+1   ADC_scale_values (4x16bit) ;RAM:FCC8h ;\
  EEPROM:1EE9h 2+1   ADC sum_limit              ;RAM:stack ; these EEPROM
  EEPROM:1EECh 3     Unused                                ; settings
  EEPROM:1EEFh 4+1   Num_steps_lifelong         ;RAM:FCE8h ; have 1-byte
  EEPROM:1EF4h 1+1   Fixed LED Mask             ;RAM:FB97h ; checksums
  EEPROM:1EF6h 2     Unused                                ; appended, and
  EEPROM:1EF8h 1+1   Some_shift_amount          ;RAM:FB8Dh ; backups at
  EEPROM:1EFAh 4+1   Daily_goal                 ;RAM:FCF0h ; 1F40h-1F9Fh
  EEPROM:1EFFh 4+1   New_goal_steps             ;RAM:FCF4h ;
  EEPROM:1F04h 28h+1 Unique ID                  ;RAM:FB9Ch ;
  EEPROM:1F2Dh 13h   Unused (00h-filled)                   ;/
  EEPROM:1F40h 60h   Backup copies of above data at 1EE0h..1F3Fh ;-backups
  EEPROM:1FA0h 2     Error code     (initially FFFFh)
  EEPROM:1FA2h 1     Reboot counter (initially 00h or 01h ?)
  EEPROM:1FA3h 5Dh   Unused (FFh-filled)
</TD></TR></TABLE>
The MM/HH/DD ring buffers are steps per minute/hour/day accordingly, mixed with
special tags:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00xxh          Zero steps for N minutes (N=max FCh)       ;\in ringbuf_mm
  xxh            N steps per minute (N=01h..FCh)            ;/
  xxxxh          N steps per hour (N=0000h..FFFFh)          ;-in ringbuf_hh
  xxxxxxh        N steps per day (N=000000h..FFFFFFh)       ;-in ringbuf_dd
  FDxxxxxxxxxxh  Timestamp, reversed-BCD-digit-order, seconds since 2001 or so?
  FEh            Newest entry marker?
  FFh            Unused entry marker?
</TD></TR></TABLE>
The firmware contains code for searching tags FDh/FEh/FFh forwards and
backwards, that works well with BCD values and 8bit counters, but unknown it
can work with the 16bit/24bit counters. The BCD digits are stored backwards
(eg. 12345 = FD5432100000h). Rinbuf pointers can be read from RAM locations
FCD0h, FCD2h, FCD6h, and FCDAh).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dscartinfraredpwalkerircommands"></A>
  DS Cart Infrared P-Walker IR Commands
</FONT></TD></TR></TABLE><BR>
Commands are usually send from NDS (or from other Walkers)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  EEPROM Commands  (Cmd 02,04,0C,0E,82)     ;\From NDS or Walker
  Connect Commands (Cmd F8,FA,FC)           ;/
  Peer Commands    (Cmd 10...1C)            ;-From Walker
  Unused Commands  (Cmd's with * marking)   ;-From Prototype tests?
  Other Commands   (Cmd's other than above) ;-From NDS
</TD></TR></TABLE>
<BR>
<B>Incoming Commands from NDS (or incoming commands/replies from another Walker)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00,hi,..,lzss(..)     EEPROM Write [hi00h..hi7Fh] Compressed   ;Reply=04
  80,hi,..,lzss(..)     EEPROM Write [hi80h..hiFFh] Compressed   ;Reply=04
  02,hi,..,data(..)     EEPROM Write [hi00h..hi7Fh] Raw          ;Reply=04
  82,hi,..,data(..)     EEPROM Write [hi80h..hiFFh] Raw          ;Reply=04
  04,xx,..              EEPROM Write Reply                     ;SendMoreCmd(s)
  06,hi,..,lo,data(nn)* CPU Memory Write [hilo+(0..nn-1)]        ;Reply=06
  0A,hi,..,lo,data(nn)* EEPROM Write Random Len [hilo+(0..nn-1)] ;Reply=04
  0C,xx,..,hi,lo,nn     EEPROM Read Request [hilo+(0..nn-1)]     ;Reply=0E
  0E,xx,..,data(nn)     EEPROM Read Reply                      ;SendMoreCmd(s)
  10,xx,..,data(68h)    Peer Step 1 Request                      ;Reply=12
  12,xx,..,data(68h)    Peer Step 1 Reply                      ;SendMoreCmd(s)
  14,xx,..,data(38h)    Peer Step 2 Request                      ;Reply=16
  16,xx,..              Peer Step 2 Reply                ;Reply=16 or None
  1C,xx,..              Peer Refuse                      ;Reply=None+Disconnect
  20,xx,..              Identity Read Request                    ;Reply=22
  24,xx,..            * Ping Request                             ;Reply=26
  2A,xx,..,none?        Unique ID Read Request                   ;Reply=2A
  2C,xx,..,none?      * Unique ID Read Request slightly other    ;Reply=2A
  32,xx,..,data(28h?) * Identity Write Request 1                 ;Reply=34
  36,xx,..            * Connection Error 1                       ;Reply=None
  38,xx,..            * Walk Start Silent                        ;Reply=38
  40,xx,..,data(28h?) * Identity Write Request 2                 ;Reply=42
  44,xx,..            * Connection Error 2                       ;Reply=None
  4E,xx,..              Walk End Request                         ;Reply=50
  52,xx,..,data(28h?)?? Identity Write Request 3                 ;Reply=54
  56,xx,..            * Connection Error 3                       ;Reply=None
  5A,xx,..              Walk Start Nonsilent                     ;Reply=5A
  60,xx,..,data(28h?) * Identity Write Request 4                 ;Reply=62
  64,xx,..            * Connection Error 4                       ;Reply=None
  66,xx,..            * Walk End Request OTHER                   ;Reply=68
  9C,xx,..            * Error Whatever                   ;Reply=9C+Disconnect
  9E,xx,..            * Error Weird Participate          ;Reply=9E+Disconnect
  A0,xx,..            * Weird Participate 1                  ;Reply=A0 or 9E
  A2,xx,..            * Weird Participate 2                  ;Reply=A2 or 9E
  A4,xx,..            * Weird Participate 3                  ;Reply=A4 or 9E
  A6,xx,..            * Weird Participate 4                  ;Reply=A6 or 9E
  A8,xx,..            * Weird Participate 5                  ;Reply=A8 or 9E
  AA,xx,..            * Weird Participate 6                  ;Reply=AA or 9E
  AC,xx,..            * Weird Participate 7                  ;Reply=AC or 9E
  AE,xx,..            * Weird Participate 8                  ;Reply=AE or 9E
  B8,xx,..            * Award Stamp Heart                        ;Reply=D8
  BA,xx,..            * Award Stamp Spade                        ;Reply=DA
  BC,xx,..            * Award Stamp Diamond                      ;Reply=DC
  BE,xx,..            * Award Stamp Club                         ;Reply=DE
  C0,xx,..            * Award Special Map                        ;Reply=C0
  C2,xx,..            * Award Event P-Letter                     ;Reply=C2
  C4,xx,..            * Award Event Item                         ;Reply=C4
  C6,xx,..            * Award Event Route                        ;Reply=C6
  D0,xx,..            * Award All Stamps and Special Map         ;Reply=C0
  D2,xx,..            * Award All Stamps and Event P-Letter      ;Reply=C2
  D4,xx,..            * Award All Stamps and Event Item          ;Reply=C4
  D6,xx,..            * Award All Stamps and Event Route         ;Reply=C6
  D8,xx,..            * Connection Error 5                       ;Reply=None
  F0,xx,..,data(71h) ?? Enroll Data (28h+40h+8+1 bytes)          ;Reply=F0
  F4,xx,..            * Disconnect                       ;Reply=None+Disconnect
  F8,02,..              Connection Reply from Walker             ;SendCmd=1002
  FA,01,..              Connection Request from NDS              ;Reply=F802
  FA,02,..              Connection Request from Walker           ;Reply=F802
  FA,xx,..              Connection Request invalid       ;Reply=None+Disconnect
  FC                    Connection Beacon from Walker            ;SendCmd=FA
  FE,01,..,data(8)    * EEPROM Write [0008h..000Fh]              ;Reply=FE
  xx                  * Ignored (single byte other than FC)      ;Reply=None
  xx,xx,..            * Invalid Cmd                              ;Reply=None
  xx,xx,xxxx          * Ignored (wrong 4-byte ID for Cmd 00-F7)  ;Reply=None
  xx,xx,xxxx          * Bad Checksum (disconnect if too often)   ;Reply=None
</TD></TR></TABLE>
<BR>
<B>Outgoing Replies to NDS (or outgoing commands/replies to another Walker)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  02,hi,..,data(nn)     EEPROM Write ...                         ;Cmd=Peer
  82,hi,..,data(nn)     EEPROM Write ...                         ;Cmd=Peer
  04,hi,..              EEPROM Write Reply                  ;Cmd=00/02/0A/80/82
  06,hi,..            * CPU Memory Write Reply                   ;Cmd=06h
  0C,02,..,hi,lo,nn     EEPROM Read Request  ;Peer, EEPROM Read  ;Cmd=0Eh
  0E,02,..,data(nn)     EEPROM Read Reply                        ;Cmd=0Ch
  10,02,..,data(68h)    Peer Step 1 Request (after Connect Reply);Cmd=F8h
  12,02,..,data(68h)    Peer Step 1 Reply                        ;Cmd=10h
  14,02,..,data(38h)    Peer Step 2 Request                      ;Cmd=0Eh
  16,02,..              Peer Step 2 Reply                        ;Cmd=14h/16h
  1C,02,..              Peer Refuse                              ;Cmd=10h/12h
  22,02,..,data(68h)    Identitiy Read Reply                     ;Cmd=20h
  26,02,..            * Ping Reply                               ;Cmd=24h
  2A,02,..,data(28h)    Unique ID Reply                          ;Cmd=2Ah/2Ch
  34,02,..            * Identitiy Write 1 Reply                  ;Cmd=32h
  38,02,..            * Walk Start silent Reply                  ;Cmd=38h
  42,02,..            * Identitiy Write 2 Reply                  ;Cmd=40h
  50,02,..              Walk End Reply                           ;Cmd=4Eh
  54,02,..           ?? Identitiy Write 3 Reply                  ;Cmd=52h
  5A,02,..              Walk Start nonsilent Reply               ;Cmd=5Ah
  62,02,..            * Identitiy Write 4 Reply                  ;Cmd=60h
  68,02,..            * Walk End OTHER Reply                     ;Cmd=66h
  9C,02,..            * Weird Whatever Reply-to-Reply?           ;Cmd=9Ch
  9E,02,..,data(11h)  * Weird Participated Reply                 ;Cmd=A0h..AEh
  9E,02,..            * Weird Participated Reply-to-Reply?       ;Cmd=9Eh
  A0,02,..,data(11h)  * Weird Participated Reply 1               ;Cmd=A0h
  A2,02,..,data(11h)  * Weird Participated Reply 2               ;Cmd=A2h
  A4,02,..,data(11h)  * Weird Participated Reply 3               ;Cmd=A4h
  A6,02,..,data(11h)  * Weird Participated Reply 4               ;Cmd=A6h
  A8,02,..,data(11h)  * Weird Participated Reply 5               ;Cmd=A8h
  AA,02,..,data(11h)  * Weird Participated Reply 6               ;Cmd=AAh
  AC,02,..,data(11h)  * Weird Participated Reply 7               ;Cmd=ACh
  AE,02,..,data(11h)  * Weird Participated Reply 8               ;Cmd=AEh
  C0,02,..            * Award Special Map Reply                  ;Cmd=C0h/D0h
  C2,02,..            * Award Event P-Letter Reply               ;Cmd=C2h/D2h
  C4,02,..            * Award Event Item Reply                   ;Cmd=C4h/D4h
  C6,02,..            * Award Event Route Reply                  ;Cmd=C6h/D6h
  C8,02,..            * Award Stamp Heart Reply                  ;Cmd=B8h
  CA,02,..            * Award Stamp Spade Reply                  ;Cmd=BAh
  CC,02,..            * Award Stamp Diamond Reply                ;Cmd=BCh
  CE,02,..            * Award Stamp Club Reply                   ;Cmd=BEh
  F0,02,..,data(28h) ?? Enroll Reply                             ;Cmd=F0h
  F8,02,..              Connect Reply                            ;Cmd=FAh
  FA,02,..              Connect Request from walker              ;Cmd=FCh
  FC                    Connection Beacon                        ;Button?
  FE,02,..            * EEPROM Write [0008h..000Fh] Reply        ;Cmd=FEh
  -?-                   Checksum Error... has no reply? or maybe sends Beacons?
</TD></TR></TABLE>
<BR>
<B>Notes</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  ..    short for 16bit Checksum at hdr[2..3] and 32bit Session ID at hdr[4..7]
  xx    somewhat don't care (usually 01h=From NDS, or 02h=From Walker)
</TD></TR></TABLE>
All 16bit checksum and the IR "encryption" (XOR by AAh), seem to be same as for
Activity Meter (see there, except use initial sum=2, not sum=0).<BR>
The Connect Request &amp; Reply commands are sending a "random" SessionID each,
all following commands/replies (except F8h and up) must use<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  SessionID = ConnectRequestRandomID XOR ConnectReplyRandomID.
</TD></TR></TABLE>
The Compressed EEPROM commands are writing decompressed 80h-bytes of data to
EEPROM (ie. the compression is only used to speedup the IR transfer, not to
save memory). The compression format is Nintendo's standard LZSS (including the
header value 10h, and little-endian 24bit length; which should be always 80h).
Special case: Compressed writes with exactly 80h bytes of incoming data are
treated as uncompressed writes (to be used when compression ratio is worse than
no compression).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dscartinfraredpwalkermemorymap"></A>
  DS Cart Infrared P-Walker Memory Map
</FONT></TD></TR></TABLE><BR>
<B>P-Walker SFR Usage</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  [0FFD4h].0  Port 1 Data bit0 OUT  SPI LCD chipselect (0=select)
  [0FFD4h].1  Port 1 Data bit1 OUT  SPI LCD access mode (0=Cmd, 1=Data)
  [0FFD4h].2  Port 1 Data bit2 OUT  SPI EEPROM chipselect (0=select)
  [0FFD6h].0  Port 3 Data bit0 OUT  IrDA PWDOWN (1=disable IrDA RX)
  [0FFD6h].1  Port 3 Data bit1 IN   IrDA RXD  ;\via serial IrDA registers
  [0FFD6h].2  Port 3 Data bit2 OUT  IrDA TXD  ;/
  [0FFDBh].2  Port 8 Data bit2      ?
  [0FFDBh].3  Port 8 Data bit3      ?
  [0FFDBh].4  Port 8 Data bit4 OUT  A/D related ... whatfor LCD? accel? batt?
  [0FFDCh].0  Port 9 Data bit0 OUT  SPI Accelerometer chipselect (0=select)
  [0FFDEh].0  Port B Data bit0 IN   ?  ;\
  [0FFDEh].2  Port B Data bit2 IN   ?  ; maybe buttons
  [0FFDEh].4  Port B Data bit4 IN   ?  ;/
  [0FFDEh].5  Port B Data bit5 OUT  ?
  Timer W General A/B/C  Audio Frequency/Volume
  IrDA                   IR Transfers
  SPI                    SPI 64Kbyte EEPROM, LCD Cmd/Data, Accelerometer
  A/D                    whatfor LCD? accel? batt?
</TD></TR></TABLE>
The SPI EEPROM uses same commands as NDS cart savedata:<BR>
<A HREF="#dscartridgebackup">DS Cartridge Backup</A><BR>
For the other two SPI-like devices, see:<BR>
<A HREF="#dscartinfraredpwalkerportslcdcontroller">DS Cart Infrared P-Walker Ports LCD Controller</A><BR>
<A HREF="#dscartinfraredpwalkerportsaccelerometerbma150">DS Cart Infrared P-Walker Ports Accelerometer BMA150</A><BR>
Note: SPI LCD chipselect is also used for outputting factory test results via
SPI bus (requires special hardware attached instead of the LCD screen).<BR>
<BR>
<B>RAM Map (2Kbytes, F780h..FF7Fh)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  F780h 60h      Misc variables
  F7E0h 2        main_callback                          ;&lt;--
  F7E2h ECh      Misc variables
  F8CEh 8+80h    Infrared RX/TX buffer hdr+data (also misc/heap)
  F956h 62Ah     Temp buffer, free RAM, and stack       ;&lt;--
  FF80h -        Stacktop (end of RAM)
</TD></TR></TABLE>
<BR>
<B>ROM Map</B><BR>
For some quick hacks, Dmitry recommends these ROM addresses (which won't work
when reflashing the firmware).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0772h          Send IR packet (F8D6h=src, r0l=len, r0h=hdr[0], r1l=hdr[1])
  08D6h          Default callback (when in IR transfer mode)
  259Eh          Watchdog refresh
</TD></TR></TABLE>
<BR>
<B>EEPROM Map</B><BR>
The EEPROM contains some important basic data, plus GUI related bitmaps (mostly
text strings pre-rendered as bitmaps for the local user name &amp; game
language) (and maybe(?) also game specific customizations).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0000h 8        ID "nintendo" (set after initial power-up eeprom init)
  0008h 8        ID whatever   (set via Cmd F0h and FEh) (never read)
  0010h 62h      ???
  0072h 1        Number of watchdog resets
  0073h 0Dh      ???
  0080h 02h+1    ADC calibration (factory-provided)               ;\
  0083h 28h+1    Unique ID      (set via Cmd F0h)                 ; with 1-byte
  00ACh 40h+1    LCD ConfigCmds (set via Cmd F0h)                 ; checksums
  00EDh 68h+1    Identity Data ("provisioned" at walk start time) ; and backup
  0156h 18h+1    Health Data   ("provisioned" at walk start time) ; copies at
  016Fh 01h+1    Copy Flag (00h=Normal, A5h=copy was interrupted) ; 0180h-027Fh
  0171h 0Fh      Unused                                           ;/
  0180h 100h     Backup copies of entries at 0080h-0017Fh
  0280h ...      Various Bitmaps
  8C70h ...      Various Garbage, Bitmaps, Items, Team, Route
  CE8Ah 2        current watts written to eeprom by cmd 20h before replying
                   (likely so remote can read them directly). u16 BE
  CE8Ch ...      Various stuff
  CEF0h 1Ch      Historic step count per day. u32 each, BE,
                   [0] is yesterday, [1] is day before, etc...
  CF0Ch ...      Various stuff
</TD></TR></TABLE>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 __________________ Data Structures (in EEPROM and Packets) ___________________
</TD></TR></TABLE>
<BR>
<B>Unique ID (28h bytes)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h 28h Generated by the DS game at pairing time, unique per walker
</TD></TR></TABLE>
<BR>
<B>Identity Data (68h bytes)   //stored reliably at 0x00ED/0x01ED</B><BR>
All multi-byte values LE, unless otherwise specified<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h 4   Unknown (LE, always 1?) ;\written from game packet at walk start
  04h 4   Unknown (LE, always 1?) ;  ;&lt;-- 0 at walk end  ;copied from [0]
  08h 2   Unknown (LE, always 7?) ;
  0Ah 2   Unknown (LE, always 7?) ;/ ;&lt;-- 0 at walk end  ;copied from [8?]
  0Ch 2   TrainerTID
  0Eh 2   TrainerSID
  10h 28h Unique ID
  38h 10h EventBitmap (aka bitfield with 128 event flags?)
  48h 10h Trainer Name (8 chars, using a custom 16bit charset, non-unicode)
  58h 1   Unknown
  59h 1   Unknown
  5Ah 1   Unknown
  5Bh 1   Flags (bit0=PairedToGame, bit1=HasPoke, bit2=PokeJoinedOnAWalk)
  5Ch 1   ProtoVer (02h)    (written by DS, refuse peer's with other values)
  5Dh 1   Unknown
  5Eh 1   ProtoSubver (00h) (written by DS, refuse peer's with other values)
  5Fh 1   Unknown (02h)     (written by DS at walk start)
  60h 4   LastSyncTime ;Big Endian  ;in WHAT... maybe seconds since WHEN?
  64h 4   StepCount    ;Big Endian  ;since WHEN... today? lifetime? lastsync?
</TD></TR></TABLE>
<BR>
<B>Peer Play Data (38h bytes)         //aka "PEER PLAY DATA"</B><BR>
All multi-byte values LE, unless otherwise specified<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h 4   curStepCount  (since WHEN?)
  04h 2   curWatts
  06h 2   Unused
  08h 4   Unknown, copied from IdentityData[00h]
  0Ch 2   Unknown, copied from IdentityData[08h]
  0Eh 2   Species
  10h 16h P-Nickname   (11 chars)  ;\the actual names in bitmap format
  26h 10h Trainer Name (8 chars)   ;/are stored elsewhere in EEPROM?
  36h 1   GenderForm
  37h 1   HasSpecialForms (spinda, arceus, unown, etc.)
</TD></TR></TABLE>
<BR>
<B>LcdConfigCmds (40h bytes)</B><BR>
Stored reliably at 00ACh/01ACh.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h 1   u8 contrastAndFlags (if 00h/FFh? commands at ROM:BEB8h will be used)
  01h 3Fh u8 commands[3fh] (Commands, or FDh,NNh=Delay(NNh), FEh=End of list)
</TD></TR></TABLE>
<BR>
<B>Enroll Data (71h bytes)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h 28h Unique ID             ;always written
  28h 40h LCD Config Data       ;written or verified depending on byte[70h]
  68h 8   Whatever ID           ;always written to EEPROM:0008h
  70h 1   LCD Action (00h=WriteA, 01h=Compare, 03h=WriteB, 02h/04h-FFh=Nop)
</TD></TR></TABLE>
<BR>
<B>HealthData (18h bytes)</B><BR>
Stored reliably at 0156h/0256h. Cached in RAM at F780h.<BR>
Big Endian unless otherwise noted.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h 4  u32 lifetimeTotalSteps
  04h 4  u32 todaySteps           //zeroed at midnight
  08h 4  u32 lastSyncTime
  0Ch 2  u16 totalDays
  0Eh 2  u16 curWatts
  10h 2  u16 unk_0
  12h 1  u8 unk_1
  13h 1  u8 unk_2
  14h 3  u8 padding[3]
  17h 1  u8 settings (bit0=isOnSpecialRoute, bit1-2=Volume, bit3-6=Contrast)
</TD></TR></TABLE>
<BR>
See Dmitry's webpage for more "game-specifc" data structures and memory
addresses.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dscartinfraredpwalkerportslcdcontroller"></A>
  DS Cart Infrared P-Walker Ports LCD Controller
</FONT></TD></TR></TABLE><BR>
<B>LCD Command Table</B><BR>
Commands are 1 or 2 bytes long (with D/C=Low, and, unlike normal SPI, one can
release /CS after each byte, even when sending 2-byte commands).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1st Byte     2nd Byte  Description
  00h+(0..Fh)  -       Set Column Address bit0-3   ;\VRAM xloc in 1-pixel units
  10h+(0..7)   -       Set Column Address bit4-6   ;/
  18h+(0..7)   -       Reserved
  20h+(0..7)   -       Set Internal Regulator Resistor Ratio
                         (0..7 = 2.3, 3.0, 3.7, 4.4, 5.1, 5.8, 6.5, 7.2)
  28h+(0..7)   -       Set Power Control Register
                         bit2: Internal Voltage Booster (0=Off, 1=On)
                         bit1: Internal Regulator       (0=Off, 1=On)
                         bit0: Output Op-amp Buffer     (0=Off, 1=On)
  30h+(0..0Fh) -       Reserved
  40h          00h-xxh Set Display Start Line (0..127?) (ROW) ("scroll yloc")
  41h+(0..2)   00h-xxh Same as above?
  44h          00h-xxh Set Display Offset (0..63) (COM0=ROW0..63) (pinout?)
  45h+(0..2)   00h-xxh Same as above?
  48h          00h-xxh Set Multiplex Ratio (num lines, duty 1/((16..64)+icon))
  49h+(0..2)   00h-xxh Same as above?
  4Ch          00h-3Fh Set N-line Inversion (0=Off, 1..31=Reduce crosstalk?)
  4Ch          20h-FFh Same as above?
  4Dh+(0..2)   00h-FFh Same as above?
  50h+(0..7)   -       Set LCD Bias (0..5=1/(4..9), 6=1/9, too)
  57h+(0..0Ch) -       Reserved
  64h+(0..3)   -       Set DC-DC Converter Factor (0=2x/3x, 1=4x, 2/3=5x)
  68h+(0..18h) -       Reserved
  81h          00h-3Fh Set Contrast (0..3Fh, 3Fh=Darkest)
  82h          OTP     Set VL6 voltage (00h..0Fh = original+Signed4bit(N))
  83h          OTP     OTP Programming?
  84h+(0..7)   -       Reserved
  88h          00h-FFh Set White Mode      (bit0-3=FrameA, bit4-7=FrameB)
  89h          00h-FFh Set White Mode      (bit0-3=FrameC, bit4-7=FrameD)
  8Ah          00h-FFh Set Light Gray Mode (bit0-3=FrameA, bit4-7=FrameB)
  8Bh          00h-FFh Set Light Gray Mode (bit0-3=FrameC, bit4-7=FrameD)
  8Ch          00h-FFh Set Dark Gray Mode  (bit0-3=FrameA, bit4-7=FrameB)
  8Dh          00h-FFh Set Dark Gray Mode  (bit0-3=FrameC, bit4-7=FrameD)
  8Eh          00h-FFh Set Black Mode      (bit0-3=FrameA, bit4-7=FrameB)
  8Fh          00h-FFh Set Black Mode      (bit0-3=FrameC, bit4-7=FrameD)
                         Above defines the grayscale palette for color 0-3,
                         normally all frames should use the same setting.
                         Color 0 is usually white (set to zero), color 3 is
                         usually black (set to number of levels selected via
                         cmd 90h). Color 1 and 2 are usually light/dark gray,
                         set to desired contrast, which may depend on the LCD.
  90h+(0..7)   -       Set PWM and FRC for gray-scale operation
                         bit0-1: Levels (0/1=Nine, 2=Twelve, 3=Fifteen Levels)
                         bit2:   Frames (0=Four, 1=Three Frames)
                         Note: Nintendo uses "9 levels" ranging from "0 to 9"
                         (maybe level 0 is treated as off, thus not counted)
  98h+(0..7)   -       Reserved
  A0h+(0..1)   -       Set Segment Remap (0=Col00h is SEG0, 1=Col7Fh is SEG0)
                         Aka xflip mirror?
  A2h+(0..1)   -       Set Icon Enable (0=Disable, 1=Enable)
  A4h+(0..1)   -       Set Entire Display On/Off (0=Show RAM, 1=All Pixels On)
  A6h+(0..1)   -       Set Inverse Display (0=Normal, 1=Inverse On/Off Pixels)
  A8h+(0..1)   -       Set Power Save Mode (0=Standby, 1=Sleep)
  AAh          -       Reserved
  ABh          -       Start Internal Oscillator (needed after reset)
  ACh+(0..1)   ?       Reserved
  AEh+(0..1)   -       Set Display On/Off (0=Off, 1=On)
  B0h+(0..0Fh) -       Set Page Address (00h..0Fh)  ;VRAM yloc in 8-pixel units
  C0h+(0,8)    -       Set COM Output Scan Direction (0=Normal, 8=Remapped)
                         Remapped: COM[0..(N-1)] becomes COM[(N-1)..0])
                         Aka yflip mirror?
  C1h+(0..6)   -       Same as above (Normal)
  C9h+(0..6)   -       Same as above (Remapped)
  D0h+(0..10h) -       Reserved
  E1h          -       Exit Power-save Mode (return from Sleep/Standby modes)
  E2h          -       Software Reset (initialize some internal registers)
  E3h          -       Reserved
  E4h          -       Exit N-line Inversion mode
  E5h+(0..2)   -       Reserved
  E8h          LEN+DTA Transfer VRAM Display Data (for 3-wire SPI mode only)
                         (LEN=00h-FFh, followed by LEN+1 data bytes)
  E9h+(0..6)   -       Reserved
  F0h+(0..0Fh) ..      Test mode commands and Extended features
  F0h          00h-03h Ext. Set VL6 Noise reduction (0=Enable, 3=Disable)
  F1h          08h-0Fh Ext. Set TC Value per 'C (0=-0.05%, 1=-0.07%, 2..7=?)
  F2h          00h-07h Ext. Oscillator Adjustment
                         (0..7 = -9%, -6%, -3%, +0%, +3%, +6%, +9%, +12%)
  F7h          00h-01h Ext. Oscillator Source (0=Internal, 1=External, 2=UNDOC)
  F6h          00h-1Fh Ext. Frame Frequency Adjust
                         bit0-2: FrameFQ (0..7 = 0..7)
                         bit3-4: Fosc    (0-3 = 59kHz, 75kHz, 94kHz, 113kHz)
  FBh          X2h,X6h Ext. Lock/Unlock Interface (bit2: 0=Unlock, 1=Lock)
</TD></TR></TABLE>
<BR>
<B>VRAM Writing</B><BR>
First set the VRAM address using three commands with D/C=Low:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h+(xloc) AND 0Fh     ;Set Column Address bit0-3
  10h+(xloc/10h)         ;Set Column Address bit4-6
  B0h+(yloc/8)           ;Set Page Address (00h..0Ah, other=reserved?)
</TD></TR></TABLE>
For the actual data transfer, set D/C=High and write data (each two bytes
contain vertical 8-pixel columns, with bit0=top, bit7=bottom):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1st byte = bitplane 1   ;\color 0..3 are usually white, lgray, dgray, black
  2nd byte = bitplane 0   ;/(palette can be changed via cmd 88h-8Fh though)
</TD></TR></TABLE>
Note: Column Address (xloc) is auto-incremented after each byte pair, the Page
Address (yloc) is NOT incremented when wrapping from x=7Fh to x=00h.<BR>
The last page is the "icon", this has only 1 pixel per xloc, maybe intended to
enable special symbols instead of pixels (on displays to combine symbols and
pixels).<BR>
<BR>
<B>VRAM Reading and Status Byte (both supported in parallel Non-SPI mode only)</B><BR>
The controller supports four modes (Nintendo uses the 4-wire SPI mode):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  3-wire SPI Serial write-only (/CS, CLK, MOSI, with cmd E8h instead D/C pin)
  4-wire SPI Serial write-only (/CS, CLK, MOSI, D/C=Data/Cmd)
  12-wire 8080 Parallel read/write (/CS, D0-D7, D/C, /RD, /WR)
  12-wire 6800 Parallel read/write (/CS, D0-D7, D/C, E, R/W)
</TD></TR></TABLE>
VRAM can be read setting the VRAM address as usually, and then reading with
D/C=High. And, an 8bit status byte can be read with D/C=Low:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7    BUSY    Chip is executing instruction (0=Ready, 1=Busy)
  6    ON      Display is On/Off             (0=Off, 1=On)
  5    RES     Chip is executing reset       (0=Ready, 1=Busy)
  4-0  -       Fixed Chip ID                 (08h=SSD1850)
</TD></TR></TABLE>
<BR>
<B>Note</B><BR>
Nintendo uses a 96x64 pixel grayscale LCD screen with 2bpp, without backlight
or frontlight. VRAM is double buffered (VRAM size is at least 96x128 pixels).<BR>
The display controller seems to be a Solomon System SSD1850 chip... or similar,
there are a number of datasheets that are more or less matching the LCD
commands used in the firmware:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  SSD0852  128x128 would allow double-buffer, but extended commands are wrong
  SSD0858  104x65  close, but extended commands are wrong
  SSD0859  128x81  could be correct (almost same as SSD1850)
  SSD1820  128x65  wrong, lacks palette (command 88h-8Fh)
  SSD1820A 128x65  wrong, lacks palette (command 88h-8Fh)
  SSD1821  128x81  wrong, lacks palette (command 88h-8Fh)
  SSD1850  128x65  could be correct (ysiz is good, but no double-buffering)
  SSD1851  128x81  as above, but more lines than needed
  SSD1852  128x128 would allow double-buffer, but extended commands are wrong
  SSD1854  128x160 wrong, uses 2-byte command B0h,YYh lacks extended commands
                   (also cmd 18h,20h,4xh,50h,60h-63h,64h,82h,83h,etc. differ)
  SSD1858  104x65  close, but lacks many extended commands
  SSD1859  128x81  could be correct (almost same as SSD1850)
</TD></TR></TABLE>
But, Nintendo's firmware contains extended command F7h,02h (which isn't
mentioned in any of the above datasheets).<BR>
And, the firmware seems to use two 64-line framebuffers at DisplayStart=0 and
DisplayStart=64, ie. needing 128 lines in total, which leaves no space for the
"icon" scanline (at least not addressable via cmd B0h+y).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dscartinfraredpwalkerportsaccelerometerbma150"></A>
  DS Cart Infrared P-Walker Ports Accelerometer BMA150
</FONT></TD></TR></TABLE><BR>
<B>Might do drilling machine, not good honking out paste pretty screenshot?</B><BR>
Official BMA150 register specs are in a Bosch-Captcha, which appears to be
intended to fool humans and bots alike (text on hatched background, undefined
color codes, increasingly unpleasant medusa-like details at closer look).
Anyways, here's a plaintext-hack of the Bosch-Captcha:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h  Chip ID     (bit7-3=Unused, bit2-0=02h)
  01h  Version     (bit7-4=al_version, bit3-0=ml_version) (undefined values)
  02h  Acc X Low   (bit7-6=DataLsb, bit5-1=Unused, bit0=NewDataFlag)
  03h  Acc X High  (bit7-0=DataMsb)
  04h  Acc Y Low   (bit7-6=DataLsb, bit5-1=Unused, bit0=NewDataFlag)
  05h  Acc Y High  (bit7-0=DataMsb)
  06h  Acc Z Low   (bit7-6=DataLsb, bit5-1=Unused, bit0=NewDataFlag)
  07h  Acc Z High  (bit7-0=DataMsb)
  08h  Temperature (bit7-0=DataTempMsb) (Lsb not existing, except in Trimming?)
  09h  Status Flags     (see below)
  0Ah  Control Flags    (see below)
  0Bh  Config Flags     (see below)
  0Ch  LG Threshold     (bit7-0)
  0Dh  LG Duration      (bit7-0)
  0Eh  HG Threshold     (bit7-0)
  0Fh  HG Duration      (bit7-0)
  10h  Any Motion Threshold (bit7-0)
  11h  Misc Stuff       (bit7-6=AnyMotionDur, bit5-3=HG Hyst, bit2-0=LG Hyst)
  12h  Customer Reserved 1 (bit7-0)
  13h  Customer Reserved 2 (bit7-0)
  14h  Range/Bandwidth  (bit7-5=Reserved, bit4-3=Range, bit2-0=Bandwidth)
  15h  Misc Flags       (see below)
  16h  Trimming X Low   (bit7-6=OffsetLsb, bit5-0=Gain)
  17h  Trimming Y Low   (bit7-6=OffsetLsb, bit5-0=Gain)
  18h  Trimming Z Low   (bit7-6=OffsetLsb, bit5-0=Gain)
  19h  Trimming T Low   (bit7-6=OffsetLsb, bit5-0=Gain)
  1Ah  Trimming X High  (bit7-0=OffsetMsb)
  1Bh  Trimming Y High  (bit7-0=OffsetMsb)
  1Ch  Trimming Z High  (bit7-0=OffsetMsb)
  1Dh  Trimming T High  (bit7-0=OffsetMsb)
  1Eh-22h BST reserved  (official blank/green)
  23h     BST reserved  (official blank/white)
  24h-2Ah Not used      (official gray/dither)
  2Bh-3Dh EEPROM Defaults for Registers 0Bh-1Dh
  3Eh-42h BST reserved  (official blank/orange)
  43h-49h Not used      (official gray/dither)
  4Ah-4Fh Not mentioned (official not here)
  50h-7Fh BST reserved  (official blank/cyan)
</TD></TR></TABLE>
Obscure Notes: Registers are 00h-06h,21h-22h,43h-7Fh are classifed as NOTHING,
07h-20h as IMAGE, and 23h-42h as EEPROM (whatever that crap means). Also,
Registers 00h-15h are OPERATIONAL, 16h-3Dh are DEFAULT SETTING, 3Eh-7Fh are
BOSCH SENSORTEC RESERVED.<BR>
<BR>
<B>Register 09h - Status Flags</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7   ST Result
  6-5 Not used (official piss/dither)
  4   Alert Phase
  3   LG_latched
  2   HG_latched
  1   LG_status
  0   HG_status
</TD></TR></TABLE>
<BR>
<B>Register 0Ah - Control Flags</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7   Reserved (official gray/dither)
  6   Reset INT
  5   Update IMAGE
  4   EE_W (uh? maybe eeprom write?)
  3   Self Test 1
  2   Self Test 0
  1   Soft Reset
  0   Sleep
</TD></TR></TABLE>
<BR>
<B>Register 0Bh - Config Flags</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7   Alert
  6   Any Motion
  5-4 Counter HG
  3-2 Counter LG
  1   Enable HG
  0   Enable LG
</TD></TR></TABLE>
<BR>
<B>Register 15h - Misc Flags</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7   SPI4
  6   enable_adv_INT
  5   new_data_INT
  4   latch_INT
  3   shadow_dis
  2-1 wake_up_pause
  0   wake_up
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dscartinfraredcomponentlists"></A>
  DS Cart Infrared Component Lists
</FONT></TD></TR></TABLE><BR>
<B>Gamecart for Walk with Me/Laufrhythmus</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Case "Nintendo, NTR-031. PAT. PEND., IMWPN1J12"
  PCB  "DA A-4  IRU01-10" (two layers) plus "IRL01-01 "(brown extra film layer)
  U1 32pin  "S906748-1, SanDisk, 11014-64B, P0A837.00, 0843, NTR-IMWP-1" (ROM)
  U2 32pin  "38600R, A06V, AH00167, 0832" (CPU, ROM 8Kbyte, RAM 0.5KByte)
  U3  5pin  "?" (OR-gate? flipflop?) (for forwarding SPI /CS to FLASH /CS)
  U4  8pin  "45PE80VG, HPAMZ V5, KOR 833X, ST e3" (SPI FLASH 1024 Kbytes)
  U1' 7pin  "5  S.. 9" IR transceiver (on brown film layer)
  X1  6pin  "737Wv"   ;7.37MHz?    /FLASH.CS --|""""|-- GND
  R1,R2,RA1 resistors                          | U3 |-- /SPI.CS (from NDS)
  C1,C2,C3,C4,C5,C6 capacitors         VDD33 --|____|-- U2.pinxxx
</TD></TR></TABLE>
Note: The printed part number on the CPU is 38600R, which does officially have
ROM 8Kbyte, RAM 0.5KByte (and the software does use only that much memory, but
it does actually contain twice as much ROM and RAM, ie. it seems to be a 38602R
chip... or, as the part number is wrong, it MIGHT even be a F38602 with FLASH
memory?).<BR>
IR transceiver wiring: 1=GND, 2=CPU.pin24=TXD, 3=CPU.pin25=RXD,
4=CPU.pin26=PWDOWN, 5=NC, 6=GND, 7=VCC.<BR>
<BR>
<B>Gamecart for P-Letter Black</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  PCB  "DI Y-1  IRC02-01" (two layers, without brown extra film layer)
  U1 32pin  "MXIC..." (ROM)
  U2 32pin  "..." (CPU, ROM 8Kbyte, RAM 0.5KByte)
  U3  5pin  "..." (OR-gate? flipflop?) (for forwarding SPI /CS to FLASH /CS)
  U4  8pin  "..." (SPI FLASH)
  U5  7pin  "..." IR transceiver
  X1  6pin  "..."
  R1,R2,RA1 resistors
  C1,C2,C3,C4,C5,C6 capacitors
</TD></TR></TABLE>
More or less same as in Walk with Me, but without film layer, and with
non-legible part numbers on existing photos.<BR>
<BR>
<B>Activity Meter (Actimeter in german) (Nintendo, 2008-2009)</B><BR>
NTR-IMWJ Aruite Wakaru Seikatsu Rhythm (JP)<BR>
NTR-IMWE Personal Trainer: Walking (US)<BR>
NTR-IMWP Walk with Me (EU) (Laufrhythmus in german)<BR>
NTR-IA8P Active Health with Carol Vorderman (EU)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Case "Nintendo DS, NTR-027, (C) 2008 Nintendo, NTR-A-HC, Made in Japan"
  Case "CE ./ VCI, ACN 060 566 083, Nintendo"
  PCB  "NTR-DHC-01" (in water resistant case)
  Ux  32pin Side-A "38602R, F22V, AH04731, 0834" (CPU, ROM 16Kbyte, RAM 1KByte)
  U2  8pin  Side-B "564X, 48H3, 30" (SPI EEPROM 8Kbyte, ST M95640-W or similar)
  U3  7pin  Side-B "1  S.  9" IR transceiver
  ??  2pin  Side-A huge smd capacitor shaped thing, maybe analog 1-axis sensor?
  ??  2pin  Side-A huge smd capacitor shaped thing, maybe analog 1-axis sensor?
  Ux/Qx     Side-A many small chips with 3-6 pins and few markings
  Xx  3pin  Side-A "CB825"      ;32.768-kHz or 38.4-kHz Crystal Resonator?
  Yx  6pin  Side-A ":i] 3.68t"  ;3.68MHz (115.2kHz*32)
  C1..C34   Plenty capacitors
  R1..R28   Plenty resistors
  BTI 2pin  Side-B Battery holder (for CR2032 H, 3V)
  Button    Side-A Push button (communication button)
  |&lt;  4pin  Side-A Two color LED
</TD></TR></TABLE>
Activity Meter Instruction Booklet, 310 pages: "Do not disassemble or attempt
to repair the Activity Meter yourself. Doing so could result in injury or
electrocution."<BR>
IR transceiver wiring: 1=BAT+, 2=TX-RC=NC?, 3=1K-to-CPU.pin25=RXD,
4=CPU.pin26=PWDOWN, 5=CPU.pin24=TXD, 6=?, 7=GND.<BR>
<BR>
<B>P-Walker (Nintendo, 2009)</B><BR>
NTR-IPKx/NTR-IPGx P-letter HeartGold/SoulSilver<BR>
TWL-IRBO/TWL-IRAO P-letter Black/White<BR>
TWL-IREO/TWL-IRDO P-letter Black/White 2<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Case "?"
  PCB "NTR-PHC-01" (with green solder stop &amp; unconventional black text layer)
  U1  32pin Side-B "F38606, F04V, AK04052, 0942" (CPU,FLASH 48Kbyte,RAM 2KByte)
  U2  4pin  Side-A "?"
  U3  4pin  Side-A "?"
  U4  4pin  Side-A "M_RA"
  U5  7pin  Side-B IR transceiver
  U6  8pin  Side-A "Sxxxx, xxxx" (maybe SPI EEPROM?)
  U7  12pin Side-B "043, A939, 021" (accelerometer?) (Bosch BMA150 ?)
  U8  5pin  Side-A "?"
  Q1  6pin  Side-A "Z4"
  D1  3pin  Side-A "?" dual diode or so
  X1  3pin  Side-B "EAJJ"       ;32.768-kHz or 38.4-kHz Crystal Resonator?
  Y1  6pin  Side-B "3.68"       ;3.68MHz (115.2kHz*32)
  BZ1 2pin  Side-B wires to piezo speaker (aka buzzer)
  CN1 14pin Side-A LCD connector 14pin? or 2x14pin? (without backlight)
            (with SSD1850 display controller (or similar) inside of LCD screen)
            (96x64 2-bit greyscale screen) (reportedly with SPI bus)
  BT+/-     Side-B Battery contacts for removeable battery (for CR2032, 3V)
  C1..C29   Plenty capacitors
  R1..R22   Plenty resistors
  SW's      Side-A Three buttons (left, center, right)
</TD></TR></TABLE>
<BR>
<B>Fit Meter (for Wii Fit U) (2013?)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  PCB "SAMU-01" (with green solder stop &amp; unconventional black text layer)
  U1  40pin Side-B "R5F101EEA, 1242KE415, SINGAPORE" (RL78 CPU)
  U2  7pin  Side-B "845G2947" IR transceiver, with metal shield
  U3  16pin Side-B (not installed)
  U4  16pin Side-A --UNKNOWN MARKING, BAD PHOTO-- maybe accelerometer
  U5  4pin  Side-A --UNKNOWN MARKING, BAD PHOTO-- maybe SPI EEPROM/FLASH
  U6  4pin  Side-A (not installed)
  U7  7pin  Side-B "I357, U231, 094" whatever, in metal shielded case
  X1  3pin  Side-B "EABL" crystal or so
  BZ1 2pin  Side-B wires to piezo speaker (aka buzzer)
  CN1 14pin Side-A LCD connector 14pin? or 2x14pin? (without backlight)
  BT+/-     Side-B Battery contacts for removeable battery
  Q1  3pin  Side-A Transistor or so
  D1..D2    Side-A Diodes (3pin each)
  C1..C29   Plenty capacitors
  R1..R22   Plenty resistors
  SW's      Side-A Three buttons (left, center, right)
</TD></TR></TABLE>
Similar as P-Walker, but uses a RL78 CPU (alike 3DS MCU) instead of H8/386.<BR>
<BR>
The IR transceivers do resemble RPM841-H16 or similar (as used in 3DS). Observe
that 7pin transceiver pinouts are NOT same. Walk with Me, Activity Meter, and
3DS all have different 7pin transceiver wirings (and, some have additional
metal shields).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="h8386sfrs"></A>
  H8/386 SFRs
</FONT></TD></TR></TABLE><BR>
<B>H8/386 Special Function Registers at F000h and up</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  F020h FLMCR1  FLASH Memory Control 1
  F021h FLMCR2  FLASH Memory Control 2
  F022h FLPWCR  FLASH Memory Power Control
  F023h EBR1    FLASH Erase Block 1
  F02Bh FENR    FLASH Memory Enable
  F067h RTCFLG  RTC Interrupt Flag
  F068h RSECDR  RTC Seconds / Free running counter
  F069h RMINDR  RTC Minutes
  F06Ah RHRDR   RTC Hours
  F06Bh RWKDR   RTC Day-of-week
  F06Ch RTCCR1  RTC Control 1
  F06Dh RTCCR2  RTC Control 2
  F06Fh RTCCSR  RTC Clock Source Select
  F078h ICCR1   I2C Bus Control 1
  F079h ICCR2   I2C Bus Control 2
  F07Ah ICMR    I2C Bus Mode
  F07Bh ICIER   I2C Bus Interrupt Enable
  F07Ch ICSR    I2C Bus Status
  F07Dh SAR     I2C Slave Address
  F07Eh ICDRT   I2C Bus Transmit Data
  F07Fh ICDRR   I2C Bus Receive Data
  F085h PFCR    System Port Function Control
  F086h PUCR8   Port 8 Pull-up Control
  F087h PUCR9   Port 9 Pull-up Control
  F08Ch PODR9   Port 9 Open-drain Control
  F0D0h TMB1    Timer B1 Mode
  F0D1h TC/LB1  Timer B1 Counter (R) / Load (W)
  F0DCh CMCR0   Compare Control 0
  F0DDh CMCR1   Compare Control 1
  F0DEh CMDR    Compare Data
  F0E0h SSCRH   SPI Synchronous Serial Control H     (AccessState3)
  F0E1h SSCRL   SPI Synchronous Serial Control L     (AccessState3)
  F0E2h SSMR    SPI Synchronous Serial Mode          (AccessState3)
  F0E3h SSER    SPI Synchronous Serial Enable        (AccessState3)
  F0E4h SSSR    SPI Synchronous Serial Status        (AccessState3)
  F0E9h SSRDR   SPI Synchronous Serial Receive Data  (AccessState3)
  F0EBh SSTDR   SPI Synchronous Serial Transmit Data (AccessState3)
  F0F0h TMRW    Timer W Mode
  F0F1h TCRW    Timer W Control
  F0F2h TIERW   Timer W Interrupt Enable
  F0F3h TSRW    Timer W Status
  F0F4h TIOR0   Timer W I/O control 0
  F0F5h TIOR1   Timer W I/O control 1
  F0F6h TCNT    Timer W Counter   (16bit)
  F0F8h GRA     Timer W General A (16bit)
  F0FAh GRB     Timer W General B (16bit)
  F0FCh GRC     Timer W General C (16bit)
  F0FEh GRD     Timer W General D (16bit)
</TD></TR></TABLE>
<B>H8/386 Special Function Registers at FF80h and up, with [FFnn] &amp; [FFnn].bitno</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  FF8Ch ECPWCR  Async Event Counter PWM Compare (16bit)
  FF8Eh ECPWDR  Async Event Counter PWM Data (16bit)
  FF91h SPCR    IrDA UART Serial 3 Port Control
  FF92h AEGSR   Async Event Input Pin Edge Select
  FF94h ECCR    Async Event Counter Control
  FF95h ECCSR   Async Event Counter Control/Status
  FF96h ECH     Async Event Counter H
  FF97h ECL     Async Event Counter L
  FF98h SMR3    IrDA UART Serial 3 Mode          (AccessState3)
  FF99h BRR3    IrDA UART Serial 3 Bit Rate      (AccessState3)
  FF9Ah SCR3    IrDA UART Serial 3 Control       (AccessState3)
  FF9Bh TDR3    IrDA UART Serial 3 Transmit Data (AccessState3)
  FF9Ch SSR3    IrDA UART Serial 3 Status        (AccessState3)
  FF9Dh RDR3    IrDA UART Serial 3 Receive Data  (AccessState3)
  FFA6h SEMR    IrDA UART Serial 3 Extended Mode (AccessState3)
  FFA7h IrCR    IrDA Control
  FFB0h TMWD    Timer WD Watchdog Mode
  FFB1h TCSRWD1 Timer WD Watchdog Control/Status 1
  FFB2h TCSRWD2 Timer WD Watchdog Control/Status 2
  FFB3h TCWD    Timer WD Watchdog Counter
  FFBCh ADRR    A/D Converter Result (16bit)
  FFBEh AMR     A/D Converter Mode
  FFBFh ADSR    A/D Converter Start
  FFC0h PMR1    Port 1 Mode
  FFC2h PMR3    Port 3 Mode
  FFCAh PMRB    Port B Mode
  FFD4h PDR1    Port 1 Data
  FFD6h PDR3    Port 3 Data
  FFDBh PDR8    Port 8 Data
  FFDCh PDR9    Port 9 Data
  FFDEh PDRB    Port B Data
  FFE0h PUCR1   Port 1 Pull-up Control
  FFE1h PUCR3   Port 3 Pull-up Control
  FFE4h PCR1    Port 1 Control
  FFE6h PCR3    Port 3 Control
  FFEBh PCR8    Port 8 Control
  FFECh PCR9    Port 9 Control
  FFF0h SYSCR1  System Control 1
  FFF1h SYSCR2  System Control 2
  FFF2h IEGR    Interrupt Edge Select
  FFF3h IENR1   Interrupt Enable 1
  FFF4h IENR2   Interrupt Enable 2
  FFF5h OSCCR   System Oscillator Control
  FFF6h IRR1    Interrupt Flag 1
  FFF7h IRR2    Interrupt Flag 2
  FFFAh CKSTPR1 Clock Stop 1
  FFFBh CKSTPR2 Clock Stop 2
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="h8386exceptionvectors"></A>
  H8/386 Exception Vectors
</FONT></TD></TR></TABLE><BR>
<B>H8/386 Exception Vectors (Vector 0000h has highest priority, 004Eh lowest)</B><BR>
Below are for Normal Mode with 16bit addressing (Extended Mode has 32bit
vectors at 0000h..009Fh accordingly).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0000h Reset/Watchdog
  0002h Reserved
  0004h Reserved
  0006h Reserved
  0008h Reserved
  000Ah Reserved
  000Ch Reserved
  000Eh External NMI interrupt
  0010h Trap 0 opcode
  0012h Trap 1 opcode
  0014h Trap 2 opcode
  0016h Trap 3 opcode
  0018h Reserved
  001Ah CPU Direct transition by executing SLEEP
  001Ch Reserved
  001Eh Reserved
  0020h External IRQ0 interrupt
  0022h External IRQ1 interrupt
  0024h External IRQAEC interrupt
  0026h Reserved
  0028h Reserved
  002Ah Comparator COMP0
  002Ch Comparator COMP1
  002Eh RTC per 0.25 seconds (4Hz)  ;0.25-second overflow
  0030h RTC per 0.5 seconds (2Hz)   ;0.5-second overflow
  0032h RTC per second (1Hz)        ;Second periodic overflow
  0034h RTC per minute              ;Minute periodic overflow
  0036h RTC per hour                ;Hour periodic overflow
  0038h RTC per day                 ;Day-of-week periodic overflow
  003Ah RTC per week (7 days)       ;Week periodic overflow
  003Ch RTC Free-running overflow
  003Eh WDT overflow (interval timer)
  0040h Asynchronous event counter overflow
  0042h Timer B1 Overflow
  0044h Serial SPI (or IIC2) (aka I2C ?)
  0046h Timer W Overflow or Capture/compare A,B,C,D
  0048h Reserved
  004Ah IrDA UART Serial 3
  004Ch A/D Conversion end
  004Eh Reserved
</TD></TR></TABLE>
Note: The SSU (aka SPI) and IIC (aka I2C) share the same vector address. When
using the IIC, shift the SSU to standby mode using CKSTPR2.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="h8300hoperands"></A>
  H8/300H Operands
</FONT></TD></TR></TABLE><BR>
<B>CPU Registers</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  R0..R6  32bit General Purpose   ;\can be alternately used as
  R7 (SP) 32bit Stack Pointer     ;/8bit/16bit registers (see below)
  PC      24bit Program Counter
  CCR     8bit  Flags (occupies 16bit when pushed/stored in memory)
</TD></TR></TABLE>
Registers R0..R7 can be split into 8bit/16bit registers (alike 80x86
registers):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  .-----------------------.
  | ERx                   | 32bit  (ERx)
  |-----------+-----------|
  | Ex        | Rx        | 16bit  (Rx)
  '-----------+-----+-----|
              ' RxH | RxL | 8bit   (RxB)
              '-----'-----'
</TD></TR></TABLE>
There are no opcodes for splitting upper 16bit in Ex into 8bit ExL,ExH (except,
the sign/zero-extend opcodes seem to allow to extend ExL to Ex).<BR>
<BR>
<B>Normal and Extended Mode</B><BR>
The CPU can be wired to two different addressing modes:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Normal Mode   --&gt; 16bit addressing (default)
  Extended Mode --&gt; 24bit addressing
</TD></TR></TABLE>
Normal mode is usually used (the CPU has less than 64K ROM/RAM anyways), the
opcodes with [er0..er7] memory addressing are then actually accessing [r0..r7],
ie. the upper 16bit in e0..e7 are ignored (and can be used for general purpose
data).<BR>
Extended mode, if it were ever used, uses the lower 24bit of er0..er7 for
[er0..er7] addressing, and CALL/RET and indirect JMP opcodes are a bit slower,
and exception vectors are 32bit wide.<BR>
<BR>
<B>Memory Addressing</B><BR>
Data is stored in Big-Endian. 16bit/32bit values must be stored at even
addresses (with bit0 cleared) (there is no need to clear bit1 for 32bit values,
namely, push/pop work regardless of bit1).<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Native        Nocash
  @aa:8         [FFaa]        Memory at FF00h..FFFFh (upper RAM and SFR's)
  @aa:16        [nnnn]
  @aa:24        [nnnnnn]
  @Erm          [Erm]
  @(d:16,ERm)   [ERm+nnnn]
  @(d:24,ERm)   [ERm+nnnnnn]
  @ERm+         [ERm+]          Memory access with post-increment
  @-ERm         [ERm-]          Memory access with pre-decrement
  (implied)     [ER6+],[ER5+]   Memory block transfer (EEPMOV)
</TD></TR></TABLE>
<BR>
<B>Bit Addressing</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Native        Nocash
  #nn:8,@aa:8   [FFaa].n
  RnB,@aa:8     [FFaa].RnB
  #nn:8,RdB     RdB.n
  RnB,RdB       RdB.RnB
</TD></TR></TABLE>
Note: The "#nn:8" suggests native syntax to use "#0x80" to select bit7,
however, the existing disassembler does instead use "#7".<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="h8300hopcodes"></A>
  H8/300H Opcodes
</FONT></TD></TR></TABLE><BR>
All opcodes are multiples of 2 bytes (2,4,6,8,10 bytes), all opcodes should be
always located at even addresses (ie. bit0 of jump address/disp operands should
be always 0).<BR>
<BR>
<B>Register Encoding</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0..7  8bit Registers R0H..R7H  (bit8-15)     ;\RxB
  8..F  8bit Registers R0L..R7L  (bit0-7)      ;/
  0..7  16bit Registers R0..R7   (bit0-15)     ;\Rx
  8..F  16bit Registers E0..E7   (bit16-31)    ;/
  0..7  32bit Registers ER0..ER7 (bit0-31)     ;-ERx (in normal opcodes)
  8..F  32bit Registers ER0..ER7 (bit0-31)     ;-ERx (in opcodes marked *m,*s)
</TD></TR></TABLE>
<BR>
<B>H8/300H Main Opcodes</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Opcode             Native                  Nocash             States IxHUNZVC
  0..                --&gt; Misc 0xxx
  1..                --&gt; Misc 1xxx
  2dnn               MOV.B @aa:8,RdB         MOV.B RdB,[FFaa]        4 ----nz0-
  3snn               MOV.B Rs,@aa:8          MOV.B [FFaa],Rs         4 ----nz0-
  4cnn               --&gt; Jumps (relative 8bit range)
  5..                --&gt; Jumps (various) and unsigned mul/div
  6..                --&gt; Misx 6xxx
  7..                --&gt; Misc 7xxx
  8dnn               ADD.B #nn:8,RdB         ADD.B RdB,nn            2 --h-nzvc
  9dnn               ADDX  #nn:8,RdB         ADC.B RdB,nn            2 --h-nzvc
  Adnn               CMP.B #nn:8,RdB         CMP.B RdB,nn            2 --h-nzvc
  Bdnn               SUBX  #nn:8,RdB         SBC.B RdB,nn            2 --h-nzvc
  Cdnn               OR.B  #nn:8,RdB         OR.B  RdB,nn            2 ----nz0-
  Ddnn               XOR.B #nn:8,RdB         XOR.B RdB,nn            2 ----nz0-
  Ednn               AND.B #nn:8,RdB         AND.B RdB,nn            2 ----nz0-
  Fdnn               MOV.B #nn:8,RdB         MOV.B RdB,nn            2 ----nz0-
</TD></TR></TABLE>
<BR>
<B>H8/300H Misc 0xxx</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0000               NOP                     NOP                     2 --------
  01..               --&gt; Misc 01xx ;Memory Load/Store (32bit ERn) etc.
  020d               STC.B CCR,RdB           MOV.B RdB,CCR           2 --------
  030s               LDC.B RsB,CCR           MOV.B CCR,RsB           2 xxxxxxxx
  04nn               ORC   #nn:8,CCR         OR.B  CCR,nn            2 xxxxxxxx
  05nn               XORC  #nn:8,CCR         XOR.B CCR,nn            2 xxxxxxxx
  06nn               ANDC  #nn:8,CCR         AND.B CCR,nn            2 xxxxxxxx
  07nn               LDC.B #nn:8,CCR         MOV.B CCR,nn            2 xxxxxxxx
  08sd               ADD.B RsB,RdB           ADD.B RdB,RsB           2 --h-nzvc
  09sd               ADD.W Rs,Rd             ADD.W Rd,Rs             2 --h-nzvc
  0A..               --&gt; Increment/Add
  0B..               --&gt; Increment/Add
  0Csd               MOV.B RsB,RdB           MOV.B RdB,RsB           2 ----nz0-
  0Dsd               MOV.W Rs,Rd             MOV.W Rd,Rs             2 ----nz0-
  0Esd               ADDX  RsB,RdB           ADC.B RdB,RsB           2 --h-nzvc
  0F0d               DAA   RdB               DAA.B RdB               2 --U-nzUc
  0Fsd            *s MOV.L ERs,ERd           MOV.L ERd,ERs           2 ----nz0-
</TD></TR></TABLE>
<BR>
<B>H8/300H Misc 01xx ;Memory Load/Store (32bit ERn) etc.</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  010069md           MOV.L @ERm,ERd          MOV.L ERd,[ERm]         8 ----nz0-
  014069m0           LDC.W @ERm,CCR          MOV.W CCR,[ERm]         6 xxxxxxxx
  010069ms        *m MOV.L ERs,@ERm          MOV.L [ERm],ERs         8 ----nz0-
  014069m0        *m STC.W CCR,@ERm          MOV.W [ERm],CCR         6 --------
  01006B0dnnnn       MOV.L @aa:16,ERd        MOV.L ERd,[nnnn]       10 ----nz0-
  01406B00nnnn       LDC.W @aa:16,CCR        MOV.W CCR,[nnnn]        8 xxxxxxxx
  01006B2d00nnnnnn   MOV.L @aa:24,ERd        MOV.L ERd,[nnnnnn]     12 ----nz0-
  01406B2000nnnnnn   LDC.W @aa:24,CCR        MOV.W CCR,[nnnnnn]     10 xxxxxxxx
  01006B8snnnn       MOV.L ERs,@aa:16        MOV.L [nnnn],ERs       10 ----nz0-
  01406B80nnnn       STC.W CCR,@aa:16        MOV.W [nnnn],CCR        8 --------
  01006BAs00nnnnnn   MOV.L ERs,@aa:24        MOV.L [nnnnnn],ERs     12 ----nz0-
  01406BA000nnnnnn   STC.W CCR,@aa:24        MOV.W [nnnnnn],CCR     10 --------
  01006Dmd           MOV.L @ERm+,ERd         MOV.L ERd,[ERm+]       10 ----nz0-
  01406Dm0           LDC.W @ERm+,CCR         MOV.W CCR,[ERm+]        8 xxxxxxxx
  01006Dms        *m MOV.L ERs,@-ERm         MOV.L [ERm-],ERs       10 ----nz0-
  01406Dm0        *m STC.W CCR,@-ERm         MOV.W [ERm-],CCR        8 --------
  01006Fmdnnnn       MOV.L @(d:16,ERm),ERd   MOV.L ERd,[ERm+nnnn]   10 ----nz0-
  01406Fm0nnnn       LDC.W @(d:16,ERm),CCR   MOV.W CCR,[ERm+nnnn]    8 xxxxxxxx
  01006Fmsnnnn    *m MOV.L ERs,@(d:16,ERm)   MOV.L [ERm+nnnn],ERs   10 ----nz0-
  01406Fm0nnnn    *m STC.W CCR,@(d:16,ERm)   MOV.W [ERm+nnnn],CCR    8 --------
  010078m06B2d00..   MOV.L @(d:24,ERm),ERd   MOV.L ERd,[ERm+nnnnnn] 14 ----nz0-
  014078m06B2000..   LDC.W @(d:24,ERm),CCR   MOV.W CCR,[ERm+nnnnnn] 12 xxxxxxxx
  010078m06BAs00..*? MOV.L ERs,@(d:24,ERm)   MOV.L [ERm+nnnnnn],ERs 14 ----nz0-
  014078m06BA000..   STC.W CCR,@(d:24,ERm)   MOV.W [ERm+nnnnnn],CCR 12 --------
  0180               SLEEP                   HALT                    2 --------
  01C050sd           MULXS.B RsB,Rd          SMUL.B Rd,RsB          16 ----nz--
  01C052sd           MULXS.W Rs,ERd          SMUL.W ERd,Rs          24 ----nz--
  01D051sd           DIVXS.B RsB,Rd          SDIV.B Rd,RsB          16 ----nz--
  01D053sd           DIVXS.W Rs,ERd          SDIV.W ERd,Rs          24 ----nz--
  01F064sd           OR.L    ERs,ERd         OR.L   ERd,ERs          4 ----nz0-
  01F065sd           XOR.L   ERs,ERd         XOR.L  ERd,ERs          4 ----nz0-
  01F066sd           AND.L   E?Rs,ERd        AND.L  ERd,ERs          4 ----nz0-
</TD></TR></TABLE>
<BR>
<B>H8/300H Misc 1xxx</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  10..               --&gt; Shift/Rotate (shift left)
  11..               --&gt; Shift/Rotate (shift right)
  12..               --&gt; Shift/Rotate (rotate left)
  13..               --&gt; Shift/Rotate (rotate right)
  14sd               OR.B  RsB,RdB           OR.B  RdB,RsB           2 ----nz0-
  15sd               XOR.B RsB,RdB           XOR.B RdB,RsB           2 ----nz0-
  16sd               AND.B RsB,RdB           AND.B RdB,RsB           2 ----nz0-
  17..               --&gt; Not/Neg/Extend
  18sd               SUB.B RsB,RdB           SUB.B RdB,RsB           2 --h-nzvc
  19sd               SUB.W Rs,Rd             SUB.W Rd,Rs             2 --h-nzvc
  1A..               --&gt; Decrement/Subtract
  1B..               --&gt; Decrement/Subtract
  1Csd               CMP.B RsB,RdB           CMP.B RdB,RsB           2 --h-nzvc
  1Dsd               CMP.W Rs,Rd             CMP.W Rd,Rs             2 --h-nzvc
  1Esd               SUBX  RsB,RdB           SBC.B RdB,RsB           2 --h-nzvc
  1F0d               DAS   RdB               DAS.B RdB               2 --U-nzU?
  1Fsd            *s CMP.L ERs,ERd           CMP.L ERd,ERs           2 --h-nzvc
</TD></TR></TABLE>
<BR>
<B>H8/300H Shift/Rotate (Shift Logical/Arithmetic, Rotate through Carry or not)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  100d               SHLL.B RdB              SHL.B RdB               2 ----nz0c
  101d               SHLL.W Rd               SHL.W Rd                2 ----nz0c
  103d               SHLL.L ERd              SHL.L ERd               2 ----nz0c
  108d               SHAL.B RdB              SAL.B RdB               2 ----nzvc
  109d               SHAL.W Rd               SAL.W Rd                2 ----nzvc
  10Bd               SHAL.L ERd              SAL.L ERd               2 ----nzvc
  110d               SHLR.B RdB              SHR.B RdB               2 ----0z0c
  111d               SHLR.W Rd               SHR.W Rd                2 ----0z0c
  113d               SHLR.L ERd              SHR.L ERd               2 ----0z0c
  118d               SHAR.B RdB              SAR.B RdB               2 ----nz0c
  119d               SHAR.W Rd               SAR.W Rd                2 ----nz0c
  11Bd               SHAR.L ERd              SAR.L ERd               2 ----nz0c
  120d               ROTXL.B RdB             RCL.B RdB               2 ----nz0c
  121d               ROTXL.W Rd              RCL.W Rd                2 ----nz0c
  123d               ROTXL.L ERd             RCL.L ERd               2 ----nz0c
  128d               ROTL.B RdB              ROL.B RdB               2 ----nz0c
  129d               ROTL.W Rd               ROL.W Rd                2 ----nz0c
  12Bd               ROTL.L ERd              ROL.L ERd               2 ----nz0c
  130d               ROTXR.B RdB             RCR.B RdB               2 ----nz0c
  131d               ROTXR.W Rd              RCR.W Rd                2 ----nz0c
  133d               ROTXR.L ERd             RCR.L ERd               2 ----nz0c
  138d               ROTR.B RdB              ROR.B RdB               2 ----nz0c
  139d               ROTR.W Rd               ROR.W Rd                2 ----nz0c
  13Bd               ROTR.L ERd              ROR.L ERd               2 ----nz0c
</TD></TR></TABLE>
<BR>
<B>H8/300H Not/Neg/Extend</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  170d               NOT.B RdB               NOT.B RdB               2 ----nz0-
  171d               NOT.W Rd                NOT.W Rd                2 ----nz0-
  173d               NOT.L Rd                NOT.L ERd               2 ----nz0-
  175d               EXTU.W Rd               UMOV Rd,RdL ;or Ed,EdL? 2 ----0z0-
  177d               EXTU.L ERd              UMOV ERd,Rd             2 ----0z0-
  178d               NEG.B RdB               NEG.B RdB               2 --h-nzvc
  179d               NEG.W Rd                NEG.W Rd                2 --h-nzvc
  17Bd               NEG.L Rd                NEG.L ERd               2 --h-nzvc
  17Dd               EXTS.W Rd               SMOV Rd,RdL ;or Ed,EdL? 2 ----nz0-
  17Fd               EXTS.L ERd              SMOV ERd,Rd             2 ----nz0-
</TD></TR></TABLE>
<BR>
<B>H8/300H Increment/Add and Decrement/Subtract</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0A0d               INC.B RdB               INC.B RdB,1             2 ----nzv-
  1A0d               DEC.B RdB               DEC.B RdB,1             2 ----nzv-
  0Asd            *s ADD.L E?Rs,ERd          ADD.L ERd,ERs           2 --h-nzvc
  1Asd            *s SUB.L ERs,ERd           SUB.L ERd,ERs           2 --h-nzvc
  0B0d               ADDS  #1,ERd            INC.S ERd,1             2 --------
  1B0d               SUBS  #1,ERd            DEC.S ERd,1             2 --------
  0B5d               INC.W #1,Rd             INC.W Rd,1              2 ----nzv-
  1B5d               DEC.W #1,Rd             DEC.W Rd,1              2 ----nzv-
  0B7d               INC.L #1,ERd            INC.L ERd,1             2 ----nzv-
  1B7d               DEC.L #1,ERd            DEC.L ERd,1             2 ----nzv-
  0B8d               ADDS  #2,ERd            INC.S ERd,2             2 --------
  1B8d               SUBS  #2,ERd            DEC.S ERd,2             2 --------
  0B9d               ADDS  #4,ERd            INC.S ERd,4             2 --------
  1B9d               SUBS  #4,ERd            DEC.S ERd,4             2 --------
  0BDd               INC.W #2,Rd             INC.W Rd,2              2 ----nzv-
  1BDd               DEC.W #2,Rd             DEC.W Rd,2              2 ----nzv-
  0BFd               INC.L #2,ERd            INC.L ERd,2             2 ----nzv-
  1BFd               DEC.L #2,ERd            DEC.L ERd,2             2 ----nzv-
</TD></TR></TABLE>
<BR>
<B>H8/300H Jump Opcodes and Unsigned Mul/Div</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  50sd               MULXU.B RsB,Rd          UMUL.B Rd,RsB          14 ----nz--
  51sd               DIVXU.B RsB,Rd          UDIV.B Rd,RsB          14 ----nz--
  52sd               MULXU.W Rs,ERd          UMUL.W ERd,Rs          22 ----nz--
  53sd               DIVXU.W Rs,ERd          UDIV.W ERd,Rs          22 ----nz--
  5470               RTS                     RET                  8,10 --------
  55nn               BSR d:8                 CALL $+/-nn           6,8 --------
  5670               RTE                     RETI                   10 xxxxxxxx
  57n0               TRAPA #n:2              TRAP 0..3 ;[0010h+n*2] 14 1x------
  58c0nnnn           --&gt; Jumps (relative 16bit range)
  59s0               JMP @ERs                JMP  ERs                4 --------
  5Annnnnn           JMP @aa:24              JMP  nnnnnn             6 --------
  5Baa               JMP @@aa:8              JMP  [FFaa]          8,10 --------
  5C00nnnn           BSR d:16                CALL $+/-nnnn        8,10 --------
  5Ds0               JSR @ERs                CALL ERs              6,8 --------
  5Ennnnnn           JSR @aa:24              CALL nnnnnn          8,10 --------
  5Faa               JSR @@aa:8              CALL [FFaa]          8,12 --------
</TD></TR></TABLE>
<BR>
<B>H8/300H Relative Jump Opcodes (8bit/16bit range)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  4cnn               Bcc d:8                 Jcc   $+/-nn            4 --------
  58c0nnnn           Bcc d:16                Jcc   $+/-nnnn          6 --------
</TD></TR></TABLE>
The 4bit condition code can be:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0  BRA or BT    JMP        ;always/true
  1  BRN or BF    -          ;never/false
  2  BHI          JA         ;unsigned-above
  3  BLS          JBE        ;unsigned-below-equal
  4  BCC or BHS   JNC or JAE ;unsigned-above-equal
  5  BCS or BLO   JC  or JB  ;unsigned-below
  6  BNE          JNZ or JNE ;not equal/zero
  7  BEQ          JZ  or JE  ;equal/zero
  8  BVC          JNO        ;signed-no overflow
  9  BVS          JO         ;signed-n-overflow
  A  BPL          JNS        ;signed-n-plus
  B  BMI          JS         ;signed-n-minus
  C  BGE          JGE        ;signed-n-greater-eq
  D  BLT          JL         ;signed-n-less
  E  BGT          JG         ;signed-n-greater
  F  BLE          JLE        ;signed-n-less-equal
</TD></TR></TABLE>
Destination address should be equal (although, the opcodes are weirdly using
byte offsets, hence limiting 8bit range to even 7bit range).<BR>
The execution time for condition=false is unknown. The time for BRN (always
false) is said to be equal to two NOPs (but unknown why one would use that
opcode, and if it does refer to the BRN opcode with 8bit and/or 16bit range).<BR>
<BR>
<B>H8/300H Misc 6xxx</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  60nd               BSET   RnB,RdB          SET   RdB.RnB           2 --------
  61nd               BNOT   RnB,RdB          NOT   RdB.RnB           2 --------
  62nd               BCLR   RnB,RdB          CLR   RdB.RnB           2 --------
  63nd               BTST   RnB,RdB          TST   RdB.RnB           2 -----z--
  64sd               OR.W   Rs,Rd            OR.W  Rd,Rs             2 ----nz0-
  65sd               XOR.W  Rs,Rd            XOR.W Rd,Rs             2 ----nz0-
  66sd               AND.W  Rs,Rd            AND.W Rd,Rs             2 ----nz0-
  67nd            *i B{I}ST #nn:8,RdB        MOV   RdB.n,{not} C     2 --------
  68md               MOV.B  @ERm,RdB         MOV.B RdB,[ERm]         4 ----nz0-
  68ms            *m MOV.B  RsB,@ERm         MOV.B [ERm],RsB         4 ----nz0-
  69md               MOV.W  @ERm,Rd          MOV.W Rd,[ERm]          4 ----nz0-
  69ms            *m MOV.W  Rs,@ERm          MOV.W [ERm],Rs          4 ----nz0-
  6A0dnnnn           MOV.B  @aa:16,RdB       MOV.B RdB,[aaaa]        6 ----nz0-
  6A2d00nnnnnn       MOV.B  @aa:24,RdB       MOV.B RdB,[aaaaaa]      8 ----nz0-
  6A4dnnnn           MOVFPE @aa:16,RdB       MOV.B RdB,[periph:aaaa] * ----nz0-
  6A8snnnn           MOV.B  RsB,@aa:16       MOV.B [aaaa],RsB        6 ----nz0-
  6AAs00nnnnnn       MOV.B  RsB,@aa:24       MOV.B [aaaaaa],RsB      8 ----nz0-
  6ACsnnnn           MOVTPE RsB,@aa:16       MOV.B [periph:aaaa],RsB * ----nz0-
  6B0dnnnn           MOV.W  @aa:16,Rd        MOV.W Rd,[aaaa]         6 ----nz0-
  6B2d00nnnnnn       MOV.W  @aa:24,Rd        MOV.W Rd,[aaaaaa]       8 ----nz0-
  6B8snnnn           MOV.W  Rs,@aa:16        MOV.W [aaaa],Rs         6 ----nz0-
  6BAs00nnnnnn       MOV.W  Rs,@aa:24        MOV.W [aaaaaa],Rs       8 ----nz0-
  6Cmd               MOV.B  @ERm+,RdB        MOV.B RdB,[ERm+]        6 ----nz0-
  6Cms            *m MOV.B  RsB,@-ERm        MOV.B [ERm-],RsB        6 ----nz0-
  6Dmd               MOV.W  @ERm+,RdB        MOV.W RdB,[ERm+]        6 ----nz0-
  6Dms            *m MOV.W  RsB,@-ERm        MOV.W [ERm-],RsB        6 ----nz0-
  6Emdnnnn           MOV.B  @(d:16,ERm),RdB  MOV.B RdB,[ERm+nnnn]    6 ----nz0-
  6Emsnnnn        *m MOV.B  RsB,@(d:16,ERm)  MOV.B [ERm+nnnn],RsB    6 ----nz0-
  6Fmdnnnn           MOV.W  @(d:16,ERm),Rd   MOV.W Rd,[ERm+nnnn]     6 ----nz0-
  6Fmsnnnn        *m MOV.W  Rs,@(d:16,ERm)   MOV.W [ERm+nnnn],Rs     6 ----nz0-
</TD></TR></TABLE>
<BR>
<B>H8/300H Misc 7xxx</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  70nd               BSET  #nn:8,RdB         SET   RdB.n             2 --------
  71nd               BNOT  #nn:8,RdB         NOT   RdB.n             2 --------
  72nd               BCLR  #nn:8,RdB         CLR   RdB.n             2 --------
  73nd               BTST  #nn:8,RdB         TST   RdB.n             2 -----z--
  74nd            *i B{I}OR  #nn:8,RdB       OR    C,{not} RdB.n     2 -------c
  75nd            *i B{I}XOR #nn:8,RdB       XOR   C,{not} RdB.n     2 -------c
  76nd            *i B{I}AND #nn:8,RdB       AND   C,{not} RdB.n     2 -------c
  77nd            *i B{I}LD  #nn:8,RdB       MOV   C,{not} RdB.n     2 -------c
  78m06A2d00nnnnnn   MOV.B @(d:24,ERm),RdB   MOV.B RdB,[ERm+nnnnnn] 10 ----nz0-
  78m06AAs00nnnnnn   MOV.B RsB,@(d:24,ERm)   MOV.B [ERm+nnnnnn],RsB 10 ----nz0-
  78m06B2d00nnnnnn   MOV.W @(d:24,ERm),Rd    MOV.W Rd,[ERm+nnnnnn]  10 ----nz0-
  78m06BAs00nnnnnn*? MOV.W Rs,@(d:24,ERm)    MOV.W [ERm+nnnnnn],Rs  10 ----nz0-
  79..               --&gt; Immediate (16bit)
  7A..               --&gt; Immediate (32bit)
  7B5C498F           EEPMOV.B              MOV [ER6+],[ER5+],R4L- 8+4n --------
  7BD4598F           EEPMOV.W              MOV [ER6+],[ER5+],R4-  8+4n --------
  7C..               --&gt; Bit Operations (Memory at ERm)
  7D..               --&gt; Bit Operations (Memory at ERm)
  7E..               --&gt; Bit Operations (Memory at FFaa)
  7F..               --&gt; Bit Operations (Memory at FFaa)
</TD></TR></TABLE>
The EEPMOV opcodes were originally intended to write to an EEPROM, but they can
be used as generic memory transfers with number of bytes in R4L or R4. EEPMOV.B
is blocking IRQs and NMIs. EEPMOV.W is also blocking IRQs, however, EEPMOV.W
gets aborted upon NMI (without resuming the transfer upon return, so software
must manually retry if R4=nonzero after executing EEPMOV.W in combination with
NMI sources).<BR>
<BR>
<B>H8/300H Immediate 16bit/32bit</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  790dnnnn           MOV.W #nnnn:16,Rd       MOV.W Rd,nnnn           4 ----nz0-
  791dnnnn           ADD.W #nnnn:16,Rd       ADD.W Rd,nnnn           4 --h-nzvc
  792dnnnn           CMP.W #nnnn:16,Rd       CMP.W Rd,nnnn           4 --h-nzvc
  793dnnnn           SUB.W #nnnn:16,Rd       SUB.W Rd,nnnn           4 --h-nzvc
  794dnnnn           OR.W  #nnnn:16,Rd       OR.W  Rd,nnnn           4 ----nz0-
  795dnnnn           XOR.W #nnnn:16,Rd       XOR.W Rd,nnnn           4 ----nz0-
  796dnnnn           AND.W #nnnn:16,Rd       AND.W Rd,nnnn           4 ----nz0-
  7A0dnnnnnnnn       MOV.L #nnnnnnnn:32,E?Rd MOV.L E?Rd,nnnnnnnn     6 ----nz0-
  7A1dnnnnnnnn       ADD.L #nnnnnnnn:32,ERd  ADD.L ERd,nnnnnnnn      6 --h-nzvc
  7A2dnnnnnnnn       CMP.L #nnnnnnnn:32,ERd  CMP.L ERd,nnnnnnnn      6 --h-nzvc
  7A3dnnnnnnnn       SUB.L #nnnnnnnn:32,ERd  SUB.L ERd,nnnnnnnn      6 --h-nzvc
  7A4dnnnnnnnn       OR.L  #nnnnnnnn:32,ERd  OR.L  ERd,nnnnnnnn      6 ----nz0-
  7A5dnnnnnnnn       XOR.L #nnnnnnnn:32,ERd  XOR.L ERd,nnnnnnnn      6 ----nz0-
  7A6dnnnnnnnn       AND.L #nnnnnnnn:32,ERd  AND.L ERd,nnnnnnnn      6 ----nz0-
</TD></TR></TABLE>
<BR>
<B>H8/300H Bit Operations</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  7Cm074n0        *i B{I}OR  #nn:8,@ERm      OR    C,{not} [ERm].n   6 -------c
  7Cm075n0        *i B{I}XOR #nn:8,@ERm      XOR   C,{not} [ERm].n   6 -------c
  7Cm076n0        *i B{I}AND #nn:8,@ERm      AND   C,{not} [ERm].n   6 -------c
  7Cm077n0        *i B{I}LD  #nn:8,@ERm      MOV   C,{not} [ERm].n   6 -------c
  7Dm060n0           BSET    RnB,@ERm        SET   [ERm].RnB         8 --------
  7Dm061n0           BNOT    RnB,@ERm        NOT   [ERm].RnB         8 --------
  7Dm062n0           BCLR    RnB,@ERm        CLR   [ERm].RnB         8 --------
  7Dm063n0           BTST    RnB,@ERm        TST   [ERm].RnB         8 -----z--
  7Dm067n0        *i B{I}ST  #nn:8,@ERm      MOV   [ERm].n,{not} C   8 --------
  7Dm070n0           BSET    #nn:8,@ERm      SET   [ERm].n           8 --------
  7Dm071n0           BNOT    #nn:8,@ERm      NOT   [ERm].n           8 --------
  7Dm072n0           BCLR    #nn:8,@ERm      CLR   [ERm].n           8 --------
  7Dm073n0           BTST    #nn:8,@ERm      TST   [ERm].n           8 -----z--
  7Eaa74n0        *i B{I}OR  #nn:8,@aa:8     OR    C,{not} [FFaa].n  6 -------c
  7Eaa75n0        *i B{I}XOR #nn:8,@aa:8     XOR   C,{not} [FFaa].n  6 -------c
  7Eaa76n0        *i B{I}AND #nn:8,@aa:8     AND   C,{not} [FFaa].n  6 -------c
  7Eaa77n0        *i B{I}LD  #nn:8,@aa:8     MOV   C,{not} [FFaa].n  6 -------c
  7Faa60n0           BSET    RnB,@aa:8       SET   [FFaa].RnB        8 --------
  7Faa61n0           BNOT    RnB,@aa:8       NOT   [FFaa].RnB        8 --------
  7Faa62n0           BCLR    RnB,@aa:8       CLR   [FFaa].RnB        8 --------
  7Faa63n0           BTST    RnB,@aa:8       TST   [FFaa].RnB        8 -----z--
  7Faa67n0        *i B{I}ST  #nn:8,@aa:8     MOV   [FFaa].n,{not} C  8 --------
  7Faa70n0           BSET    #nn:8,@aa:8     SET   [FFaa].n          8 --------
  7Faa71n0           BNOT    #nn:8,@aa:8     NOT   [FFaa].n          8 --------
  7Faa72n0           BCLR    #nn:8,@aa:8     CLR   [FFaa].n          8 --------
  7Faa73n0           BTST    #nn:8,@aa:8     TST   [FFaa].n          8 -----z--
</TD></TR></TABLE>
Nintendo uses undocumented opcode 7Eaa73n0 instead of official 7Faa73n0.
Unknown if both are working. Unknown if all other opcodes in 7EaaXXn0 range do
also act like 7FaaXXn0, and perhaps also 7Cm0XXn0 like 7Dm0XXn0 (nintendo uses
the offical 7D/7F for SET/NOT/CLR, so weirdness may apply for TST only).<BR>
<BR>
<B>H8/300H Encoding Notes</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  *i   optional inverted source operand (when setting bit3 in the "n" digit)
  *s   must have bit3 set in "s" digit
  *m   must have bit3 set in "m" digit
  *?   must have bit3 set-or-not-set (has conflicting info in official specs)
  E?Rs meant to be ERs (although official specs omit the E in some cases)
  E?Rd meant to be ERd (although official specs omit the E in some cases)
  xxxS meant to be Silent, no flags affected (although specs say Sign Extend)
  xxxX meant to mean Carry, or meant to mean nothing specific in other cases
</TD></TR></TABLE>
<BR>
<B>H8/300H Pseudo Opcodes</B><BR>
The official "PUSH/POP.W/L Rn" opcodes are normal MOV.W/L opcodes with ER7 (SP)
and post-increment or pre-decrement.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  6DFn               PUSH.W Rn    ;MOV.W [ER7-],Rn
  6D7n               POP.W  Rn    ;MOV.W Rn,[ER7+]
  01006DFn           PUSH.L ERn   ;MOV.L [ER7-],ERn
  01006D7n           POP.L  ERn   ;MOV.L ERn,[ER7+]
</TD></TR></TABLE>
Although not officially defined, one could also implement "PUSH/POP.W CCR".<BR>
There are no PUSH/POP.B opcodes (because that would misalign the stack).<BR>
<BR>
<B>H8/300H N/A</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  ---N/A---          MOV.L @aa:8,ERd         MOV.L ERd,[FFaa]        - ----nz0-
  ---N/A---          MOV.L ERs,@aa:8         MOV.L [FFaa],ERs        - ----nz0-
  ---N/A---          MOV.W @aa:8,Rd          MOV.W Rd,[FFaa]         - ----nz0-
  ---N/A---          MOV.W Rs,@aa:8          MOV.W [FFaa],Rs         - ----nz0-
  ---N/A---          SUB.B #nn:8,RdB         SUB.B RdB,nn            - --h-nzvc
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dscartunknownextras"></A>
  DS Cart Unknown Extras
</FONT></TD></TR></TABLE><BR>
<B>DS Cartridges with built-in MicroSD Card Slot</B><BR>
The DS Vision cartridge contains a built-in microSD card slot. Users can
download videos from internet (against a fee), store the videos on microSD
cards, and then view them on the NDS via DS Vision cartridge.<BR>
Unknown how the microSD is accessed; via parallel 'ROM' bus and/or via serial
SPI bus; by which commands? Also unknown if the thing contains built-in video
decoder hardware, or if videos are decoded on ARM cpus.<BR>
<BR>
<B>DS Cartridge with Bluetooth Keyboard (Typing Adventure)</B><BR>
Mostly unknown. The components in the cartridge are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  typical Macronix ROM
  STMicroelectronics M25PE10 SPI FLASH memory, presumably 128K
  Broadcom BCM2070 Bluetooth controller
  26MHz crystal oscillator
</TD></TR></TABLE>
the FLASH chip isn't connected directly to the cart-SPI bus, instead it's
prolly accessed through the Bluetooth controller.<BR>
<BR>
<B>NTR-UNSJ - Japanese TV Tuner</B><BR>
Some huge cartridge with digital TV receiver.<BR>
Unknown if the "U" in the gamecode means that it contains NAND, too.<BR>
DSi Launcher sets BPTWL[21h].bit0=0 for this cartridge (unknown what for).<BR>
<BR>
<B>NTR/TWL-Uxxx gamecodes (for carts with uncommon hardware)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  NTR-UNSJ      Japanese TV Tuner, with TV receiver
  NTR-UBRP      Nintendo DS Brower, with RAM cart in GBA slot
  NTR-UAMA      DS Vision Starter Kit, with microSD
  NTR-UEIJ      Starry Sky Navigation, with azimuth
  NTR/TWL-Uxxx  NAND carts (see NAND chapter)
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dscartcheatactionreplayds"></A>
  DS Cart Cheat Action Replay DS
</FONT></TD></TR></TABLE><BR>
The first commercial DS cheat code solution, this device was developed by
Datel. It supports swapping out cartridges after loading the AR software. For
updating, the user may either manually enter codes or use the included
proprietary USB cable that comes with the device. The user has been able to
manually update codes since firmware version 1.52.<BR>
<BR>
<B>Action Replay DS Codes</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  ABCD-NNNNNNNN       Game ID ;ASCII Gamecode [00Ch] and CRC32 across [0..1FFh]
  00000000 XXXXXXXX   manual hook codes (rarely used) (default is auto hook)
  0XXXXXXX YYYYYYYY   word[XXXXXXX+offset] = YYYYYYYY
  1XXXXXXX 0000YYYY   half[XXXXXXX+offset] = YYYY
  2XXXXXXX 000000YY   byte[XXXXXXX+offset] = YY
  3XXXXXXX YYYYYYYY   IF YYYYYYYY &gt; word[XXXXXXX]   ;unsigned    ;\
  4XXXXXXX YYYYYYYY   IF YYYYYYYY &lt; word[XXXXXXX]   ;unsigned    ; for v1.54,
  5XXXXXXX YYYYYYYY   IF YYYYYYYY = word[XXXXXXX]                ; when X=0,
  6XXXXXXX YYYYYYYY   IF YYYYYYYY &lt;&gt; word[XXXXXXX]               ; uses
  7XXXXXXX ZZZZYYYY   IF YYYY &gt; ((not ZZZZ) AND half[XXXXXXX])   ; [offset]
  8XXXXXXX ZZZZYYYY   IF YYYY &lt; ((not ZZZZ) AND half[XXXXXXX])   ; instead of
  9XXXXXXX ZZZZYYYY   IF YYYY = ((not ZZZZ) AND half[XXXXXXX])   ; [XXXXXXX]
  AXXXXXXX ZZZZYYYY   IF YYYY &lt;&gt; ((not ZZZZ) AND half[XXXXXXX])  ;/
  BXXXXXXX 00000000   offset = word[XXXXXXX+offset]
  C0000000 YYYYYYYY   FOR loopcount=0 to YYYYYYYY  ;execute Y+1 times
  C4000000 00000000   offset = address of the C4000000 code           ;v1.54
  C5000000 XXXXYYYY   counter=counter+1, IF (counter AND YYYY) = XXXX ;v1.54
  C6000000 XXXXXXXX   [XXXXXXXX]=offset                               ;v1.54
  D0000000 00000000   ENDIF
  D1000000 00000000   NEXT loopcount
  D2000000 00000000   NEXT loopcount, and then FLUSH everything
  D3000000 XXXXXXXX   offset = XXXXXXXX
  D4000000 XXXXXXXX   datareg = datareg + XXXXXXXX
  D5000000 XXXXXXXX   datareg = XXXXXXXX
  D6000000 XXXXXXXX   word[XXXXXXXX+offset]=datareg, offset=offset+4
  D7000000 XXXXXXXX   half[XXXXXXXX+offset]=datareg, offset=offset+2
  D8000000 XXXXXXXX   byte[XXXXXXXX+offset]=datareg, offset=offset+1
  D9000000 XXXXXXXX   datareg = word[XXXXXXXX+offset]
  DA000000 XXXXXXXX   datareg = half[XXXXXXXX+offset]
  DB000000 XXXXXXXX   datareg = byte[XXXXXXXX+offset] ;bugged on pre-v1.54
  DC000000 XXXXXXXX   offset = offset + XXXXXXXX
  EXXXXXXX YYYYYYYY   Copy YYYYYYYY parameter bytes to [XXXXXXXX+offset...]
  44332211 88776655   parameter bytes 1..8 for above code  (example)
  0000AA99 00000000   parameter bytes 9..10 for above code (padded with 00s)
  FXXXXXXX YYYYYYYY   Copy YYYYYYYY bytes from [offset..] to [XXXXXXX...]
</TD></TR></TABLE>
IF/ENDIF can be nested up to 32 times. FOR/NEXT cannot be nested, any FOR
statement does forcefully terminate any prior loop. FOR does backup the current
IF condidition flags, and NEXT does restore these flags, so ENDIF(s) aren't
required inside of the loop. The NEXT+FLUSH command does (after finishing the
loop) reset offset=0, datareg=0, and does clear all condition flags, so further
ENDIF(s) aren't required after the loop.<BR>
Before v1.54, the DB000000 code did accidently set offset=offset+XXXXXXX after
execution of the code. For all word/halfword accesses, the address should be
aligned accordingly. For the COPY commands, addresses should be aligned by four
(all data is copied with ldr/str, except, on odd lengths, the last 1..3 bytes
do use ldrb/strb).<BR>
offset, datareg, loopcount, and counter are internal registers in the action
replay software.<BR>
<BR>
&gt; The condition register is checked, for all code types<BR>
&gt; but the D0, D1 and D2 code type<BR>
Makes sense.<BR>
<BR>
&gt; and for the C5 code type it's checked AFTER the counter has<BR>
&gt; been incremented (so the counter is always incremented<BR>
I love that exceptions ;-)<BR>
<BR>
<B>Hook</B><BR>
The hook codes consist of a series of nine 00000000 XXXXXXXX codes, and must be
marked as (M) code (for not being confused with normal 0XXXXXXX YYYYYYYY
codes). For all nine codes, the left 32bit are actually don't care (but should
be zero), the meaning of the right 32bit varies from 1st to 9th code.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1st: Address used prior to launching game (eg. 23xxxxxh)
  2nd: Address to write the hook at (inside the ARM7 executable)
  3rd: Hook final address (huh?)
  4th: Hook mode selection (0=auto, 1=mode1, 2=mode2)
  5th: Opcode that replaces the hooked one (eg. E51DE004h)
  6th: Address to store important stuff  (default 23FE000h)
  7th: Address to store the code handler (default 23FE074h)
  8th: Address to store the code list    (default 23FE564h)
  9th: Must be 1 (00000001h)
</TD></TR></TABLE>
For most games, the AR does automatically hook code on the ARM7. Doing that
automatically is nice, but hooking ARM7 means that there is no access to VRAM,
TCM and Cache, which &lt;might&gt; cause problems since efficient games
&lt;should&gt; store all important data in TCM or Cache (though, in practice,
I'd doubt that any existing NDS games are that efficient).<BR>
<BR>
<B>Thanks</B><BR>
To Kenobi and Dualscreenman from Kodewerx for above ARDS cheat info.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dscartcheatcodebreakerds"></A>
  DS Cart Cheat Codebreaker DS
</FONT></TD></TR></TABLE><BR>
This is Pelican's entry into the DS cheat-device industry. It supports swapping
out the cartridges, and alternately, also gives the user the option of
connecting another gamecard onto it. For updating, the user may either manually
enter codes, or use Wifi to connect to the Codebreaker update site (that
updating will overwrite all manually entered codes though).<BR>
<BR>
<B>Codebreaker DS Codes</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  ---Initialization---
  0000CR16 GAMECODE                    Specify Game ID, use Encrypted codes
  8000CR16 GAMECODE                    Specify Game ID, use Unencrypted codes
  BEEFC0DE XXXXXXXX                    Change Encryption Keys
  A0XXXXXX YYYYYYYY                    Bootup-Hook 1, X=Address, Y=Value
  A8XXXXXX YYYYYYYY                    Bootup-Hook 2, X=Address, Y=Value
  F0XXXXXX TYYYYYYY         Code-Hook 1 (T=Type,Y=CheatEngineAddr,X=HookAddr)
  F8XXXXXX TPPPPPPP         Code-Hook 2 (T=Type,X=CheatEngineHookAddr,P=Params)
  ---General codes---
  00XXXXXX 000000YY                    [X]=YY
  10XXXXXX 0000YYYY                    [X]=YYYY
  20XXXXXX YYYYYYYY                    [X]=YYYYYYYY
  60XXXXXX 000000YY ZZZZZZZZ 00000000  [[X]+Z]=YY
  60XXXXXX 0000YYYY ZZZZZZZZ 10000000  [[X]+Z]=YYYY
  60XXXXXX YYYYYYYY ZZZZZZZZ 20000000  [[X]+Z]=YYYYYYYY
  30XXXXXX 000000YY                    [X]=[X] + YY
  30XXXXXX 0001YYYY                    [X]=[X] + YYYY
  38XXXXXX YYYYYYYY                    [X]=[X] + YYYYYYYY
  70XXXXXX 000000YY                    [X]=[X] OR  YY
  70XXXXXX 001000YY                    [X]=[X] AND YY
  70XXXXXX 002000YY                    [X]=[X] XOR YY
  70XXXXXX 0001YYYY                    [X]=[X] OR  YYYY
  70XXXXXX 0011YYYY                    [X]=[X] AND YYYY
  70XXXXXX 0021YYYY                    [X]=[X] XOR YYYY
  ---Memory fill/copy---
  40XXXXXX 2NUMSTEP 000000YY 000000ZZ  byte[X+(0..NUM-1)*STEP*1]=Y+(0..NUM-1)*Z
  40XXXXXX 1NUMSTEP 0000YYYY 0000ZZZZ  half[X+(0..NUM-1)*STEP*2]=Y+(0..NUM-1)*Z
  40XXXXXX 0NUMSTEP YYYYYYYY ZZZZZZZZ  word[X+(0..NUM-1)*STEP*4]=Y+(0..NUM-1)*Z
  50XXXXXX YYYYYYYY ZZZZZZZZ 00000000  copy Y bytes from [X] to [Z]
  ---Conditional codes (bugged)---
  60XXXXXX 000000YY ZZZZZZZZ 01c100VV  IF [[X]+Z] .. VV   THEN [[X]+Z]=YY
  60XXXXXX 000000YY ZZZZZZZZ 01c0VVVV  IF [[X]+Z] .. VVVV THEN [[X]+Z]=YY
  60XXXXXX 0000YYYY ZZZZZZZZ 11c100VV  IF [[X]+Z] .. VV   THEN [[X]+Z]=YYYY
  60XXXXXX 0000YYYY ZZZZZZZZ 11c0VVVV  IF [[X]+Z] .. VVVV THEN [[X]+Z]=YYYY
  60XXXXXX YYYYYYYY ZZZZZZZZ 21c100VV  IF [[X]+Z] .. VV   THEN [[X]+Z]=YYYYYYYY
  60XXXXXX YYYYYYYY ZZZZZZZZ 21c0VVVV  IF [[X]+Z] .. VVVV THEN [[X]+Z]=YYYYYYYY
  ---Conditional codes (working)---
  D0XXXXXX NNc100YY                    IF [X] .. YY   THEN exec max(1,NN) lines
  D0XXXXXX NNc0YYYY                    IF [X] .. YYYY THEN exec max(1,NN) lines
</TD></TR></TABLE>
The condition digits (c=0..7), have the following functions:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0 IF [mem] =  imm THEN ...              4 IF ([mem] AND imm) =  0   THEN ...
  1 IF [mem] &lt;&gt; imm THEN ...              5 IF ([mem] AND imm) &lt;&gt; 0   THEN ...
  2 IF [mem] &lt;  imm THEN ... (unsigned)   6 IF ([mem] AND imm) =  imm THEN ...
  3 IF [mem] &gt;  imm THEN ... (unsigned)   7 IF ([mem] AND imm) &lt;&gt; imm THEN ...
</TD></TR></TABLE>
Notes<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  GAMECODE  Cartridge Header[00Ch] (32bit in reversed byte-order)
  CR16      Cartridge Header[15Eh] (16bit in normal byte-order)
  XXXXXX    27bit addr (actually 7 digits, XXXXXXX, overlaps 5bit code number)
</TD></TR></TABLE>
The "bugged" conditional codes (60XXXXXX) are accidently skipping NN lines when
the condition is false, where NN is taken from the upper 8bit of the code's
last 32bit values (ie. exactly as for the D0XXXXXX codes). For byte-writes,
that would be NN=01h, which can be eventually dealt with, although there may be
compatibility problems which future versions that might fix that bug. For
halfword/word writes, NN would be 11h or 21h, so that codes are about totally
unusable.<BR>
<BR>
<B>Codebreaker DS / Encrypted Codes</B><BR>
The overall "address value" decryption works like so:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  for i=4Fh to 00h
    y=77628ECFh
    if i&gt;13h then y=59E5DC8Ah
    if i&gt;27h then y=054A7818h
    if i&gt;3Bh then y=B1BF0855h
    address = (Key0-value) xor address
    value   = value - Key1 - (address ror 1Bh)
    address = (address xor (value + y)) ror 13h
    if (i&gt;13h) then
      if (i&lt;=27h) or (i&gt;3Bh) then x=Key2 xor Key1 xor Key0
      else x=((Key2 xor Key1) and Key0) xor (Key1 and Key2)
      value=value xor (x+y+address)
      x = Secure[((i*4+00h) and FCh)+000h]
      x = Secure[((i*4+34h) and FCh)+100h] xor x
      x = Secure[((i*4+20h) and FCh)+200h] xor x
      x = Secure[((i*4+08h) and FCh)+300h] xor x
      address = address - (x ror 19h)
  next i
</TD></TR></TABLE>
Upon startup, the initial key settings are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Secure[0..7FFh] = Copy of the ENCRYPTED 1st 2Kbytes of the game's Secure Area
  Key0 = 0C2EAB3Eh, Key1 = E2AE295Dh, Key2 = E1ACC3FFh, Key3 = 70D3AF46h
  scramble_keys
</TD></TR></TABLE>
Upon BEEFC0DE XXXXXXXX, the keys get changed like so:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Key0 = Key0 + (XXXXXXXX ror 1Dh)
  Key1 = Key1 - (XXXXXXXX ror 05h)
  Key2 = Key2 xor (Key3 xor Key0)
  Key3 = Key3 xor (Key2  -  Key1)
  scramble_keys
</TD></TR></TABLE>
The above scramble_keys function works like so:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  for i=0 to FFh
    y = byte(xlat_table[i])
    Secure[i*4+000h] = (Secure[i*4+000h] xor Secure[y*4]) + Secure[y*4+100h]
    Secure[i*4+400h] = (Secure[i*4+400h] xor Secure[y*4]) - Secure[y*4+200h]
  next i
  for i=0 to 63h
    Key0 = Key0 xor (Secure[i*4] + Secure[i*4+190h])
    Key1 = Key1 xor (Secure[i*4] + Secure[i*4+320h])
    Key2 = Key2 xor (Secure[i*4] + Secure[i*4+4B0h])
    Key3 = Key3 xor (Secure[i*4] + Secure[i*4+640h])
  next i
  Key0 = Key0  -  Secure[7D0h]
  Key1 = Key1 xor Secure[7E0h]
  Key2 = Key2  +  Secure[7F0h]
  Key3 = Key3 xor Secure[7D0h] xor Secure[7F0h]
</TD></TR></TABLE>
the xlat_table consists of 256 fixed 8bit values:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  34h,59h,00h,32h,7Bh,D3h,32h,C9h,9Bh,77h,75h,44h,E0h,73h,46h,06h
  0Bh,88h,B3h,3Eh,ACh,F2h,BAh,FBh,2Bh,56h,FEh,7Ah,90h,F7h,8Dh,BCh
  8Bh,86h,9Ch,89h,00h,19h,CDh,4Ch,54h,30h,01h,93h,30h,01h,FCh,36h
  4Dh,9Fh,FDh,D7h,32h,94h,AEh,BCh,2Bh,61h,DFh,B3h,44h,EAh,8Bh,A3h
  2Bh,53h,33h,54h,42h,27h,21h,DFh,A9h,DDh,C0h,35h,58h,EFh,8Bh,33h
  B4h,D3h,1Bh,C7h,93h,AEh,32h,30h,F1h,CDh,A8h,8Ah,47h,8Ch,70h,0Ch
  17h,4Eh,0Eh,A2h,85h,0Dh,6Eh,37h,4Ch,39h,1Fh,44h,98h,26h,D8h,A1h
  B6h,54h,F3h,AFh,98h,83h,74h,0Eh,13h,6Eh,F4h,F7h,86h,80h,ECh,8Eh
  EEh,4Ah,05h,A1h,F1h,EAh,B4h,D6h,B8h,65h,8Ah,39h,B3h,59h,11h,20h
  B6h,BBh,4Dh,88h,68h,24h,12h,9Bh,59h,38h,06h,FAh,15h,1Dh,40h,F0h
  01h,77h,57h,F5h,5Dh,76h,E5h,F1h,51h,7Dh,B4h,FAh,7Eh,D6h,32h,4Fh
  0Eh,C8h,61h,C1h,EEh,FBh,2Ah,FCh,ABh,EAh,97h,D5h,5Dh,E8h,FAh,2Ch
  06h,CCh,86h,D2h,8Ch,10h,D7h,4Ah,CEh,8Fh,EBh,03h,16h,ADh,84h,98h
  F5h,88h,2Ah,18h,ACh,7Fh,F6h,94h,FBh,3Fh,00h,B6h,32h,A2h,ABh,28h
  64h,5Ch,0Fh,C6h,23h,12h,0Ch,D2h,BAh,4Dh,A3h,F2h,C9h,86h,31h,57h
  0Eh,F8h,ECh,E1h,A0h,9Ah,3Ch,65h,17h,18h,A0h,81h,D0h,DBh,D5h,AEh
</TD></TR></TABLE>
all used operations are unsigned 32bit integer.<BR>
<BR>
<B>Thanks</B><BR>
To Kenobi and Dualscreenman from Kodewerx for above CBDS cheat info.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dscartdldidriver"></A>
  DS Cart DLDI Driver
</FONT></TD></TR></TABLE><BR>
DLDI (Dynamically Linked Device Interface for libfat) is a popular yet
undocumented flashcart driver for homebrew NDS software dating back to 2006.
Below was reverse-engineered 11/2018.<BR>
<BR>
file.dldi --&gt; driver file (can be small like 1.5Kbyte, or max 32Kbyte)<BR>
file.nds --&gt; ROM image (must contain 32Kbyte space with DLDI ID for
patching)<BR>
<BR>
<B>Driver patch file standard header</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00h 4  DLDI ID       (EDh,A5h,8Dh,BFh) (aka BF8DA5EDh)  ;\patching tools will
  04h 8  DLDI String   (20h,"Chishm",00h)                 ; refuse any other
  0Ch 1  DLDI Version  (01h in .dldi, don't care in .nds) ;/values
  0Dh 1  Size of .dldi+BSS (rounded up to 1 SHL N bytes) (max 0Fh=32Kbytes)
  0Eh 1  Sections to fix/destroy (see FIX_xxx)
  0Fh 1  Space in .nds file (1 SHL N) (0Eh..0Fh in .nds, can be 0 in .dldi)
  10h 48 ASCII Full Driver Name (max 47 chars, plus zero padding)
  40h 4  Address of ALL start (text) ;-base address (BF800000h in .dldi)
  44h 4  Address of ALL end   (data) ;-for highly-unstable FIX_ALL addr.adjusts
  48h 4  Address of GLUE start       ;\for semi-stable FIX_GLUE addr.adjusts
  4Ch 4  Address of GLUE end         ;/  ("Interworking glue" for ARM-vs-THUMB)
  50h 4  Address of GOT start        ;\for semi-stable FIX_GOT addr.adjusts
  54h 4  Address of GOT end          ;/  ("Global Offset Table")
  58h 4  Address of BSS start        ;\for zerofilling "BSS" via FIX_BSS
  5Ch 4  Address of BSS end          ;/  ("Block Started by Symbol")
  60h 4  ASCII Short Driver/Device Name (4 chars, eg. "MYHW" for MyHardware)
  64h 4  Flags 2 (see FEATURE_xxx) (usually 13h=GbaSlot, or 23h=NdsSlot)
  68h 4  Address of Function startup() ;&lt;-- must be at offset +80h !! ;\
  6Ch 4  Address of Function isInserted() ;out: 0=no/fail, 1=yes/okay ; all
  70h 4  Address of Function readSectors(sector,numSectors,buf)       ; return
  74h 4  Address of Function writeSectors(sector,numSectors,buf)      ; 0=fail,
  78h 4  Address of Function clearStatus()                            ; 1=okay
  7Ch 4  Address of Function shutdown()                               ;/
  80h .. Driver Code (can/must begin with "startup()")            ;\max 7F80h
  ..  .. Glue section (usually a small snippet within above code) ; bytes (when
  ..  .. GOT section (usually after above code) (pointer table)   ; having 32K
  ..  .. BSS section (usually at end, may exceed .dldi filesize)  ; allocated)
  ..  .. Optional two garbage NOPs at end of default.dldi         ;/
</TD></TR></TABLE>
hdr[0Eh] - Sections to fix/destroy (FIX_xxx):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0    FIX_ALL   ;-installer uses highly-unstable guessing in whole dldi file
  1    FIX_GLUE  ;-installer uses semi-stable address guessing in GLUE area
  2    FIX_GOT   ;-installer uses semi-stable address guessing in GOT area
  3    FIX_BSS   ;-installer will zerofill BSS area
  4-7  Reserved (0)
</TD></TR></TABLE>
hdr[64h] - Flags 2 (FEATURE_xxx) (usually 13h=GbaSlot, or 23h=NdsSlot):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0    FEATURE_MEDIUM_CANREAD          00000001h (usually set)
  1    FEATURE_MEDIUM_CANWRITE         00000002h (a few carts can't write)
  2-3  Reserved (0)
  4    FEATURE_SLOT_GBA                00000010h (need EXMEMCNT bit7 adjusted)
  5    FEATURE_SLOT_NDS                00000020h (need EXMEMCNT bit11 adjusted)
  6-31 Reserved (0)
</TD></TR></TABLE>
Note: The allocated driver size in hdr[0Fh] was 0Fh=32Kbytes between 2006 and
2016, however, libnds has changed that to 0Eh=16Kbytes in January 2017 (maybe
intending to free more RAM, especially when using ARM7 WRAM).<BR>
However, there's at least one driver exceeding 16K (rpg_nand.dldi in AKAIO
package; the driver disguises itself as 8K driver in hdr[0Dh], but its BSS area
actually needs ways MORE than 16K).<BR>
<BR>
<B>Required entries in .nds file</B><BR>
Officially, dldi could be at any 4-byte aligned location, however, for faster
lookup, better use this locations:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  dldi area should be located at a 40h-byte aligned address in ROM image.
  dldi area should be located in ARM9 (or ARM7) bootcode area.
</TD></TR></TABLE>
An "empty" driver needs to contain:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  dldi[00h..0Bh] must contain DLDI ID word/string
  dldi[0Fh]      must contain allocated size (0Eh=16Kbyte or 0Fh=32Kbyte)
  dldi[40h..43h] must contain RAM base address of DLDI block
  and other entries should contain valid dummy strings and dummy functions.
</TD></TR></TABLE>
An installed driver should contain a copy of the .dldi file, with addresses
adjusted to RAM locations, and BSS area zerofilled (if FIX_BSS was set)<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  dldi[0Fh] must be kept as in the old .nds file (not as in .dldi file)
</TD></TR></TABLE>
Some installers might try to detect homebrew by looking at nds carthdr for
deciding whether or not to try to install dldi (unknown if/which ones are doing
such things and looking at which carthdr entries).<BR>
<BR>
<B>Functions</B><BR>
startup, isInserted, clearStatus, shutdown can be dummy functions that do
nothing (other than returning r0=1=okay).<BR>
Alternately startup/shutdown can initialize or power down the hardware,
clearStatus is meant to be some sort of soft reset, and isInserted is allowing
to test if the SD card is inserted &amp; working.<BR>
read/write sectors are reading/writing one or more sectors. Sector size is 200h
bytes, sector numbers is 0=First 200h bytes, 1=Next 200h bytes, and so on.<BR>
buf should be usually 4-byte aligned, however, some drivers do also support
unaligned buffers using slower transfer code (better implement that when making
.dldi drivers, but better don't rely on it being supported when making .nds
files).<BR>
The driver functions can support SD and SDHC (or the flashcart manufacturer
might release driver updates if SDHC wasn't supported).<BR>
Higher level FAT functions must be contained in the .nds file (so a driver
update won't help if the .nds file lacks FAT32) (and ExFAT most unlikely to be
supported).<BR>
Functions should be ARM7 compatible, ie. don't use BLX or POP r15 for mode
switching, so the driver can be used on both ARM9 and ARM7 (or even on GBA).<BR>
<BR>
<B>SLOT_GBA/NDS</B><BR>
SLOT_GBA/NDS seem to relate to GBA and NDS slots, the driver can probably have
only one of the SLOT bits set (the functions don't allow to select which slot
to use).<BR>
Purpose is unclear to me, maybe just telling the .nds file that the flashcart
is in the given slot (and thereby shouldn't expect other hardware in that
slot). Or maybe telling telling the installer which hardware the driver is
supposed for.<BR>
<BR>
FIX_xxx does maybe relate to address adjustments made by the dldi installer.
Unknown if/how that's working.<BR>
<A HREF="#dscartdldidriverguessedaddressadjustments">DS Cart DLDI Driver - Guessed Address-Adjustments</A><BR>
<BR>
Some DLDI flashcarts support extra features like Rumble. However, that extra
hardware is accessed via direct I/O, not via DLDI driver. Unknown which I/O
ports are used for that stuff - probably something compatible with official
GBA/NDS rumble cart(s).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dscartdldidriverguessedaddressadjustments"></A>
  DS Cart DLDI Driver - Guessed Address-Adjustments
</FONT></TD></TR></TABLE><BR>
The DLDI installer uses some guessing method for address-adjustments (the
FIX_xxx flags are supposed to patch addresses, but not opcodes or other data).<BR>
<BR>
<B>Unaligned-Word patching and over-shooting bug</B><BR>
The central mistake in the official DLDI installer is that it is patching all
words at [start..end-1], using 1-byte address increments instead of 4-byte
increments. This includes patching words at non-word aligned locations, or
patching words whose lower bytes were already patched, and over-shooting to
words at [end-1..end+2].<BR>
<BR>
<B>ddmem Base BF800000h</B><BR>
Most or all .dldi files are using ddmem base BF800000h (defined in dldi.ld).
That value was chosen because it won't conflict with opcodes (as NDS BIOS
doesn't use SWI function 80h, BF80xxxxh would be an invalid SWI function in
ARM; and BF80h would be an invalid opcode in THUMB).<BR>
So far, this would have worked well, but it doesn't work with unaligned-word
patching bug (eg. THUMB opcodes 8000h,BF00h, or ARM opcodes xxBF80xxh or the
like). And, even if it would have worked for opcodes - it might still fail for
data values.<BR>
<BR>
<B>FIX_GOT</B><BR>
GOT does usually contain BF80xxxxh address pointers (plus some 00000000h
words). The guessing works quite stable (the maximum for 32K files is
xxxxh=7FFFh, so there's no risk to encounter xxxx=BF80h) (one could encounter
xxxxh=xxBFh, but the previously patched word is usually in RAM area, eg.
02xxxxxxh, so this would form BF02h, without risk to be seen as BF80h).<BR>
BUG: The GOT table is usually located at the end of the .dldi file, meaning
that the over-shooting bug will see three uninitialized bytes at
[got_end+0..2], and may go amok if they are BF80xxh or xxBF80h. The value of
those bytes depends on left-over from previously installed .dldi driver(s) and
on the ddmem base used in the .nds file, so the bug may take place randomly
depending on several factors.<BR>
<BR>
<B>FIX_GLUE</B><BR>
GLUE does usually contain a handful of opcodes and .pool values for switching
between ARM and THUMB code. The intention is to patch the addresses in the
.pool, and to leave the opcodes intact. This can be potentially stable,
assuming that the used opcodes in the GLUE (and the next three bytes after
glue_end) usually won't contain BF80h).<BR>
<BR>
<B>FIX_ALL</B><BR>
This is the mother of all bugs. Fortunately there aren't any .dldi drivers with
FIX_ALL flag - and one should never make drivers that do use it.<BR>
ALL is covering the whole dldi space, including the 80h-byte DLDI header, the
code area, including GLUE area, and GOT area, and probably also the yet
uninitialized BSS area, and the next three bytes after end_all.<BR>
Patching the whole code area means an increased risk to hit opcodes or data
values that contain BF80h. The over-shooting bug may even destroy the next
three bytes after the 32Kbyte area.<BR>
Patching the DLDI header could destroy the header itself, the header in the
.dldi file usually won't contain BF80h at unintended locations, however, the
pointers in that header are adjusted before applying FIX_ALL, for example, RAM
base 0200BF00h (in .nds file) combined with a function at BF800080h (in .dldi
file) would result in 0200BF80h. The nasty thing is that the problem won't
occur with other RAM base values (in other .nds files).<BR>
<BR>
<B>Avoiding the bugs</B><BR>
When making .dldi drivers: Never use FIX_ALL. And preferably avoid FIX_GOT and
FIX_GLUE as well (ARM CPU can do relative jumps and relative addressing, eg.
via ADR and ADRL pseudo opcodes, so there's no point in needing address
adjustments). Or otherwise append padding after GOT area, and try to avoid
using opcodes/data with BF80h in/after GLUE area.<BR>
When making dldi installers: Best patch only word-aligned words (ARM CPU can't
access unaligned data, so there's little chance that DLDI drivers would ever
contain unaligned words). Or, when maintaining unaligned patching: At the very
least skip the 80h-byte header on FIX_ALL, and after patching a word at other
locations, skip the next three bytes, and don't do the over-shooting at end.<BR>
When making .nds files: There isn't too much that could be done here. One could
set ddmem to 64Kbyte aligned addresses (so functions won't end up at
xxxxBF80h). Or one could even set ddmem to BF800000h (so patching will leave
everything unchanged &amp; intact - so one could then do the address
adjustments manually, and hopefully more reliable than other DLDI installers).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dsencryptionbygamecodeidcodekey1"></A>
  DS Encryption by Gamecode/Idcode (KEY1)
</FONT></TD></TR></TABLE><BR>
<B>KEY1 - Gamecode / Idcode Encryption</B><BR>
The KEY1 encryption relies only on the gamecode (or firmware idcode), it does
not contain any random components. The fact that KEY1 encrypted commands appear
random is just because the &lt;unencrypted&gt; commands contain random values,
so the encryption result looks random.<BR>
<BR>
KEY1 encryption is used for KEY1 encrypted gamecart commands (ie. for loading
the secure area). It is also used for resolving the extra decryption of the
first 2K of the secure area, and for firmware decryption, and to decode some
encrypted values in gamecart/firmware header.<BR>
<BR>
<B>Initial Encryption Values</B><BR>
Below formulas can be used only with a copy of the 1048h-byte key tables from
NDS/DSi BIOS. The values can be found at:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  NDS.ARM7 ROM: 00000030h..00001077h (values 99 D5 20 5F ..) Blowfish/NDS-mode
  DSi.ARM9 ROM: FFFF99A0h..FFFFA9E7h (values 99 D5 20 5F ..) ""
  DSi.TCM Copy: 01FFC894h..01FFD8DBh (values 99 D5 20 5F ..) ""
  DSi.ARM7 ROM: 0000C6D0h..0000D717h (values 59 AA 56 8E ..) Blowfish/DSi-mode
  DSi.RAM Copy: 03FFC654h..03FFD69Bh (values 59 AA 56 8E ..) ""
  DSi.Debug:    (stored in launcher) (values 69 63 52 05 ..) Blowfish/DSi-debug
</TD></TR></TABLE>
The DSi ROM sections are disabled after booting, but the RAM/TCM copies can be
dumped (eg. with some complex main memory hardware mods, or via unlaunch
exploit). The DSi.Debug key is stored in launcher, and it's used when SCFG_OP
is nonzero (as so on debugging on hardware).<BR>
<BR>
<B>encrypt_64bit(ptr) / decrypt_64bit(ptr)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Y=[ptr+0]
  X=[ptr+4]
  FOR I=0 TO 0Fh (encrypt), or FOR I=11h TO 02h (decrypt)
    Z=[keybuf+I*4] XOR X
    X=[keybuf+048h+((Z SHR 24) AND FFh)*4]
    X=[keybuf+448h+((Z SHR 16) AND FFh)*4] + X
    X=[keybuf+848h+((Z SHR  8) AND FFh)*4] XOR X
    X=[keybuf+C48h+((Z SHR  0) AND FFh)*4] + X
    X=Y XOR X
    Y=Z
  NEXT I
  [ptr+0]=X XOR [keybuf+40h] (encrypt), or [ptr+0]=X XOR [keybuf+4h] (decrypt)
  [ptr+4]=Y XOR [keybuf+44h] (encrypt), or [ptr+4]=Y XOR [keybuf+0h] (decrypt)
</TD></TR></TABLE>
<BR>
<B>apply_keycode(modulo)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  encrypt_64bit(keycode+4)
  encrypt_64bit(keycode+0)
  [scratch]=0000000000000000h   ;S=0 (64bit)
  FOR I=0 TO 44h STEP 4         ;xor with reversed byte-order (bswap)
    [keybuf+I]=[keybuf+I] XOR bswap_32bit([keycode+(I MOD modulo)])
  NEXT I
  FOR I=0 TO 1040h STEP 8
    encrypt_64bit(scratch)      ;encrypt S (64bit) by keybuf
    [keybuf+I+0]=[scratch+4]    ;write S to keybuf (first upper 32bit)
    [keybuf+I+4]=[scratch+0]    ;write S to keybuf (then lower 32bit)
  NEXT I
</TD></TR></TABLE>
<BR>
<B>init_keycode(idcode,level,modulo,key)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  if key=nds then copy [nds_arm7bios+0030h..1077h] to [keybuf+0..1047h]
  if key=dsi then copy [dsi_arm7bios+C6D0h..D717h] to [keybuf+0..1047h]
  [keycode+0]=[idcode]
  [keycode+4]=[idcode]/2
  [keycode+8]=[idcode]*2
  IF level&gt;=1 THEN apply_keycode(modulo) ;first apply (always)
  IF level&gt;=2 THEN apply_keycode(modulo) ;second apply (optional)
  [keycode+4]=[keycode+4]*2
  [keycode+8]=[keycode+8]/2
  IF level&gt;=3 THEN apply_keycode(modulo) ;third apply (optional)
</TD></TR></TABLE>
<BR>
<B>firmware_decryption</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  init_keycode(firmware_header+08h,1,0Ch,nds) ;idcode (usually "MACP"), level 1
  decrypt_64bit(firmware_header+18h)          ;rominfo
  init_keycode(firmware_header+08h,2,0Ch,nds) ;idcode (usually "MACP"), level 2
  decrypt ARM9 and ARM7 bootcode by decrypt_64bit (each 8 bytes)
  decompress ARM9 and ARM7 bootcode by LZ77 function (swi)
  calc CRC16 on decrypted/decompressed ARM9 bootcode followed by ARM7 bootcode
</TD></TR></TABLE>
Note: The sizes of the compressed/encrypted bootcode areas are unknown (until
they are fully decompressed), one way to solve that problem is to decrypt the
next 8 bytes each time when the decompression function requires more data.<BR>
<BR>
<B>gamecart_decryption</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  init_keycode(cart_header+0Ch,1,08h,nds)   ;gamecode, level 1, modulo 8
  decrypt_64bit(cart_header+78h)            ;rominfo (secure area disable)
  init_keycode(cart_header+0Ch,2,08h,nds)   ;gamecode, level 2, modulo 8
  encrypt_64bit all NDS KEY1 commands (1st command byte in MSB of 64bit value)
  after loading the secure_area, calculate secure_area crc, then
  decrypt_64bit(secure_area+0)              ;first 8 bytes of secure area
  init_keycode(cart_header+0Ch,3,08h,nds)   ;gamecode, level 3, modulo 8
  decrypt_64bit(secure_area+0..7F8h)        ;each 8 bytes in first 2K of secure
  init_keycode(cart_header+0Ch,1,08h,dsi)   ;gamecode, level 1, modulo 8
  encrypt_64bit all DSi KEY1 commands (1st command byte in MSB of 64bit value)
</TD></TR></TABLE>
After secure area decryption, the ID field in the first 8 bytes should be
"encryObj", if it matches then first 8 bytes are filled with E7FFDEFFh,
otherwise the whole 2K are filled by that value.<BR>
<BR>
<B>Gamecart Command Register</B><BR>
Observe that the byte-order of the command register [40001A8h] is reversed. The
way how the CPU stores 64bit data in memory (and the way how the
"encrypt_64bit" function for KEY1-encrypted commands expects data in memory) is
LSB at [addr+0] and MSB at [addr+7]. This value is to be transferred MSB first.
However, the DS hardware transfers [40001A8h+0] first, and [40001A8h+7] last.
So, the byte order must be reversed when copying the value from memory to the
command register.<BR>
<BR>
<B>Note</B><BR>
The KEY1 encryption is based on Bruce Schneier's "Blowfish Encryption
Algorithm".<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dsencryptionbyrandomseedkey2"></A>
  DS Encryption by Random Seed (KEY2)
</FONT></TD></TR></TABLE><BR>
<B>KEY2 39bit Seed Values</B><BR>
The pre-initialization settings at cartridge-side (after reset) are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Seed0 = 58C56DE0E8h
  Seed1 = 5C879B9B05h
</TD></TR></TABLE>
The post-initialization settings (after sending command 4llllmmmnnnkkkkkh to
the cartridge, and after writing the Seed values to Port 40001Bxh) are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Seed0 = (mmmnnn SHL 15)+6000h+Seedbyte
  Seed1 = 5C879B9B05h
</TD></TR></TABLE>
The seedbyte is selected by Cartridge Header [013h].Bit0-2, this index value
should be usually in range 0..5, however, possible values for index 0..7 are:
E8h,4Dh,5Ah,B1h,17h,8Fh,99h,D5h.<BR>
The 24bit random value (mmmnnn) is derived from the real time clock setting,
and also scattered by KEY1 encryption, anyways, it's just random and doesn't
really matter where it comes from.<BR>
<BR>
<B>KEY2 Encryption</B><BR>
Relies on two 39bit registers (x and y), which are initialized as such:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  x = reversed_bit_order(seed0)  ;ie. LSB(bit0) exchanged with MSB(bit38), etc.
  y = reversed_bit_order(seed1)
</TD></TR></TABLE>
During transfer, x, y, and transferred data are modified as such:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  x = (((x shr 5)xor(x shr 17)xor(x shr 18)xor(x shr 31)) and 0FFh)+(x shl 8)
  y = (((y shr 5)xor(y shr 23)xor(y shr 18)xor(y shr 31)) and 0FFh)+(y shl 8)
  data = (data xor x xor y) and 0FFh
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dsfirmwareserialflashmemory"></A>
  DS Firmware Serial Flash Memory
</FONT></TD></TR></TABLE><BR>
<B>ST Microelectronics SPI Bus Compatible Serial FLASH Memory</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
 Chips used as wifi-flash:
  ID 20h,40h,12h - ST M45PE20 - 256 KBytes (Nintendo DS) (in my old DS)
  ID 20h,50h,12h - ST M35PE20 - 256 KBytes (Nintendo DS) (in my DS-Lite)
  ID 20h,80h,13h - ST M25PE40 - 512 KBytes (iQue DS, with chinese charset)
  ID 20h,40h,11h - ST 45PE10V6 - 128 Kbytes (Nintendo DSi) (in my DSi)
  ID 20h,58h,0Ch?- 5A32        - 4 Kbytes (Nintendo DSi, newer models)
  ID ?           - 26FV032T    - (Nintendo DSi, J27H020) (this has big package)
  ID ?           - 5K32        - (3DS?)
  ID 62h,62h,0Ch - 32B, 3XH    - 4 Kbytes (New3DS)
 Other similar chips (used in game cartridges):
  ID 20h,40h,13h - ST 45PE40V6 - 512 KBytes (DS Zelda, NTR-AZEP-0)
  ID 20h,40h,14h - ST 45PE80V6 - 1024 Kbytes (eg. Spirit Tracks, NTR-BKIP)
 +ID 62h,11h,00h - Sanyo ?          - 512 Kbytes (P-Letter Diamond, ADAE)
  ID 62h,16h,00h - Sanyo LE25FW203T - 256 KBytes (Mariokart backup)
 +ID 62h,26h,11h - Sanyo ?          - ? Kbytes (3DS: CTR-P-AXXJ)
 +ID 62h,26h,13h - Sanyo ?          - ? Kbytes (3DS: CTR-P-APDJ)
  ID C2h,22h,11h - Macronix MX25L1021E? 128 Kbytes (eg. 3DS Starfox)
  ID C2h,22h,13h - Macronix ...? 512 Kbytes (eg. 3DS Kid Icarus, 3DS Sims 3)
  ID C2h,20h,17h - Macronix MX25L6445EZNI-10G 8192 Kbytes (DSi Art Academy)
  ID 01h,F0h,00h - Garbage/Infrared on SPI-bus? (eg. P-Letter White)
  ID 03h,F8h,00h - Garbage/Infrared on SPI-bus? (eg. P-Letter White 2)
</TD></TR></TABLE>
FLASH has more than 100,000 Write Cycles, more than 20 Year Data Retention<BR>
The Firmware Flash Memory is accessed via SPI bus,<BR>
<A HREF="#dsserialperipheralinterfacebusspi">DS Serial Peripheral Interface Bus (SPI)</A><BR>
<BR>
<B>Instruction Codes</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  06h  WREN Write Enable (No Parameters)
  04h  WRDI Write Disable (No Parameters)
  9Fh  RDID Read JEDEC Identification (Read 1..3 ID Bytes)
             (Manufacturer, Device Type, Capacity)
  05h  RDSR Read Status Register (Read Status Register, endless repeated)
             Bit7-2  Not used (zero)
             Bit1    WEL Write Enable Latch             (0=No, 1=Enable)
             Bit0    WIP Write/Program/Erase in Progess (0=No, 1=Busy)
  03h  READ Read Data Bytes (Write 3-Byte-Address, read endless data stream)
  0Bh  FAST Read Data Bytes at Higher Speed (Write 3-Byte-Address, write 1
             dummy-byte, read endless data stream) (max 25Mbit/s)
  0Ah  PW   Page Write (Write 3-Byte-Address, write 1..256 data bytes)
             (changing bits to 0 or 1) (reads unchanged data, erases the page,
             then writes new &amp; unchanged data) (11ms typ, 25ms max)
  02h  PP   Page Program (Write 3-Byte-Address, write 1..256 data bytes)
             (changing bits from 1 to 0) (1.2ms typ, 5ms max)
  DBh  PE   Page Erase 100h bytes (Write 3-Byte-Address) (10ms typ, 20ms max)
  D8h  SE   Sector Erase 10000h bytes (Write 3-Byte-Address) (1s typ, 5s max)
  B9h  DP   Deep Power-down (No Parameters) (consumption 1uA typ, 10uA max)
             (3us) (ignores all further instructions, except RDP)
  ABh  RDP  Release from Deep Power-down (No Parameters) (30us)
</TD></TR></TABLE>
Write/Program may not cross page-boundaries. Write/Program/Erase are rejected
during first 1..10ms after power up. The WEL bit is automatically cleared on
Power-Up, on /Reset, and on completion of WRDI/PW/PP/PE/SE instructions. WEL is
set by WREN instruction (which must be issued before any write/program/erase
instructions). Don't know how RDSR behaves when trying to write to the
write-protected region?<BR>
<BR>
<B>Communication Protocol</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Set Chip Select LOW to invoke the command
  Transmit the instruction byte
  Transmit any parameter bytes
  Transmit/receive any data bytes
  Set Chip Select HIGH to finish the command
</TD></TR></TABLE>
All bytes (and 3-byte addresses) transferred most significant bit/byte first.<BR>
<BR>
<B>DSi "5A32" chip (32Kit aka 4Kbyte)</B><BR>
Early DSi DWM-W015 boards did have 128Kbyte FLASH, but later boards have custum
4Kbyte FLASH chips (these 4K chips are found on later DSi DWM-W015 boards, and
DSi DWM-W024 boards, and 3DS DWM-W028 boards). The chips are having a 24bit
address bus (needed for NDS compatibility), and, a weird non-writeable gap
within a 128Kbyte memory are:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000000h..0002FFh  Writeable only if /WP=HIGH (otherwise writes are ignored)
  000300h..01F2FFh  Not writeable (FFh-filled, writes are ignored)
  01F300h..01FFFFh  Writeable
  020000h and up    Mirrors of 0..01FFFFh (same read/write-ability as above)
</TD></TR></TABLE>
There are several part numbers: "5A32" (DSi), "5K32" (3DS), "32B, 3XH" (3DS),
and "26FV032T" (DSi), that chips are probably all the same size &amp;
functionally same; most of those 4Kbyte chips have tiny packages (except
"26FV032T" which comes in classic large package).<BR>
<BR>
<B>Pin-Outs (Large Package, in NDS, and early DSi boards)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1   D    Serial Data In (latched at rising clock edge)          _________
  2   C    Serial Clock (max 25MHz)                             /|o        |
  3   /RES Reset                                            1 -| |         |- 8
  4   /S   Chip Select (instructions start at falling edge) 2 -| |         |- 7
  5   /W   Write Protect (makes first 256 pages read-only)  3 -| |_________|- 6
  6   VCC  Supply (2.7V..3.6V typ) (4V max) (DS:VDD3.3)     4 -|/          |- 5
  7   VSS  Ground                                              |___________|
  8   Q    Serial Data Out (changes at falling clock edge)
</TD></TR></TABLE>
<BR>
<B>Pin-Outs (Tiny Package, in newer DSi boards, and 3DS)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  1   /S   Chip Select (instructions start at falling edge)     ___________
  2   Q    Serial Data Out (changes at falling clock edge)  1 -| o         |- 8
  3   /W   Write Protect (makes first pages read-only)      2 -|           |- 7
  4   VSS  Ground                                           3 -|           |- 6
  5   D    Serial Data In (latched at rising clock edge)    4 -|___________|- 5
  6   C    Serial Clock
  7   /RES Reset
  8   VCC  Supply (2.7V..3.6V typ) (DSi: VDD33)
</TD></TR></TABLE>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dsfirmwareheader"></A>
  DS Firmware Header
</FONT></TD></TR></TABLE><BR>
<B>Firmware Memory Map</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  00000h-00029h  Firmware Header
  0002Ah-001FFh  Wifi Settings
  00200h-3F9FFh  Firmware Code/Data                       ;-NDS only (not DSi)
  00200h-002FEh  00h-filled                               ;\
  002FFh         80h                                      ;
  00300h-1F2FFh  FFh-filled (not write-able on 4K chips)  ; DSi only (not NDS)
  1F300h-1F3FEh  FFh-filled (write-able)                  ;
  1F3FFh         Whatever Debug/Bootflags                 ;
  1F400h-1F5FFh  Wifi Access Point 4  ;\with WPA/WPA2     ;
  1F600h-1F7FFh  Wifi Access Point 5  ; support           ;
  1F800h-1F9FFh  Wifi Access Point 6  ;/                  ;/
  3FA00h-3FAFFh  Wifi Access Point 1  ;\
  3FB00h-3FBFFh  Wifi Access Point 2  ; Open/WEP only
  3FC00h-3FCFFh  Wifi Access Point 3  ;/
  3FD00h-3FDFFh  Not used
  3FE00h-3FEFFh  User Settings Area 1
  3FF00h-3FFFFh  User Settings Area 2
</TD></TR></TABLE>
On iQue DS (with 512K flash memory), user settings are moved to 7FE00h and up,
and, there seems to be some unknown stuff at 200h..27Fh.<BR>
<BR>
<B>Firmware Header (00000h-001FFh)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Addr Size Expl.
  000h 2    part3 romaddr/8 (arm9 gui code) (LZ/huffman compression)
  002h 2    part4 romaddr/8 (arm7 wifi code) (LZ/huffman compression)
  004h 2    part3/4 CRC16 arm9/7 gui/wifi code
  006h 2    part1/2 CRC16 arm9/7 boot code
  008h 4    firmware identifier (usually nintendo "MAC",nn) (or nocash "XBOO")
            the 4th byte (nn) occassionally changes in different versions
  00Ch 2    part1 arm9 boot code romaddr/2^(2+shift1) (LZSS compressed)
  00Eh 2    part1 arm9 boot code 2800000h-ramaddr/2^(2+shift2)
  010h 2    part2 arm7 boot code romaddr/2^(2+shift3) (LZSS compressed)
  012h 2    part2 arm7 boot code 3810000h-ramaddr/2^(2+shift4)
  014h 2    shift amounts, bit0-2=shift1, bit3-5=shift2, bit6-8=shift3,
            bit9-11=shift4, bit12-15=firmware_chipsize/128K
  016h 2    part5 data/gfx romaddr/8 (LZ/huffman compression)
  018h 8    Optional KEY1-encrypted "enPngOFF"=Cartridge KEY2 Disable
            (feature isn't used in any consoles, instead contains timestamp)
  018h 5    Firmware version built timestamp (BCD minute,hour,day,month,year)
  01Dh 1    Console type
              FFh=Nintendo DS
              20h=Nintendo DS-lite
              57h=Nintendo DSi (also iQueDSi)
              43h=iQueDS
              63h=iQueDS-lite
            The entry was unused (FFh) in older NDS, ie. replace FFh by 00h)
              Bit0   seems to be DSi/iQue related
              Bit1   seems to be DSi/iQue related
              Bit2   seems to be DSi related
              Bit3   zero
              Bit4   seems to be DSi related
              Bit5   seems to be DS-Lite related
              Bit6   indicates presence of "extended" user settings (DSi/iQue)
              Bit7   zero
  01Eh 2    Unused (FFh-filled)
  020h 2    User Settings Offset (div8) (usually last 200h flash bytes)
  022h 2    Unknown (7EC0h or 0B51h)
  024h 2    Unknown (7E40h or 0DB3h)
  026h 2    part5 CRC16 data/gfx
  028h 2    unused (FFh-filled)
  02Ah-1FFh Wifi Calibration Data (see next chapter)
</TD></TR></TABLE>
<BR>
<B>DSi</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  000h 1Dh   Zerofilled (bootcode is in new eMMC chip, not on old FLASH chip)
  01Dh 6     Same as on DS (header: Console Type and User Settings Offset)
  022h 6     Zerofilled (bootcode is in new eMMC chip, not on old FLASH chip)
  028h..1FCh Same as on DS (wifi calibration)
  1FDh 1     Wifi Board (01h=DWM-W015, 02h=W024, 03h=W028)   ;\this was
  1FEh 1     Wifi Flash (20h=With access point 4/5/6)        ; FFh-filled
  1FFh 1     Same as on DS (FFh)                             ;/on DS
  200h FFh   Zerofilled                                      ;\
  2FFh 1     Unknown (80h)                                   ; this was
  300h   1F000h FFh's (not write-able on 4K chips)           ; bootcode
  1F300h FFh    FFh's (write-able) ;twl-debugger: 00h's      ; on DS
  1F3FFh 1      FFh                ;twl-debugger: 40h        ;/
</TD></TR></TABLE>
The bytes [000h..027h] cannot be changed on DSi because they are part of the
RSA signature in DSi's Boot Info Block (at eMMC offset 200h..3FFh).<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dsfirmwarewificalibrationdata"></A>
  DS Firmware Wifi Calibration Data
</FONT></TD></TR></TABLE><BR>
<B>Wifi Calibration/Settings (located directly after Firmware Header)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Addr Size Expl.
  000h-029h Firmware Header (see previous chapter)
  02Ah 2    CRC16 (with initial value 0) of [2Ch..2Ch+config_length-1]
  02Ch 2    config_length (usually 0138h, ie. entries 2Ch..163h)
  02Eh 1    Unused        (00h)
  02Fh 1    Version (0=v1..v4, 3=v5, 5=v6..v7,6=W006,15=W015,24=W024,34=N3DS)
  030h 6    Unused        (00h-filled) (DS-Lite and DSi: FF,FF,FF,FF,FF,00)
  036h 6    48bit MAC address (v1-v5: 0009BFxxxxxx, v6-v7: 001656xxxxxx)
  03Ch 2    list of enabled channels ANDed with 7FFE (Bit1..14 = Channel 1..14)
            (usually 3FFEh, ie. only channel 1..13 enabled)
  03Eh 2    Whatever Flags (usually FFFFh)
  040h 1    RF Chip Type (NDS: usually 02h) (DS-Lite and DSi/3DS: usually 03h)
  041h 1    RF Bits per entry at 0CEh (usually 18h=24bit=3byte) (Bit7=?)
  042h 1    RF Number of entries at 0CEh (usually 0Ch)
  043h 1    Unknown (usually 01h)
  044h 2    Initial Value for [4808146h]  ;W_CONFIG_146h
  046h 2    Initial Value for [4808148h]  ;W_CONFIG_148h
  048h 2    Initial Value for [480814Ah]  ;W_CONFIG_14Ah
  04Ah 2    Initial Value for [480814Ch]  ;W_CONFIG_14Ch
  04Ch 2    Initial Value for [4808120h]  ;W_CONFIG_120h
  04Eh 2    Initial Value for [4808122h]  ;W_CONFIG_122h
  050h 2    Initial Value for [4808154h]  ;W_CONFIG_154h
  052h 2    Initial Value for [4808144h]  ;W_CONFIG_144h
  054h 2    Initial Value for [4808130h]  ;W_CONFIG_130h
  056h 2    Initial Value for [4808132h]  ;W_CONFIG_132h
  058h 2    Initial Value for [4808140h]  ;W_CONFIG_140h ;maybe ACK timeout?
  05Ah 2    Initial Value for [4808142h]  ;W_CONFIG_142h
  05Ch 2    Initial Value for [4808038h]  ;W_POWER_TX
  05Eh 2    Initial Value for [4808124h]  ;W_CONFIG_124h
  060h 2    Initial Value for [4808128h]  ;W_CONFIG_128h
  062h 2    Initial Value for [4808150h]  ;W_CONFIG_150h
  064h 69h  Initial 8bit values for BB[0..68h]
  0CDh 1    Unused (00h)
</TD></TR></TABLE>
Below for Type2 (ie. when [040h]=2) (Mitsumi MM3155 and RF9008):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0CEh 24h  Initial 24bit values for RF[0,4,5,6,7,8,9,0Ah,0Bh,1,2,3]
  0F2h 54h  Channel 1..14 2x24bit values for RF[5,6]
  146h 0Eh  Channel 1..14 8bit values for BB[1Eh] (usually somewhat B1h..B7h)
  154h 0Eh  Channel 1..14 8bit values for RF[9].Bit10..14 (usually 10h-filled)
</TD></TR></TABLE>
Below for Type3 (ie. when [040h]=3) (Mitsumi MM3218) (and AR6013G):<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  --- Type3 values are originated at 0CEh, following addresses depend on:  ---
  1) number of initial values, found at [042h]        ;usually 29h
  2) number of BB indices,     found at [0CEh+[042h]] ;usually 02h
  3) number of RF indices,     found at [043h]        ;usually 02h
  --- Below example addresses assume above values to be set to 29h,02h,02h ---
  0CEh 29h  Initial 8bit values for RF[0..28h]
  0F7h 1    Number of BB indices per channel
  0F8h 1    1st BB index
  0F9h 14   1st BB data for channel 1..14
  107h 1    2nd BB index
  108h 14   2nd BB data for channel 1..14
  116h 1    1st RF index
  117h 14   1st RF data for channel 1..14
  125h 1    2nd RF index
  126h 14   2nd RF data for channel 1..14
  134h 46   Unused (FFh-filled)
</TD></TR></TABLE>
Below for both Type2 and Type3:<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  162h 1    Unknown (usually 19h..1Ch)
  163h 1    Unused (FFh) (Inside CRC16 region, with config_length=138h)
  164h 99h  Unused (FFh-filled) (Outside CRC16 region, with config_length=138h)
  1FDh 1    DSi/3DS Wifi Board (01h=W015, 02h=W024, 03h=W028);\this was
  1FEh 1    DSi/3DS Wifi Flash (20h=With access point 4/5/6) ; FFh-filled on DS
  1FFh 1    DSi/3DS Same as on DS (FFh)                      ;/
</TD></TR></TABLE>
Most of the Wifi settings seem to be always the same values on all currently
existing consoles. Except for:<BR>
Values that are (obviously) different are the CRC16, and 4th-6th bytes of the
MAC address. Also, initial values for BB[01h] and BB[1Eh], and channel 1..14
values for BB[1Eh], and unknown entry [162h] contain different calibration
settings on all consoles.<BR>
Firmware v5 is having a new wifi ID [2Fh]=03h, and different RF[9] setting.<BR>
Firmware v6 (dslite) has wifi ID [2Fh]=05h, and same RF[9] setting as v5,
additionally, v6 and up have different 2nd-3rd bytes of the MAC address.<BR>
<BR>
Moreover, a LOT of values are different with Type3 chips (ie. when [040h]=3).<BR>
<BR>
<B>Note</B><BR>
Unlike for Firmware User Settings, the Firmware Header (and Wifi Settings)
aren't stored in RAM upon boot. So the data must be retrieved via SPI bus by
software.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dsfirmwarewifiinternetaccesspoints"></A>
  DS Firmware Wifi Internet Access Points
</FONT></TD></TR></TABLE><BR>
<B>Connection data 1 at WifiFlash[00020h]*8-400h (eg. 01FA00h/03FA00h/07FA00h)</B><BR>
<B>Connection data 2 at WifiFlash[00020h]*8-300h (eg. 01FB00h/03FB00h/07FB00h)</B><BR>
<B>Connection data 3 at WifiFlash[00020h]*8-200h (eg. 01FC00h/03FC00h/07FC00h)</B><BR>
These three 100h byte regions are used to memorize known internet access
points. The NDS firmware doesn't use these regions, but games that support
internet are allowed to read (and configure/write) them. The DSi firmware also
supports configuring these entries.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Addr Siz Expl.
  000h 64  Unknown (usually 00h-filled) (no Proxy supported on NDS)
  040h 32  SSID (ASCII name of the access point) (padded with 00h's)
  060h 32  SSID for WEP64 on AOSS router (each security level has its own SSID)
  080h 16  WEP Key 1 (for type/size, see entry E6h)
  090h 16  WEP Key 2  ;\
  0A0h 16  WEP Key 3  ; (usually 00h-filled)
  0B0h 16  WEP Key 4  ;/
  0C0h 4   IP Address           (0=Auto/DHCP)
  0C4h 4   Gateway              (0=Auto/DHCP)
  0C8h 4   Primary DNS Server   (0=Auto/DHCP)
  0CCh 4   Secondary DNS Server (0=Auto/DHCP)
  0D0h 1   Subnet Mask (0=Auto/DHCP, 1..1Ch=Leading Ones) (eg. 6 = FC.00.00.00)
  0D1h ..  Unknown (usually 00h-filled)
  0E6h 1   WEP Mode (0=None, 1/2/3=5/13/16 byte hex, 5/6/7=5/13/16 byte ascii)
  0E7h 1   Status (00h=Normal, 01h=AOSS, FFh=connection not configured/deleted)
  0E8h 1   Zero (not SSID Length, ie. unlike as entry 4,5,6 on DSi)
  0E9h 1   Unknown (usually 00h)
  0EAh 2   DSi only: MTU (Max transmission unit) (576..1500, usually 1400)
  0ECh 3   Unknown (usually 00h-filled)
  0EFh 1   bit0/1/2 - connection 1/2/3 (1=Configured, 0=Not configured)
  0F0h 6   Nintendo Wifi Connection (WFC) 43bit User ID
           (ID=([F0h] AND 07FFFFFFFFFFh)*1000, shown as decimal string
           NNNN-NNNN-NNNN-N000) (the upper 5bit of the last byte are
           containing additional/unknown nonzero data)
  0F6h 8   Unknown (nonzero stuff !?!)
  0FEh 2   CRC16 for Entries 000h..0FDh (with initial value 0000h)
</TD></TR></TABLE>
For connection 3: entries [0EFh..0FDh] - always zero-filled?<BR>
The location of the first data block is at the User Settings address minus
400h, ie. Firmware Header [00020h]*8-400h.<BR>
<BR>
<B>Connection data 4 at WifiFlash[00020h]*8-A00h (eg. 01F400h) (DSi only)</B><BR>
<B>Connection data 5 at WifiFlash[00020h]*8-800h (eg. 01F600h) (DSi only)</B><BR>
<B>Connection data 6 at WifiFlash[00020h]*8-600h (eg. 01F800h) (DSi only)</B><BR>
The DSi has three extra 200h-byte regions (for use DSi games, with the new
WPA/WPA2 encryption support, and with additional proxy support), these extra
regions are found under "Advanced Setup" in the DSi firmware's "Internet"
configuration menu.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Addr Siz Expl.
  000h 32  Proxy Authentication Username (ASCII string, padded with 00's)
  000h 32  Proxy Authentication Password (ASCII string, padded with 00's)
  040h 32  SSID (ASCII string, padded with 00's) (see [0E8h] for length)
  060h ..  Maybe same as NDS
  080h 16  WEP Key (zerofilled for WPA)
  0xxh ..  Maybe same as NDS
  0C0h 4   IP Address           (0=Auto/DHCP)
  0C4h 4   Gateway              (0=Auto/DHCP)
  0C8h 4   Primary DNS Server   (0=Auto/DHCP)
  0CCh 4   Secondary DNS Server (0=Auto/DHCP)
  0D0h 1   Subnet Mask (0=Auto/DHCP, 1..1Ch=Leading Ones) (eg. 6 = FC.00.00.00)
  0D1h ..  Unknown (zerofilled)
  0E6h 1   WEP (00h=None/WPA/WPA2, 01h/02h/03h/05h/06h/07h=WEP, same as NDS)
  0E7h 1   WPA (00h=Normal, 10h=WPA/WPA2, 13h=WPS+WPA/WPA2, FFh=unused/deleted)
  0E8h 1   SSID Length in characters (01h..20h, or 00h=unused)
  0E9h 1   Unknown (usually 00h)
  0EAh 2   MTU Value (Max transmission unit) (576..1500, usually 1400)
  0ECh 3   Unknown (usually 00h-filled)
  0EFh 1   bit0/1/2 - connection 4/5/6 (1=Configured, 0=Not configured)
  0F0h 14  Zerofilled (or maybe ID as on NDS, if any such ID exists for DSi?)
  0FEh 2   CRC16 for Entries 000h..0FDh (with initial value 0000h)
  100h 32  Precomputed PSK (based on WPA/WPA2 password and SSID) ;\all zero
  120h 64  WPA/WPA2 password (ASCII string, padded with 00's)    ;/for WEP
  160h 33  Zerofilled
  181h 1   WPA (0=None/WEP, 4=WPA-TKIP, 5=WPA2-TKIP, 6=WPA-AES, 7=WPA2-AES)
  182h 1   Proxy Enable         (00h=None, 01h=Yes)
  183h 1   Proxy Authentication (00h=None, 01h=Yes)
  184h 48  Proxy Name (ASCII string, max 47 chars, padded with 00's)
  1B4h 52  Zerofilled
  1E8h 2   Proxy Port (16bit)
  1EAh 20  Zerofilled
  1FEh 2   CRC16 for Entries 100h..1FDh (with initial value 0000h) (0=deleted)
</TD></TR></TABLE>
The location of the first data block (aka settings number 4) is at the User
Settings address minus A00h, ie. Firmware Header [00020h]*8-A00h.<BR>
Observe that NDS consoles do have NDS Firmware bootcode/data in that area, so
those new regions can exist on DSi only (or on homebrew NDS firmwares).
Presence of the new regions is indicated in Firmware Header [001FEh], that byte
is usually FFh=NDS or 20h=DSi, the DSi browser does internally replace FFh by
10h, and does then check if byte&gt;=20h (ie. the new areas exist if the byte
is 20h..FEh).<BR>
Note that the Proxy feature can be used to redirect internet access (when using
a custom proxy server, one could redirect commercial games to homebrew servers;
as done by the <A HREF="http://pbsds.net/"><FONT COLOR=#808080>http://pbsds.net/</FONT></A>
 project) (actually the same should be possible with the DNS server entry,
possibly with less traffic).<BR>
<BR>
<B>Note</B><BR>
The location of the user settings &amp; connection data varies (eg.
01Fxxxh=DSi, 03Fxxxh=NDS, 07Fxxxh=iQueDS).<BR>
<BR>
<B>Nintendo Zone Beacons</B><BR>
DSi games and DSi browser can reportedly also connect to Nintendo's public
access points (those that are announced via Nintendo Zone Beacons).<BR>
<BR>
<B>Hidden Connection data at WifiFlash[00020h]*8-100h (eg. xxFD00h)</B><BR>
This seems to hold an extra 100h-byte region (same as Connection data 1-3),
some (or all) NDS/DSi games seem to be capable of using it (although it isn't
shown in config menues). One theory is that it might be used for the Nintendo
Wi-Fi USB Connector?<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dsfirmwareusersettings"></A>
  DS Firmware User Settings
</FONT></TD></TR></TABLE><BR>
<B>Current Settings (RAM 27FFC80h-27FFCEFh, DSi: 2FFFC80h-2FFFCEFh)</B><BR>
<B>User Settings 0 (Firmware 3FE00h-3FEFFh) ;(DSi &amp; iQue use different address,</B><BR>
<B>User Settings 1 (Firmware 3FF00h-3FFFFh) ;see Firmware Header [020h])</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Addr Size Expl.
  000h  2   Version (5) (Always 5, for all NDS/DSi Firmware versions)
  002h  1   Favorite color (0..15) (0=Gray, 1=Brown, etc.)
  003h  1   Birthday month (1..12) (Binary, non-BCD)
  004h  1   Birthday day   (1..31) (Binary, non-BCD)
  005h  1   Not used (zero)
  006h  20  Nickname string in UTF-16 format
  01Ah  2   Nickname length in characters    (0..10)
  01Ch  52  Message string in UTF-16 format
  050h  2   Message length in characters     (0..26)
  052h  1   Alarm hour     (0..23) (Binary, non-BCD)
  053h  1   Alarm minute   (0..59) (Binary, non-BCD)
  054h  2
  056h  1   80h=enable alarm (huh?), bit 0..6=enable?
  057h  1   Zero (1 byte)
  058h  2x2 Touch-screen calibration point (adc.x1,y1) 12bit ADC-position
  05Ch  2x1 Touch-screen calibration point (scr.x1,y1) 8bit pixel-position
  05Eh  2x2 Touch-screen calibration point (adc.x2,y2) 12bit ADC-position
  062h  2x1 Touch-screen calibration point (scr.x2,y2) 8bit pixel-position
  064h  2   Language and Flags (see below)
  066h  1   Year (2000..2255) (when having entered date in the boot menu)
  067h  1   Unknown (usually 00h...08h or 78h..7Fh or so)
  068h  4   RTC Offset (difference in seconds when RTC time/date was changed)
  06Ch  4   Not used (FFh-filled, sometimes 00h-filled) (=MSBs of above?)
</TD></TR></TABLE>
Below not stored in RAM (found only in FLASH memory)...<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  070h  2   Update counter (used to check latest) (must be 0000h..007Fh)
  072h  2   CRC16 of entries 00h..6Fh (70h bytes)
  074h  8Ch Not used (FFh-filled) (or extended data, see below)
</TD></TR></TABLE>
Below extended data was invented for iQue DS (for adding the chinese language
setting), and is also included in Nintendo DSi models. Presence of extended
data is indicated in Firmware Header entry [1Dh].Bit6.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  074h  1   Unknown (01h) (maybe version?)
  075h  1   Extended Language (0..5=Same as Entry 064h, plus 6=Chinese)
            (for language 6, entry 064h defaults to english; for compatibility)
            (for language 0..5, both entries 064h and 075h have same value)
  076h  2   Bitmask for Supported Languages (Bit0..6)
            (007Eh for iQue DS, ie. with chinese, but without japanese)
            (0042h for iQue DSi, chinese (and english, but only for NDS mode))
            (003Eh for DSi/EUR, ie. without chinese, and without japanese)
  078h  86h Not used (FFh-filled on iQue DS, 00h-filled on DSi)
  0FEh  2   CRC16 of entries 74h..FDh (8Ah bytes)
</TD></TR></TABLE>
Note: The DSi does store the user settings in eMMC files (TWLCFGn.dat), that
files include NDS-style settings (username etc), plus additional DSi-specific
settings (country, parental controls, etc). For backwards compatibilty, the DSi
does also store a copy of those settings in NDS-style format in Wifi FLASH and
Main RAM at 2FFFC80h.<BR>
<A HREF="#dsisdmmcfirmwaresystemsettingsdatafiles">DSi SD/MMC Firmware System Settings Data Files</A><BR>
DSi Backlight level and DSi sound volume seem to be stored in the BPTWL chip
(or possibly in its attached I2C potentiometer).<BR>
<BR>
<B>Language and Flags (Entry 064h)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  0..2 Language (0=Japanese, 1=English, 2=French, 3=German,
       4=Italian, 5=Spanish, 6..7=Reserved) (for Chinese see Entry 075h)
       (the language setting also implies time/data format)
  3    GBA mode screen selection (0=Upper, 1=Lower)
  4-5  Backlight Level    (0..3=Low,Med,High,Max) (DS-Lite only)
  6    Bootmenu Disable   (0=Manual/bootmenu, 1=Autostart Cartridge)
  7-8  ?
  9    Settings Lost (1=Prompt for User Info, and Language, and Calibration)
  10   Settings Okay (0=Prompt for User Info)
  11   Settings Okay (0=Prompt for User Info) (Same as Bit10)
  12   No function
  13   Settings Okay (0=Prompt for User Info, and Language)
  14   Settings Okay (0=Prompt for User Info) (Same as Bit10)
  15   Settings Okay (0=Prompt for User Info) (Same as Bit10)
</TD></TR></TABLE>
The Health and Safety message is skipped if Bit9=1, or if one or more of the
following bits is zero: Bits 10,11,13,14,15. However, as soon as entering the
bootmenu, the Penalty-Prompt occurs.<BR>
<BR>
Note: There are two User Settings areas in the firmware chip, at offset 3FE00h
and 3FF00h, if both areas have valid CRCs, then the current/newest area is that
whose Update Counter is one bigger than in the other/older area.<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  IF count1=((count0+1) AND 7Fh) THEN area1=newer ELSE area0=newer
</TD></TR></TABLE>
When changing settings, the older area is overwritten with new data (and
incremented Update Counter). The two areas allow to recover previous settings
in case of a write-error (eg. on a battery failure during write).<BR>
<BR>
<B>Battery Removal</B><BR>
Even though the battery is required only for the RTC (not for the firmware
flash memory), most of the firmware user settings are reset when removing the
battery. This appears to be a strange bug-or-feature of the DS bios, at least,
fortunately, it still keeps the rest of the firmware intact.<BR>
<BR>
<BR>

<!--------------------------------------->
<TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=2><TR bgcolor="#cccccc"><TD WIDTH=100%><FONT SIZE=+2>
  <A NAME="dsfirmwareextendedsettings"></A>
  DS Firmware Extended Settings
</FONT></TD></TR></TABLE><BR>
Extended Settings contain some additional information which is not supported by
the original firmware (current century, date/time formats, temperature
calibration, etc.), the settings are supported by Nocash Firmware, by the
no$gba emulator, and may be eventually also supported by other emulators. If
present, the values can be used by games, otherwise games should use either
whatever default settings, or contain their own configuration menu.<BR>
<BR>
<B>Extended Settings - loaded to 23FEE00h (aka fragments of NDS9 boot code)</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
  Addr Siz Expl.
  00h  8  ID "XbooInfo"
  08h  2  CRC16 Value [0Ch..0Ch+Length-1]
  0Ah  2  CRC16 Length (from 0Ch and up)
  0Ch  1  Version (currently 01h)
  0Dh  1  Update Count (newer = (older+1) AND FFh)
  0Eh  1  Bootmenu Flags
            Bit6   Important Info  (0=Disable, 1=Enable)
            Bit7   Bootmenu Screen (0=Upper, 1=Lower)
  0Fh  1  GBA Border (0=Black, 1=Gray Line)
  10h  2  Temperature Calibration TP0 ADC value  (x16) (sum of 16 ADC values)
  12h  2  Temperature Calibration TP1 ADC value  (x16) (sum of 16 ADC values)
  14h  2  Temperature Calibration Degrees Kelvin (x100) (0=none)
  16h  1  Temperature Flags
            Bit0-1 Format (0=Celsius, 1=Fahrenheit, 2=Reaumur, 3=Kelvin)
  17h  1  Backlight Intensity (0=0ff .. FFh=Full)
  18h  4  Date Century Offset       (currently 20, for years 2000..2099)
  1Ch  1  Date Month Recovery Value (1..12)
  1Dh  1  Date Day Recovery Value   (1..31)
  1Eh  1  Date Year Recovery Value  (0..99)
  1Fh  1  Date/Time Flags
            Bit0-1 Date Format   (0=YYYY-MM-DD, 1=MM-DD-YYYY, 2=DD-MM-YYYY)
            Bit2   Friendly Date (0=Raw Numeric, 1=With Day/Month Names)
            Bit5   Time DST      (0=Hide DST, 1=Show DST=On/Off)
            Bit6   Time Seconds  (0=Hide Seconds, 1=Show Seconds)
            Bit7   Time Format   (0=24 hour, 1=12 hour)
  20h  1  Date Separator      (Ascii, usually Slash, or Dot)
  21h  1  Time Separator      (Ascii, usually Colon, or Dot)
  22h  1  Decimal Separator   (Ascii, usually Comma, or Dot)
  23h  1  Thousands Separator (Ascii, usually Comma, or Dot)
  24h  1  Daylight Saving Time (Nth)
             Bit 0-3 Activate on (0..4 = Last,1st,2nd,3rd,4th)
             Bit 4-7 Deactivate on (0..4 = Last,1st,2nd,3rd,4th)
  25h  1  Daylight Saving Time (Day)
             Bit 0-3 Activate on (0..7 = Mon,Tue,Wed,Thu,Fri,Sat,Sun,AnyDay)
             Bit 4-7 Deactivate on (0..7 = Mon,Tue,Wed,Thu,Fri,Sat,Sun,AnyDay)
  26h  1  Daylight Saving Time (of Month)
             Bit 0-3 Activate DST in Month   (1..12)
             Bit 4-7 Deactivate DST in Month (1..12)
  27h  1  Daylight Saving Time (Flags)
             Bit 0   Current DST State (0=Off, 1=On)
             Bit 1   Adjust DST Enable (0=Disable, 1=Enable)
</TD></TR></TABLE>
Note: With the original firmware, the memory region at 23FEE00h and up contains
un-initialized, non-zero-filled data (fragments of boot code).<BR>
<BR>
<BR>
</BODY></HTML>
